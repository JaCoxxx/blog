<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[原]JS原生数组方法的用法及其实现"><meta name="keywords" content="Arrays,es6,原生"><meta name="author" content="JaCo Wu"><meta name="copyright" content="JaCo Wu"><title>[原]JS原生数组方法的用法及其实现 | JaCo Wu的博客</title><link rel="shortcut icon" href="/blog/img/640.jpg"><link rel="stylesheet" href="/blog/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66455669";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">2.</span> <span class="toc-text">forEach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">3.</span> <span class="toc-text">map()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">4.</span> <span class="toc-text">filter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#some"><span class="toc-number">5.</span> <span class="toc-text">some()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#every"><span class="toc-number">6.</span> <span class="toc-text">every()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copyWithin"><span class="toc-number">7.</span> <span class="toc-text">copyWithin()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill"><span class="toc-number">8.</span> <span class="toc-text">fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-number">9.</span> <span class="toc-text">concat()</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/blog/img/640.jpg"></div><div class="author-info__name text-center">JaCo Wu</div><div class="author-info__description text-center">一个默默无闻的前端攻城狮</div><div class="follow-button"><a href="https://github.com/JaCoxxx/JaCoxxx.github.io">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬博客</div><a class="author-info-links__name text-center" href="http://www.wclimb.site">wclimb</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/blog/img/paris_wallpaper.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">JaCo Wu的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">[原]JS原生数组方法的用法及其实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/js/">js</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 12 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>本文原载于<a href="https://blog.csdn.net/jacoox/article/details/82693994" target="_blank" rel="noopener">CSDN</a></p>
</blockquote>
<p>此文章将会介绍数组大部分的原生方法的用法，并自己实现一个具有相同功能的方法，不定期更新。顺序暂时看起来比较乱，所有方法都写完后会重新整理一下。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JS原生数组方法的参数都大致符合下面的通式（针对不同的参数，会在遇到之后补充），比较常见的方法一大部分都是遍历一遍数组，然后给每个元素执行一次提供的函数，也就是回调函数，所以实现基本都是基于遍历的。其他的，会在后面详细说明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.method( <span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// value : 必选，当前元素</span></span><br><span class="line">    <span class="comment">// index : 可选，当前元素索引值</span></span><br><span class="line">    <span class="comment">// arr : 可选，当前数组</span></span><br><span class="line">    <span class="comment">// thisValue : 可选，替换当前的this指向</span></span><br><span class="line">&#125;, thisValue)</span><br></pre></td></tr></table></figure>

<p>大致将数组方法分为两类，一类是改变原数组的方法，一类是不改变原数组的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 改变原数组</span></span><br><span class="line">arr.push();</span><br><span class="line">arr.pop();</span><br><span class="line">arr.unshift();</span><br><span class="line">arr.shift();</span><br><span class="line">arr.reverse();</span><br><span class="line">arr.solice();</span><br><span class="line">arr.sort();</span><br><span class="line">arr.copyWithin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不改变原数组</span></span><br><span class="line">arr.concat();</span><br><span class="line">arr.toString();</span><br><span class="line">arr.slice();</span><br><span class="line">arr.join();</span><br><span class="line">arr.split();</span><br><span class="line">arr.forEach();</span><br><span class="line">arr.map();</span><br><span class="line">arr.filter();</span><br><span class="line">arr.some();</span><br><span class="line">arr.every();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><blockquote>
<p><code>forEach()</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。</p>
</blockquote>
<p><code>forEach()</code> 没有什么好说的，就是遍历数组的所有元素，需要注意的就是此方法不会改变原数组。使用方法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>实现起来也很简单，就是遍历一次数组，然后给每个元素都执行一次回调函数，直接上实现代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123; <span class="comment">// 第一个参数必须是函数才能执行，否则报错</span></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i ++) &#123;</span><br><span class="line">            fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>) <span class="comment">// 将this绑定到回调函数之上，并传入参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，</span></span><br><span class="line"><span class="comment">// fn : 回调函数</span></span><br><span class="line"><span class="comment">// callback : this指向</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote>
<p><code>map()</code> 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
</blockquote>
<p><code>map()</code> 就相当于是在 <code>forEach()</code> 方法上的扩展，遍历所有元素并以相同的规则改变元素后返回一个新数组。用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val * index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [0, 2, 6, 12]</span></span><br></pre></td></tr></table></figure>

<p><code>map()</code> 就是加强版的 <code>forEach()</code> ，所以实现方法大致相同，只是多了一个返回新数组，实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [] <span class="comment">// 与 forEach() 的区别所在，返回一个新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i ++) &#123;</span><br><span class="line">        arr.push(fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote>
<p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
</blockquote>
<p>filter 过滤，透过；顾名思义，<code>filter()</code> 就是过滤元素的方法，返回一个由过滤的元素组成的新数组。用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (val % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p><code>filter()</code> 方法实现的重点就在于理解 return 返回值的真假决定了正在遍历的该元素是否加入新数组。在实现过程中用到了<code>push()</code>方法，此方法会在后面详细介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>, length3 = <span class="keyword">this</span>.length; k &lt; length3; k++)&#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值必定是一个 boolean 类型的</span></span><br><span class="line">            <span class="comment">// 所以可以直接利用 ‘&amp;&amp;’ 来判断当返回值为真的时候，将此元素加入到新数组之中   </span></span><br><span class="line">            fn.call(callback, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>) &amp;&amp; arr.push(<span class="keyword">this</span>[k])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><blockquote>
<p><code>some()</code> 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
</blockquote>
<p>some 一些。<code>some()</code> 就是当数组中只要有一个元素符合条件就返回真。用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> flag = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(flag) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>some()</code> 看起来用法和上面的几种差不多，实现起来自然也不会有太大差别，仅仅是多了一层 if 判断，判断是否符合条件，实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个不知道该称为什么点的一个点是用来设定当数组中有符合条件的值就是返回真</span></span><br><span class="line">    <span class="comment">// 并同时跳出循环，因为 some 只需要有至少一个满足就可以了</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, length2 = <span class="keyword">this</span>.length; j &lt; length2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="comment">// 这句是为了严谨起见</span></span><br><span class="line">            <span class="comment">// 虽然本身就已经是一个 boolean 值了，但是还是要加 !! 来强转一下</span></span><br><span class="line">            flag = !! fn.call(callback, <span class="keyword">this</span>[j], j, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><blockquote>
<p><code>every()</code> 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p>
</blockquote>
<p>every 所以。说到some，自然离不开every。every就是判断数组中是否所有的元素都满足条件，一旦有一个不满足就返回 false，用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> flag = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">val ,index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(flag) <span class="comment">// false</span></span><br><span class="line"> every() 与 some() 的实现方法相似，只有在真假的判断上有些许区别，不多说，直接看代码</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.myEvery = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// every 的设定就和 some 的完全相反了，some 是要至少一个，</span></span><br><span class="line">    <span class="comment">// every 是要全部满足，所以一旦有一个不满足就跳出循环并返回 false</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, length2 = <span class="keyword">this</span>.length; j &lt; length2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag === <span class="literal">false</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            flag = !!fn.call(callback, <span class="keyword">this</span>[j], j, <span class="keyword">this</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><blockquote>
<p><code>copyWithin()</code> 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</p>
</blockquote>
<p>copyWithin 看名字组成，就是数组内部的拷贝，相当于选择其中的一部分元素复制，粘贴到另一部分去，这就是一个用法不同于上面所说的通式的方法了。值得注意的地方是，此方法会改变原数组的元素，但不改变其大小。他的参数列表及用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line">arr.copyWithin(target, start, end)</span><br><span class="line"><span class="comment">// target : 必选，复制到指定位置的索引值</span></span><br><span class="line"><span class="comment">// start : 可选，元素复制的起始索引，缺失则从 0 开始</span></span><br><span class="line"><span class="comment">// end : 可选，元素复制的结束索引，默认值是 arr.length，可取负值，表示倒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>)) <span class="comment">// (7)[1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">1</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// (7)[1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">-2</span>)) <span class="comment">// (7)[1, 2, 3, 3, 3, 2, 2]</span></span><br></pre></td></tr></table></figure>

<p>第一次看到这个，肯定是看的头大吧， 不过没关系，接下来一步一步剖析整个过程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment">// 在这里我们定义 clArr 为要复制的数组片段</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>)) <span class="comment">// (7)[1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start, end 均取默认值，即 0, 7</span></span><br><span class="line"><span class="comment">// 所以 clArr = arr = [1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">// target = 3, 即从 arr[3] 开始复制,同时还要保证 arr 的大小不发生改变</span></span><br><span class="line"><span class="comment">// 所以复制后数组为 [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 当复制到数组最后一位时直接停止</span></span><br><span class="line"><span class="comment">// 从这里我们可以看出，重点就是找到clArr，只要找到clArr，一切都就迎刃而解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">1</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为copyWithin会改变原数组，所以此时的 arr = [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// start = 1, end = 7</span></span><br><span class="line"><span class="comment">// clArr = [2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 可以看到 clArr.length = end - start</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// (7)[1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"><span class="comment">// start = 2, end = 5</span></span><br><span class="line"><span class="comment">// clArr = [3, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"><span class="comment">// start = 4, end = 8</span></span><br><span class="line"><span class="comment">// clArr = [2, 3, 2]</span></span><br><span class="line"><span class="comment">// 可以看到虽然理论上 clArr.length = 4，但是由于start + clArr.length </span></span><br><span class="line"><span class="comment">// 已经超出原数组的长度，所以 clArr.length 会自动以原数组长度为准</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">-2</span>)) <span class="comment">// (7)[1, 2, 3, 3, 3, 2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"><span class="comment">// 由定义我们知道负值就是倒数，所以我们首先将其转换成整数</span></span><br><span class="line"><span class="comment">// 即 end = arr.length + end = 5</span></span><br><span class="line"><span class="comment">// start = 4, end = 5</span></span><br><span class="line"><span class="comment">// clArr = [3]</span></span><br></pre></td></tr></table></figure>

<p>看到这里相信你已经看懂了吧，会用了，下一步就是自己实现了，上面的过程基本也介绍了整个过程，就是首先确定 start 与 end ，然后根据二者的值确定要复制的数组片段，再根据 target 确定从何处开始复制。下面就是自己的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myCopyWithin = <span class="function"><span class="keyword">function</span>(<span class="params">target, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>, len = <span class="keyword">this</span>.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若传入了值就用传入的值，未传入就是用默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> end = end || len</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的实现与上面略有不同，这里首先判断 end 的值</span></span><br><span class="line">    <span class="comment">// 如果大于数组长度就给end 赋值数组长度，小于0，则取正序值</span></span><br><span class="line"></span><br><span class="line">    end = end &gt; len ? len : (end &lt; <span class="number">0</span> ? len + end : end)</span><br><span class="line">    <span class="keyword">var</span> clArr = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 是辅助索引值，len2 是 clArr 的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> index = start, len2 = end - start</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，确定 clArr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len2; i ++) &#123;</span><br><span class="line">        clArr[i] = <span class="keyword">this</span>[index]</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// len3 是遍历复制的结尾索引，加判断是防止 len3 大于原数组长度导致出错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len3 = target + len2</span><br><span class="line">    len3 = len3 &gt; len ? len : len3</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 clArr，将clArr复制到原数组指定位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> j = target; j &lt; len3; j ++) &#123;</span><br><span class="line">        arr[j] = clArr[index]</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><blockquote>
<p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p>
</blockquote>
<p>fill 填充，一个和 <code>copyWithin()</code> 类似的方法，因为他们都是往数组里面填充一个片段，不同的是一个填充的是本来的数组的内容，一个填充的是一个固定值。其参数列表与用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line"></span><br><span class="line">arr.fill(val, start, end)</span><br><span class="line"><span class="comment">// val : 必选，用来填充数组元素的值</span></span><br><span class="line"><span class="comment">// start : 可选，起始索引，默认值为0</span></span><br><span class="line"><span class="comment">// end : 可选，结束索引，默认值为arr.length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// (7) [5, 5, 5, 4, 5, 6, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">3</span>, <span class="number">5</span>)) <span class="comment">// (7) [5, 5, 5, 4, 5, 3, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">6</span>)) <span class="comment">// (7) [6, 6, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>

<p>用法看起来也是一目了然，实现起来也是很容易，实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">arguments</span>[<span class="number">0</span>], start = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="number">0</span>, end = <span class="built_in">arguments</span>[<span class="number">2</span>] || arr.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i ++) &#123;</span><br><span class="line">        arr[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><blockquote>
<p><code>concat()</code> 方法用于连接两个或多个数组。</p>
</blockquote>
<p>concat 合并多个数组，就是将传入的多个数组按顺序连接在目标数组后面，并且返回新数组 ，参数列表及用法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line">arr.concat(arr1, arr2, ...arrN)</span><br><span class="line"><span class="comment">// arr1, arr2, ... arrN : 必选，该参数可以是具体的值，也可以是数组对象。可以是任意多个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> newArr1 = arr1.concat(arr2, arr3)</span><br><span class="line"><span class="keyword">var</span> newArr2 = arr1.concat(arr2)</span><br><span class="line"><span class="keyword">var</span> newArr3 = arr1.concat(num1)</span><br><span class="line"><span class="built_in">console</span>.log(newArr1) <span class="comment">// [1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr2) <span class="comment">// [1, 2, 3, 4, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr3) <span class="comment">// [1, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure>

<p>此方法就是首先复制一个原数组的副本，然后将要连接的数组（数值）都拼接到后面，实现起来也很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myConcat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 得到形参列表的长度，判断需要几次循环来拼接</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 如果要拼接的是数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> len2 = <span class="built_in">arguments</span>[i].length</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len2; j ++) &#123;</span><br><span class="line">                arr[arr.length] = <span class="built_in">arguments</span>[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数值</span></span><br><span class="line">            arr[arr.length] = <span class="built_in">arguments</span>[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JaCo Wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jacoxxx.github.io/blog/js/cjz9964d7000zqwuzsxav2yqj/">https://jacoxxx.github.io/blog/js/cjz9964d7000zqwuzsxav2yqj/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jacoxxx.github.io/blog">JaCo Wu的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/Arrays/">Arrays</a><a class="post-meta__tags" href="/blog/tags/es6/">es6</a><a class="post-meta__tags" href="/blog/tags/原生/">原生</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/blog/js/cjz9964d80010qwuzokv5sflh/"><i class="fa fa-chevron-left">  </i><span>[原]JS原生数组方法的用法及其实现（二）</span></a></div><div class="next-post pull-right"><a href="/blog/css/cjz9964d5000uqwuz4z4ye7i9/"><span>[转]css加载会造成阻塞吗？</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTU1OS8yMjA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/blog/img/paris_wallpaper.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By JaCo Wu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.6.1"></script><script src="/blog/js/fancybox.js?version=1.6.1"></script><script src="/blog/js/sidebar.js?version=1.6.1"></script><script src="/blog/js/copy.js?version=1.6.1"></script><script src="/blog/js/fireworks.js?version=1.6.1"></script><script src="/blog/js/transition.js?version=1.6.1"></script><script src="/blog/js/scroll.js?version=1.6.1"></script><script src="/blog/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>