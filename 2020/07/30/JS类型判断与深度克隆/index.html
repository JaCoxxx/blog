<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JS类型判断与深度克隆"><meta name="keywords" content="es6,原生,引用类型"><meta name="author" content="JaCo Wu"><meta name="copyright" content="JaCo Wu"><title>JS类型判断与深度克隆 | JaCo Wu的博客</title><link rel="shortcut icon" href="https://jacokwu.cn/images/public/author.jpg"><link rel="stylesheet" href="/blog/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66455669";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类型判断"><span class="toc-number">1.</span> <span class="toc-text">类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">1.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof的迷惑行为"><span class="toc-number">1.2.</span> <span class="toc-text">typeof的迷惑行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-new-Number-1-‘object’"><span class="toc-number">1.2.1.</span> <span class="toc-text">typeof new Number(1) === ‘object’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-null-‘object’"><span class="toc-number">1.2.2.</span> <span class="toc-text">typeof null === ‘object’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-9-‘str’"><span class="toc-number">1.2.3.</span> <span class="toc-text">typeof 9 + ‘str’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-newStr-‘undefined’"><span class="toc-number">1.2.4.</span> <span class="toc-text">typeof newStr === ‘undefined’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-document-all-‘undefined’"><span class="toc-number">1.2.5.</span> <span class="toc-text">typeof document.all === ‘undefined’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">1.3.</span> <span class="toc-text">instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多全局对象"><span class="toc-number">1.3.1.</span> <span class="toc-text">多全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">1.4.</span> <span class="toc-text">constructor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.5.</span> <span class="toc-text">toString</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">1.6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-isArray-arg"><span class="toc-number">1.6.1.</span> <span class="toc-text">Array.isArray(arg)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isNaN-arg-Number-isNaN-arg"><span class="toc-number">1.6.2.</span> <span class="toc-text">isNaN(arg) / Number.isNaN(arg)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深度克隆"><span class="toc-number">2.</span> <span class="toc-text">深度克隆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#我们为什么需要深度克隆？"><span class="toc-number">2.1.</span> <span class="toc-text">我们为什么需要深度克隆？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现过程"><span class="toc-number">2.2.</span> <span class="toc-text">实现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本数据类型变量克隆"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本数据类型变量克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp克隆"><span class="toc-number">2.2.2.</span> <span class="toc-text">RegExp克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date克隆"><span class="toc-number">2.2.3.</span> <span class="toc-text">Date克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array克隆"><span class="toc-number">2.2.4.</span> <span class="toc-text">Array克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object克隆"><span class="toc-number">2.2.5.</span> <span class="toc-text">Object克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dom克隆"><span class="toc-number">2.2.6.</span> <span class="toc-text">Dom克隆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-4"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://jacokwu.cn/images/public/author.jpg"></div><div class="author-info__name text-center">JaCo Wu</div><div class="author-info__description text-center">一个默默无闻的前端攻城狮</div><div class="follow-button"><a href="https://github.com/JaCoxxx/JaCoxxx.github.io">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">41</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">大佬博客</div><a class="author-info-links__name text-center" href="http://www.wclimb.site">wclimb</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/oliverchu">Oliver Chu</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://jacokwu.cn/images/public/background.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">JaCo Wu的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">JS类型判断与深度克隆</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/js/">js</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 17 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>要进行深度克隆，首先就需要知道进行克隆的这个变量是什么类型的值，知道了是什么类型的，我们才能分门别类的去根本不同的类型进行克隆。所以我们先介绍如何进行准确的类型判断。</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>首先我们需要知道JavaScript都有哪些数据类型。</p>
<p>基本数据类型：Undefined、Null、Boolean、Number、 String 和 Symbol。<br>引用数据类型：Object。</p>
<p>定义一些变量方便后面使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">''</span></span><br><span class="line"><span class="keyword">const</span> _undefined = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> _null = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> bool = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/a/</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">const</span> dom = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>拓展</strong> – bigInt</li>
</ul>
<blockquote>
<p>BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数BigInt()。</p>
</blockquote>
<p>这是一个新的基本数据类型。如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bigNum = <span class="number">10</span>n</span><br><span class="line"><span class="keyword">const</span> oldNum = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bigNum) <span class="comment">// 'bigint'</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum === oldNum) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum == oldNum) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum + bigNum) <span class="comment">// 20n</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum + oldNum) <span class="comment">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span></span><br></pre></td></tr></table></figure>

<p>详细可以看以下两篇内容：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">MDN - BigInt</a>，<a href="https://segmentfault.com/a/1190000019912017" target="_blank" rel="noopener">JS最新基本数据类型:BigInt</a>。</p>
<hr>
<p>然后我们看看有哪些方法可以去判断一个变量的类型呢？</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote>
<p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型。</p>
</blockquote>
<p>我们看看上面定义的变量的表现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> str <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> _undefined <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> _null <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> bool <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> sym <span class="comment">// "symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> func <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> reg <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> date <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> dom <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>可以看出来有些变量的表现让人比较不满意，所以在涉及到引用变量的时候，使用<code>typeof</code>时还是要注意的。</p>
<h3 id="typeof的迷惑行为"><a href="#typeof的迷惑行为" class="headerlink" title="typeof的迷惑行为"></a>typeof的迷惑行为</h3><h4 id="typeof-new-Number-1-‘object’"><a href="#typeof-new-Number-1-‘object’" class="headerlink" title="typeof new Number(1) === ‘object’"></a>typeof new Number(1) === ‘object’</h4><p>什么？<code>new Number(1)</code>不是个数字吗？<br>这是因为使用<code>new</code>操作符创建的变量都是这个构造函数的实例，被加在了原型链上，尽管他仍然等于 1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newNum) <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line">newNum === <span class="number">1</span> <span class="comment">// false</span></span><br><span class="line">newNum + <span class="number">1</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>因为这个迷惑行为，所以非必要时，不要使用<code>new</code>操作符去创建一个基本类型的变量，这可能会导致不必要的麻烦。</p>
<h4 id="typeof-null-‘object’"><a href="#typeof-null-‘object’" class="headerlink" title="typeof null === ‘object’"></a>typeof null === ‘object’</h4><p>什么？<code>null</code>不是属于基本数据类型<code>null</code>吗？<br>这个大家应该都清楚，从 JavaScript 诞生到现在一直都是这样。</p>
<blockquote>
<p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于<code>null</code>代表的是空指针（大多数平台下值为<code>0x00</code>），因此，<code>null</code>的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。</p>
</blockquote>
<h4 id="typeof-9-‘str’"><a href="#typeof-9-‘str’" class="headerlink" title="typeof 9 + ‘str’"></a>typeof 9 + ‘str’</h4><p>什么？<code>9 + &#39;str&#39;</code>不是属于字符串的拼接，属于<code>string</code>类型吗？<br>这是因为<strong>运算符的优先级</strong>，<code>typeof</code>的优先级要高于<code>+</code>，所以会先得到<code>typeof 9</code>的值为<code>&#39;number&#39;</code>，然后计算<code>&#39;number&#39; + &#39;str&#39;</code>，得到最终结果为<code>&#39;numberstr&#39;</code>。<br>如果是这样写：<code>typeof (9 + &#39;str&#39;)</code>。得到的结果就是<code>&#39;string&#39;</code>。</p>
<ul>
<li><strong>拓展</strong> – 运算符优先级</li>
</ul>
<p>下面列出了常用的运算符的优先级。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></p>
<h4 id="typeof-newStr-‘undefined’"><a href="#typeof-newStr-‘undefined’" class="headerlink" title="typeof newStr === ‘undefined’"></a>typeof newStr === ‘undefined’</h4><p>这个需要分情况讨论，看下面一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> varStr === <span class="string">'undefined'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> letStr === <span class="string">'undefined'</span>)</span><br><span class="line"><span class="keyword">let</span> letStr</span><br></pre></td></tr></table></figure>

<p>执行这段代码的结果会是什么呢？</p>
<p>首先有个前置知识。</p>
<blockquote>
<p>在 ECMAScript 2015 之前，typeof 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，typeof 也能返回 ‘undefined’。使用 typeof 永远不会抛出错误。</p>
</blockquote>
<p>所以第一行的答案必是<code>true</code>。那第二行呢？</p>
<hr>
<p>在看正确答案之前我们先复习一下<code>var let const</code>。</p>
<p><code>var</code>关联词用来声明一个<strong>可变</strong>的本地变量，在<strong>全局范围</strong>内都有效，也就是说，当你用<code>var</code>声明了一个变量的时候，他就会在全局声明时创建一个属性。<br><code>let</code>关联词用来声明一个<strong>可变</strong>的本地变量，在其<strong>作用域或子块</strong>内都有效，也就是说，当你用<code>let</code>声明了一个变量的时候，在此之前或者作用域之外都是不能使用这个变量的。<br><code>const</code>关联词用来声明一个<strong>不可变</strong>的本地变量，在其<strong>作用域或子块</strong>内都有效，也就是说，当你用<code>const</code>声明了一个变量的时候，他和<code>let</code>声明的变量有着同样的作用域，但无法更改。</p>
<p>我们通过一个简单的for循环理解一下<code>var</code>和<code>let</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">300</span>) <span class="comment">// 10 个 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(j), <span class="number">300</span>) <span class="comment">// 0 ~ 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// Uncaught ReferenceError: j is not defined</span></span><br></pre></td></tr></table></figure>

<p>对于第一个for循环，<code>var</code>定义的<code>i</code>被<strong>提升</strong>到了代码开头，在全局范围内都有效，所以全局只有一个变量<code>i</code>，循环的每一层都是去改变这个<code>i</code>的值；而循环内部的<code>setTimeout</code>都被加到了执行队列的尾端，执行其内部的方法时就会去寻找全局的<code>i</code>，这个时候的i就已经时被改变成最后的值<code>10</code>。同理在for循环外部的打印也是去找的全局变量<code>i</code>。</p>
<p>对于第二个for循环。<code>let</code>定义的j只在其当轮的作用域下有效，所以每次循环其实都是一个新的变量<code>j</code>；而循环内部的<code>setTimeout</code>同样都被加到了执行队列的尾端，但是每个<code>setTimeout</code>在执行的时候都会去找其对应的作用域下的值，也就是会输出正确的<code>0 - 9</code>。在for循环外部的打印，因为其不在定义<code>j</code>的作用域范围内，所以会报错。</p>
<hr>
<p>看到这里，最开始的那一段代码的结果就显而易见了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> varStr === <span class="string">'undefined'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> letStr === <span class="string">'undefined'</span>) <span class="comment">// Uncaught ReferenceError: letStr is not defined</span></span><br><span class="line"><span class="keyword">let</span> letStr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在加入了块级作用域的 let 和 const 之后，在其被声明之前对块中的 let 和 const 变量使用 typeof 会抛出一个 ReferenceError。块作用域变量在块的头部处于“暂存死区”，直至其被初始化，在这期间，访问变量将会引发错误。</p>
</blockquote>
<h4 id="typeof-document-all-‘undefined’"><a href="#typeof-document-all-‘undefined’" class="headerlink" title="typeof document.all === ‘undefined’"></a>typeof document.all === ‘undefined’</h4><p>什么？<code>document.all</code>不是当前页面的标签的集合，属于<code>object</code>类型吗？<br>这是一个例外，在MDN中是这样说的。</p>
<blockquote>
<p>尽管规范允许为非标准的外来对象自定义类型标签，但它要求这些类型标签与已有的不同。document.all 的类型标签为 ‘undefined’ 的例子在 Web 领域中被归类为对原 ECMA JavaScript 标准的“故意侵犯”。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>typeof</code>可以用来对基本数据类型变量（通过<code>new</code>定义的除外）做类型校验，也可以用来区分是否是引用型变量；但是在用的时候需要注意上面所说的一些特殊情况。</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p><code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<p>我们看看上面定义的变量的表现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line">_undefined <span class="keyword">instanceof</span>  <span class="comment">// ❌</span></span><br><span class="line">_null <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line">bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// false</span></span><br><span class="line">sym <span class="keyword">instanceof</span> <span class="built_in">Symbol</span> <span class="comment">// false</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">func <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">dom <span class="keyword">instanceof</span> HTMLBodyElement <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>然后我们看看对于由构造函数创建的基本类型的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> conNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> conStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>)</span><br><span class="line"><span class="keyword">const</span> conBoo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line">conNum <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">conStr <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line">conBoo <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以及当右边为<code>Object</code>时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conStr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">_null <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line">conNum <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">conBoo <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">func <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">dom <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>instanceof</code>会在你的原型链上去找关联关系，第一层就是每个变量所对应的构造函数，而<code>Object</code>就是在原型链上能找到的终点了。</p>
<p>至于<code>null</code>，虽然<code>typeof null === &#39;object&#39;</code>，而且<code>Object.prototype.__proto__ === null</code>；但是实际上，null并不存在原型链，他就是一个简简单单的null，没有任何属性。</p>
<p>下面这种神图，相信大家都有看过，<code>instanceof</code>就是在这个链上一层层去找的。</p>
<p><img src="https://jacokwu.cn/images/blog/prototype.jpg" alt="原型链"></p>
<h4 id="多全局对象"><a href="#多全局对象" class="headerlink" title="多全局对象"></a>多全局对象</h4><blockquote>
<p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式<code>[] instanceof window.frames[0].Array</code>会返回<code>false</code>，因为<code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">instanceof</a></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>instanceof</code>可以用来判断引用数据类型变量的具体类型以及由<code>new</code>定义的基本数据类型变量的类型。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote>
<p><code>constructor</code>是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。</p>
</blockquote>
<p><code>constructor</code>返回的是当前变量的构造器，和<code>instanceof</code>一样都是在原型链上操作。先看下之前定义的变量的表现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.constructor) <span class="comment">// String</span></span><br><span class="line"><span class="built_in">console</span>.log(_undefined.constructor) <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(_null.constructor) <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor) <span class="comment">// Number</span></span><br><span class="line"><span class="built_in">console</span>.log(bool.constructor) <span class="comment">// Boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.constructor) <span class="comment">// Symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor) <span class="comment">// Array</span></span><br><span class="line"><span class="built_in">console</span>.log(func.constructor) <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor) <span class="comment">// RegExp</span></span><br><span class="line"><span class="built_in">console</span>.log(date.constructor) <span class="comment">// Date</span></span><br><span class="line"><span class="built_in">console</span>.log(dom.constructor) <span class="comment">// HTMLBodyElement</span></span><br></pre></td></tr></table></figure>

<p>可以看出来除了<code>null</code>和<code>undefined</code>都可以使用<code>constructor</code>属性得到其的构造函数，也就是准确的类型。</p>
<ul>
<li>注意：数值不能直接使用<code>constructor</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1.</span><span class="keyword">constructor</span>) // Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">console.log((1).<span class="keyword">constructor</span>) // Number</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><code>constructor</code>可以判断除了<code>null</code>和<code>undefined</code>外的所有变量的类型。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><blockquote>
<p><code>toString()</code>方法返回一个表示该对象的字符串。</p>
</blockquote>
<p><code>toString()</code>是<code>Object</code>原型链上的方法，如果直接调用返回的值是其转换成字符串的值，我们可以通过<code>call</code>方法来调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _toString = <span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(str)</span><br><span class="line"><span class="built_in">console</span>.log(_toString(str)) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(_undefined)) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(_null)) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(num)) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(bool)) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(sym)) <span class="comment">// [object Symbol]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(obj)) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(arr)) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(func)) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(reg)) <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(date)) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(dom)) <span class="comment">// [object HTMLBodyElement]</span></span><br></pre></td></tr></table></figure>

<p>那么，我们为什么要通过<code>call</code>来调用呢？</p>
<p>首先一点是，<code>Object</code>的<code>toString</code>方法会返回一个<code>[object ${calss}]</code>的形式的字符串，在<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4.2" target="_blank" rel="noopener">ecma</a>中是这样说的：“Return the String value that is the result of concatenating the three Strings “[object “, class, and “]”.”；翻译过来就是“返回字符串值，该值是将三个字符串“[object”，class和“]”连接在一起的结果”。所以我们可以使用这个方法去判断变量类型。</p>
<p>其次是，大部分的类型都重写了<code>Object</code>的<code>toString</code>方法，也就是每个类型的变量去直接调用结果的表现都是不一样的，所以我们需要通过<code>call</code>去调用<code>Object</code>的<code>toString</code>方法。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>toString</code>可以用来准确的判断一个变量的类型。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Array-isArray-arg"><a href="#Array-isArray-arg" class="headerlink" title="Array.isArray(arg)"></a>Array.isArray(arg)</h4><p>对于数组，<code>Array</code>给我们专门提供了<code>Array.isArray(arg)</code>来判断<code>arg</code>是否是数组。</p>
<p>其实现方法很简单，就是封装了<code>toString</code>，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然其内部的实现肯定不会这么简单，至少也要加上类型判断。</p>
<h4 id="isNaN-arg-Number-isNaN-arg"><a href="#isNaN-arg-Number-isNaN-arg" class="headerlink" title="isNaN(arg) / Number.isNaN(arg)"></a>isNaN(arg) / Number.isNaN(arg)</h4><p><code>isNaN</code>是提供给我们的一个全局方法，<code>Number.isNaN</code>则是<code>Number</code>的一个原型方法。二者均是用来判断<code>NaN</code>的，后者比前者更加稳妥。如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'NaN'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'NaN'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'23'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'23'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'abc'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'abc'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以发现，当参数为非数字类型时，<code>isNaN</code>会先尝试将其转换为数值，然后去判断转换后的值是否为<code>NaN</code>，所以会有很多的迷惑行为。<br>而对于<code>Number.isNaN</code>，其并不会去尝试转换参数，而是直接去判断参数是否为<code>NaN</code>，哪怕是字符串的<code>&#39;NaN&#39;</code>都不行，所以推荐使用<code>Number.isNaN</code>。</p>
<p>#### </p>
<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><p>学习了几种类型判断的方法，下面我们正式开始深度克隆。</p>
<h3 id="我们为什么需要深度克隆？"><a href="#我们为什么需要深度克隆？" class="headerlink" title="我们为什么需要深度克隆？"></a>我们为什么需要深度克隆？</h3><p>首先看下面这段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">let</span> newStr = str</span><br><span class="line">newStr += <span class="string">'4'</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr</span><br><span class="line">newArr.push(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(newStr)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>

<p>在这段代码中，newArr是arr的复制，newStr是str的复制；但是结果是arr跟着newArr改变了。</p>
<p>出现这种情况的原因是，在JavaScript中，普通数据类型都存在栈（栈内存）中，占用空间大小固定；引用数据类型都存在堆（堆内存）中，通过指针建立联系。而引用类型的值的复制，只是给新变量B添加了一个指针b，指向了被复制变量A的指针a所指向的内存，也就是说，B虽然是经过A复制得来，但是他们指向的始终还是同一个值，所以会一个变，另一个跟着变。如下所示。</p>
<iframe src="https://show.zohopublic.com.cn/publish/akx8s75d8e674921945c3992fc73634c613e9" height="442" width="100%" name="%E5%8F%98%E9%87%8F%E5%AD%98%E5%80%BC" scrolling="no" frameborder="0" style="border:1px solid #AABBCC" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

<p>为了避免这种指向同一地址，联动更改的问题，就需要用到深度克隆，使得复制出来的变量是一个全新的变量，不会对以前的变量产生其他影响。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>先搭个架子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arg) <span class="keyword">return</span> arg</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本数据类型变量克隆"><a href="#基本数据类型变量克隆" class="headerlink" title="基本数据类型变量克隆"></a>基本数据类型变量克隆</h4><p>然后我们由上一节得知，深度遍历主要就是针对的引用型变量，所以第一步就是先区分出基本变量和引用型变量。区分是否引用型变量可以使用<code>typeof</code>。</p>
<p>这一步有几点需要注意一下， 一个是<code>function</code>，<code>typeof fun === &#39;function&#39;</code>，而对于<code>function</code>来说，直接复制是没有问题的，所以不需要考虑这个。<br>还有一个是<code>document.all</code>，<code>typeof document.all === &#39;undefined&#39;</code>，<code>document.all</code>并不被推荐使用，且其中的关键信息都是只读的，所以在这里不考虑其的复制。<br>还有一个是通过<code>new</code>定义的基本类型变量，这些变量会通过第一步的判断，所以我们留在下一步讨论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区分基本类型变量和引用类型变量</span></span><br><span class="line"><span class="comment">// 对于基本类型变量可以直接复制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'object) &#123;</span></span><br><span class="line"><span class="string">	return arg</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后第二步，我们需要分类型考虑各类型的复制。不过在此之前，需要先分辨出各类型。</p>
<p>在这里，用的是<code>toString</code>，当然，其他的也可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(arg)</span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Date]'</span>: <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Array]'</span>: <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Object]'</span>: <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过switch去处理不同类型的克隆，而default分支就用来处理通过了第一步判断的基本类型的变量，可以直接返回。</p>
<h4 id="RegExp克隆"><a href="#RegExp克隆" class="headerlink" title="RegExp克隆"></a><code>RegExp</code>克隆</h4><p>我们需要先了解几个<code>RegExp</code>的内置属性。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>source</td>
<td>source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。</td>
</tr>
<tr>
<td>global</td>
<td>global 属性表明正则表达式是否使用了 “g” 标志。global 是一个正则表达式实例的只读属性。</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>ignoreCase 属性表明正则表达式是否使用了 “i” 标志。ignoreCase 是正则表达式实例的只读属性。</td>
</tr>
<tr>
<td>multiline</td>
<td>multiline 属性表明正则表达式是否使用了 “m” 标志。multiline 是正则表达式实例的一个只读属性。</td>
</tr>
</tbody></table>
<p>我们需要获取源正则对象的字符串和其标志，然后生成一个新的正则。如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: </span><br><span class="line">		<span class="keyword">let</span> flag = <span class="string">''</span></span><br><span class="line">		<span class="keyword">if</span> (arg.global) flag.push(<span class="string">'g'</span>)</span><br><span class="line">		<span class="keyword">if</span> (arg.ignoreCase) flag.push(<span class="string">'i'</span>)</span><br><span class="line">		<span class="keyword">if</span> (arg.multiline) flag.push(<span class="string">'m'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(arg.source, flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在支持es6的环境中，我们可以不用这么麻烦，直接生成即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为从es6开始，当第一个参数为正则表达式而第二个标志参数存在时，new RegExp(/ab+c/, ‘i’) 不再抛出 TypeError （”从另一个RegExp构造一个RegExp时无法提供标志”）的异常，取而代之，将使用这些参数创建一个新的正则表达式。</p>
<h4 id="Date克隆"><a href="#Date克隆" class="headerlink" title="Date克隆"></a><code>Date</code>克隆</h4><p>对于时间，我们可以直接获取其时间戳，然后新生成一个即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Date]'</span>: </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Array克隆"><a href="#Array克隆" class="headerlink" title="Array克隆"></a><code>Array</code>克隆</h4><p>对于数组，可以通过遍历去处理数组内部每一项的值，而这些值又可能是任何属性，所以这里需要用递归去处理这些值。</p>
<p>这里要注意，不能使用解构，因为解构并不会改变数组内部值的组成，所以对于内部值，仍然是浅克隆。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Array]'</span>:</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arg.length; i ++) &#123;</span><br><span class="line">      result[i] = deepClone(arg[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object克隆"><a href="#Object克隆" class="headerlink" title="Object克隆"></a><code>Object</code>克隆</h4><p>对于对象，和数组类似，都要使用递归去处理其内部值，而不同点在于，对象还需要处理其原型链、只读属性或者是修改过属性的值等等。</p>
<p>首先是处理原型链，可以用<code>Object.getPrototypeOf()</code>和<code>Object.create()</code>，前者作用是返回指定对象的原型；后者作用是创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.create(proto)</span><br></pre></td></tr></table></figure>

<p>然后是只读属性或者是修改过属性的值，可以用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>，前者作用是返回指定对象上一个自有属性对应的属性描述符；后者作用是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rule = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(newObj, <span class="string">'foo'</span>, rule)</span><br></pre></td></tr></table></figure>

<p>然后合在一起处理就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'[object Object]'</span>:</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(arg)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> arg) &#123;</span><br><span class="line">      <span class="keyword">let</span> rule = <span class="built_in">Object</span>.getOwnPropertyDescriptor(arg, item)</span><br><span class="line">      rule.value = rule.value &amp;&amp; deepClone(rule.value)</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(result, item, rule)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dom克隆"><a href="#Dom克隆" class="headerlink" title="Dom克隆"></a><code>Dom</code>克隆</h4><p>Dom可能是几个节点的集合，也可能是单一的节点。因为节点的集合属于<code>HTMLCollection</code>接口，而这个接口是会自动更新的，所以不考虑这个。而对于单一节点，根据其节点名称的不同，<code>toString</code>返回的结果也不相同，所以我们使用节点的一个属性<code>nodeTpy</code>来判断其是否是dom节点。</p>
<p>这里还要用到一个内置方法<code>Node.cloneNode()</code>，其返回调用该方法的节点的一个副本；接收一个参数<code>deep</code>，参数如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg.nodeType &amp;&amp; <span class="string">'cloneNode'</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.cloneNode(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>目前是做了基本的深度克隆，但是还有很多缺陷，比如没有考虑过循环引用以及层数过多时递归会爆栈，后面会继续做优化。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">JavaScript高级程序设计</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN</a><br><a href="https://segmentfault.com/a/1190000019912017" target="_blank" rel="noopener">JS最新基本数据类型:BigInt</a><br><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator" target="_blank" rel="noopener">ECMAScript (ECMA-262)</a><br><a href="https://www.jianshu.com/p/2a3728cded4c" target="_blank" rel="noopener">JavaScript中如何实现深度克隆</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JaCo Wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jacokwu.cn/blog/2020/07/30/JS类型判断与深度克隆/">https://jacokwu.cn/blog/2020/07/30/JS类型判断与深度克隆/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jacokwu.cn/blog">JaCo Wu的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/es6/">es6</a><a class="post-meta__tags" href="/blog/tags/原生/">原生</a><a class="post-meta__tags" href="/blog/tags/引用类型/">引用类型</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/blog/2020/11/17/gulp入门-gulpfile文件/"><i class="fa fa-chevron-left">  </i><span>gulp入门-gulpfile文件</span></a></div><div class="next-post pull-right"><a href="/blog/2020/07/09/从数组到栈与队列/"><span>从数组到栈与队列</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '49402195632a617e3708',
  clientSecret: '887d4bded9e50678007602a209d9191c8e2d8dbf',
  repo: 'blog',
  owner: 'JaCoxxx',
  admin: 'JaCoxxx',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://jacokwu.cn/images/public/background.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By JaCo Wu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.6.1"></script><script src="/blog/js/fancybox.js?version=1.6.1"></script><script src="/blog/js/sidebar.js?version=1.6.1"></script><script src="/blog/js/copy.js?version=1.6.1"></script><script src="/blog/js/fireworks.js?version=1.6.1"></script><script src="/blog/js/transition.js?version=1.6.1"></script><script src="/blog/js/scroll.js?version=1.6.1"></script><script src="/blog/js/head.js?version=1.6.1"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>