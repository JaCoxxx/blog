<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS类型判断与深度克隆</title>
      <link href="/blog/2020/07/30/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
      <url>/blog/2020/07/30/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/</url>
      
        <content type="html"><![CDATA[<p>要进行深度克隆，首先就需要知道进行克隆的这个变量是什么类型的值，知道了是什么类型的，我们才能分门别类的去根本不同的类型进行克隆。所以我们先介绍如何进行准确的类型判断。</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>首先我们需要知道JavaScript都有哪些数据类型。</p><p>基本数据类型：Undefined、Null、Boolean、Number、 String 和 Symbol。<br>引用数据类型：Object。</p><p>定义一些变量方便后面使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">''</span></span><br><span class="line"><span class="keyword">const</span> _undefined = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> _null = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> bool = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/a/</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">const</span> dom = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>拓展</strong> – bigInt</li></ul><blockquote><p>BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数BigInt()。</p></blockquote><p>这是一个新的基本数据类型。如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bigNum = <span class="number">10</span>n</span><br><span class="line"><span class="keyword">const</span> oldNum = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bigNum) <span class="comment">// 'bigint'</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum === oldNum) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum == oldNum) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum + bigNum) <span class="comment">// 20n</span></span><br><span class="line"><span class="built_in">console</span>.log(bigNum + oldNum) <span class="comment">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span></span><br></pre></td></tr></table></figure><p>详细可以看以下两篇内容：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">MDN - BigInt</a>，<a href="https://segmentfault.com/a/1190000019912017" target="_blank" rel="noopener">JS最新基本数据类型:BigInt</a>。</p><hr><p>然后我们看看有哪些方法可以去判断一个变量的类型呢？</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote><p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型。</p></blockquote><p>我们看看上面定义的变量的表现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> str <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> _undefined <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> _null <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> bool <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> sym <span class="comment">// "symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> func <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> reg <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> date <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> dom <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>可以看出来有些变量的表现让人比较不满意，所以在涉及到引用变量的时候，使用<code>typeof</code>时还是要注意的。</p><h3 id="typeof的迷惑行为"><a href="#typeof的迷惑行为" class="headerlink" title="typeof的迷惑行为"></a>typeof的迷惑行为</h3><h4 id="typeof-new-Number-1-‘object’"><a href="#typeof-new-Number-1-‘object’" class="headerlink" title="typeof new Number(1) === ‘object’"></a>typeof new Number(1) === ‘object’</h4><p>什么？<code>new Number(1)</code>不是个数字吗？<br>这是因为使用<code>new</code>操作符创建的变量都是这个构造函数的实例，被加在了原型链上，尽管他仍然等于 1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newNum) <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line">newNum === <span class="number">1</span> <span class="comment">// false</span></span><br><span class="line">newNum + <span class="number">1</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>因为这个迷惑行为，所以非必要时，不要使用<code>new</code>操作符去创建一个基本类型的变量，这可能会导致不必要的麻烦。</p><h4 id="typeof-null-‘object’"><a href="#typeof-null-‘object’" class="headerlink" title="typeof null === ‘object’"></a>typeof null === ‘object’</h4><p>什么？<code>null</code>不是属于基本数据类型<code>null</code>吗？<br>这个大家应该都清楚，从 JavaScript 诞生到现在一直都是这样。</p><blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于<code>null</code>代表的是空指针（大多数平台下值为<code>0x00</code>），因此，<code>null</code>的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。</p></blockquote><h4 id="typeof-9-‘str’"><a href="#typeof-9-‘str’" class="headerlink" title="typeof 9 + ‘str’"></a>typeof 9 + ‘str’</h4><p>什么？<code>9 + &#39;str&#39;</code>不是属于字符串的拼接，属于<code>string</code>类型吗？<br>这是因为<strong>运算符的优先级</strong>，<code>typeof</code>的优先级要高于<code>+</code>，所以会先得到<code>typeof 9</code>的值为<code>&#39;number&#39;</code>，然后计算<code>&#39;number&#39; + &#39;str&#39;</code>，得到最终结果为<code>&#39;numberstr&#39;</code>。<br>如果是这样写：<code>typeof (9 + &#39;str&#39;)</code>。得到的结果就是<code>&#39;string&#39;</code>。</p><ul><li><strong>拓展</strong> – 运算符优先级</li></ul><p>下面列出了常用的运算符的优先级。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></p><h4 id="typeof-newStr-‘undefined’"><a href="#typeof-newStr-‘undefined’" class="headerlink" title="typeof newStr === ‘undefined’"></a>typeof newStr === ‘undefined’</h4><p>这个需要分情况讨论，看下面一段代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> varStr === <span class="string">'undefined'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> letStr === <span class="string">'undefined'</span>)</span><br><span class="line"><span class="keyword">let</span> letStr</span><br></pre></td></tr></table></figure><p>执行这段代码的结果会是什么呢？</p><p>首先有个前置知识。</p><blockquote><p>在 ECMAScript 2015 之前，typeof 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，typeof 也能返回 ‘undefined’。使用 typeof 永远不会抛出错误。</p></blockquote><p>所以第一行的答案必是<code>true</code>。那第二行呢？</p><hr><p>在看正确答案之前我们先复习一下<code>var let const</code>。</p><p><code>var</code>关联词用来声明一个<strong>可变</strong>的本地变量，在<strong>全局范围</strong>内都有效，也就是说，当你用<code>var</code>声明了一个变量的时候，他就会在全局声明时创建一个属性。<br><code>let</code>关联词用来声明一个<strong>可变</strong>的本地变量，在其<strong>作用域或子块</strong>内都有效，也就是说，当你用<code>let</code>声明了一个变量的时候，在此之前或者作用域之外都是不能使用这个变量的。<br><code>const</code>关联词用来声明一个<strong>不可变</strong>的本地变量，在其<strong>作用域或子块</strong>内都有效，也就是说，当你用<code>const</code>声明了一个变量的时候，他和<code>let</code>声明的变量有着同样的作用域，但无法更改。</p><p>我们通过一个简单的for循环理解一下<code>var</code>和<code>let</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">300</span>) <span class="comment">// 10 个 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(j), <span class="number">300</span>) <span class="comment">// 0 ~ 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// Uncaught ReferenceError: j is not defined</span></span><br></pre></td></tr></table></figure><p>对于第一个for循环，<code>var</code>定义的<code>i</code>被<strong>提升</strong>到了代码开头，在全局范围内都有效，所以全局只有一个变量<code>i</code>，循环的每一层都是去改变这个<code>i</code>的值；而循环内部的<code>setTimeout</code>都被加到了执行队列的尾端，执行其内部的方法时就会去寻找全局的<code>i</code>，这个时候的i就已经时被改变成最后的值<code>10</code>。同理在for循环外部的打印也是去找的全局变量<code>i</code>。</p><p>对于第二个for循环。<code>let</code>定义的j只在其当轮的作用域下有效，所以每次循环其实都是一个新的变量<code>j</code>；而循环内部的<code>setTimeout</code>同样都被加到了执行队列的尾端，但是每个<code>setTimeout</code>在执行的时候都会去找其对应的作用域下的值，也就是会输出正确的<code>0 - 9</code>。在for循环外部的打印，因为其不在定义<code>j</code>的作用域范围内，所以会报错。</p><hr><p>看到这里，最开始的那一段代码的结果就显而易见了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> varStr === <span class="string">'undefined'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> letStr === <span class="string">'undefined'</span>) <span class="comment">// Uncaught ReferenceError: letStr is not defined</span></span><br><span class="line"><span class="keyword">let</span> letStr</span><br></pre></td></tr></table></figure><blockquote><p>在加入了块级作用域的 let 和 const 之后，在其被声明之前对块中的 let 和 const 变量使用 typeof 会抛出一个 ReferenceError。块作用域变量在块的头部处于“暂存死区”，直至其被初始化，在这期间，访问变量将会引发错误。</p></blockquote><h4 id="typeof-document-all-‘undefined’"><a href="#typeof-document-all-‘undefined’" class="headerlink" title="typeof document.all === ‘undefined’"></a>typeof document.all === ‘undefined’</h4><p>什么？<code>document.all</code>不是当前页面的标签的集合，属于<code>object</code>类型吗？<br>这是一个例外，在MDN中是这样说的。</p><blockquote><p>尽管规范允许为非标准的外来对象自定义类型标签，但它要求这些类型标签与已有的不同。document.all 的类型标签为 ‘undefined’ 的例子在 Web 领域中被归类为对原 ECMA JavaScript 标准的“故意侵犯”。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>typeof</code>可以用来对基本数据类型变量（通过<code>new</code>定义的除外）做类型校验，也可以用来区分是否是引用型变量；但是在用的时候需要注意上面所说的一些特殊情况。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p><code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上。</p></blockquote><p>我们看看上面定义的变量的表现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line">_undefined <span class="keyword">instanceof</span>  <span class="comment">// ❌</span></span><br><span class="line">_null <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line">bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// false</span></span><br><span class="line">sym <span class="keyword">instanceof</span> <span class="built_in">Symbol</span> <span class="comment">// false</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">func <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">dom <span class="keyword">instanceof</span> HTMLBodyElement <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>然后我们看看对于由构造函数创建的基本类型的变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> conNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> conStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>)</span><br><span class="line"><span class="keyword">const</span> conBoo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line">conNum <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">conStr <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line">conBoo <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以及当右边为<code>Object</code>时。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conStr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">_null <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line">conNum <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">conBoo <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">func <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">dom <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这是因为<code>instanceof</code>会在你的原型链上去找关联关系，第一层就是每个变量所对应的构造函数，而<code>Object</code>就是在原型链上能找到的终点了。</p><p>至于<code>null</code>，虽然<code>typeof null === &#39;object&#39;</code>，而且<code>Object.prototype.__proto__ === null</code>；但是实际上，null并不存在原型链，他就是一个简简单单的null，没有任何属性。</p><p>下面这种神图，相信大家都有看过，<code>instanceof</code>就是在这个链上一层层去找的。</p><p><img src="https://jacokwu.cn/images/blog/prototype.jpg" alt="原型链"></p><h4 id="多全局对象"><a href="#多全局对象" class="headerlink" title="多全局对象"></a>多全局对象</h4><blockquote><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式<code>[] instanceof window.frames[0].Array</code>会返回<code>false</code>，因为<code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">instanceof</a></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>instanceof</code>可以用来判断引用数据类型变量的具体类型以及由<code>new</code>定义的基本数据类型变量的类型。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote><p><code>constructor</code>是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。</p></blockquote><p><code>constructor</code>返回的是当前变量的构造器，和<code>instanceof</code>一样都是在原型链上操作。先看下之前定义的变量的表现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.constructor) <span class="comment">// String</span></span><br><span class="line"><span class="built_in">console</span>.log(_undefined.constructor) <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(_null.constructor) <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor) <span class="comment">// Number</span></span><br><span class="line"><span class="built_in">console</span>.log(bool.constructor) <span class="comment">// Boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.constructor) <span class="comment">// Symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor) <span class="comment">// Array</span></span><br><span class="line"><span class="built_in">console</span>.log(func.constructor) <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor) <span class="comment">// RegExp</span></span><br><span class="line"><span class="built_in">console</span>.log(date.constructor) <span class="comment">// Date</span></span><br><span class="line"><span class="built_in">console</span>.log(dom.constructor) <span class="comment">// HTMLBodyElement</span></span><br></pre></td></tr></table></figure><p>可以看出来除了<code>null</code>和<code>undefined</code>都可以使用<code>constructor</code>属性得到其的构造函数，也就是准确的类型。</p><ul><li>注意：数值不能直接使用<code>constructor</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1.</span><span class="keyword">constructor</span>) // Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">console.log((1).<span class="keyword">constructor</span>) // Number</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><code>constructor</code>可以判断除了<code>null</code>和<code>undefined</code>外的所有变量的类型。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><blockquote><p><code>toString()</code>方法返回一个表示该对象的字符串。</p></blockquote><p><code>toString()</code>是<code>Object</code>原型链上的方法，如果直接调用返回的值是其转换成字符串的值，我们可以通过<code>call</code>方法来调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _toString = <span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(str)</span><br><span class="line"><span class="built_in">console</span>.log(_toString(str)) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(_undefined)) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(_null)) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(num)) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(bool)) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(sym)) <span class="comment">// [object Symbol]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(obj)) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(arr)) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(func)) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(reg)) <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(date)) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(_toString(dom)) <span class="comment">// [object HTMLBodyElement]</span></span><br></pre></td></tr></table></figure><p>那么，我们为什么要通过<code>call</code>来调用呢？</p><p>首先一点是，<code>Object</code>的<code>toString</code>方法会返回一个<code>[object ${calss}]</code>的形式的字符串，在<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4.2" target="_blank" rel="noopener">ecma</a>中是这样说的：“Return the String value that is the result of concatenating the three Strings “[object “, class, and “]”.”；翻译过来就是“返回字符串值，该值是将三个字符串“[object”，class和“]”连接在一起的结果”。所以我们可以使用这个方法去判断变量类型。</p><p>其次是，大部分的类型都重写了<code>Object</code>的<code>toString</code>方法，也就是每个类型的变量去直接调用结果的表现都是不一样的，所以我们需要通过<code>call</code>去调用<code>Object</code>的<code>toString</code>方法。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>toString</code>可以用来准确的判断一个变量的类型。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Array-isArray-arg"><a href="#Array-isArray-arg" class="headerlink" title="Array.isArray(arg)"></a>Array.isArray(arg)</h4><p>对于数组，<code>Array</code>给我们专门提供了<code>Array.isArray(arg)</code>来判断<code>arg</code>是否是数组。</p><p>其实现方法很简单，就是封装了<code>toString</code>，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然其内部的实现肯定不会这么简单，至少也要加上类型判断。</p><h4 id="isNaN-arg-Number-isNaN-arg"><a href="#isNaN-arg-Number-isNaN-arg" class="headerlink" title="isNaN(arg) / Number.isNaN(arg)"></a>isNaN(arg) / Number.isNaN(arg)</h4><p><code>isNaN</code>是提供给我们的一个全局方法，<code>Number.isNaN</code>则是<code>Number</code>的一个原型方法。二者均是用来判断<code>NaN</code>的，后者比前者更加稳妥。如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'NaN'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'NaN'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'23'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'23'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'abc'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">'abc'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可以发现，当参数为非数字类型时，<code>isNaN</code>会先尝试将其转换为数值，然后去判断转换后的值是否为<code>NaN</code>，所以会有很多的迷惑行为。<br>而对于<code>Number.isNaN</code>，其并不会去尝试转换参数，而是直接去判断参数是否为<code>NaN</code>，哪怕是字符串的<code>&#39;NaN&#39;</code>都不行，所以推荐使用<code>Number.isNaN</code>。</p><p>#### </p><h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><p>学习了几种类型判断的方法，下面我们正式开始深度克隆。</p><h3 id="我们为什么需要深度克隆？"><a href="#我们为什么需要深度克隆？" class="headerlink" title="我们为什么需要深度克隆？"></a>我们为什么需要深度克隆？</h3><p>首先看下面这段代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">let</span> newStr = str</span><br><span class="line">newStr += <span class="string">'4'</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr</span><br><span class="line">newArr.push(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(newStr)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure><p>在这段代码中，newArr是arr的复制，newStr是str的复制；但是结果是arr跟着newArr改变了。</p><p>出现这种情况的原因是，在JavaScript中，普通数据类型都存在栈（栈内存）中，占用空间大小固定；引用数据类型都存在堆（堆内存）中，通过指针建立联系。而引用类型的值的复制，只是给新变量B添加了一个指针b，指向了被复制变量A的指针a所指向的内存，也就是说，B虽然是经过A复制得来，但是他们指向的始终还是同一个值，所以会一个变，另一个跟着变。如下所示。</p><iframe src="https://show.zohopublic.com.cn/publish/akx8s75d8e674921945c3992fc73634c613e9" height="221" width="329" name="%E5%8F%98%E9%87%8F%E5%AD%98%E5%80%BC" scrolling="no" frameborder="0" style="border:1px solid #AABBCC" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><p>为了避免这种指向同一地址，联动更改的问题，就需要用到深度克隆，使得复制出来的变量是一个全新的变量，不会对以前的变量产生其他影响。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>先搭个架子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arg) <span class="keyword">return</span> arg</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本数据类型变量克隆"><a href="#基本数据类型变量克隆" class="headerlink" title="基本数据类型变量克隆"></a>基本数据类型变量克隆</h4><p>然后我们由上一节得知，深度遍历主要就是针对的引用型变量，所以第一步就是先区分出基本变量和引用型变量。区分是否引用型变量可以使用<code>typeof</code>。</p><p>这一步有几点需要注意一下， 一个是<code>function</code>，<code>typeof fun === &#39;function&#39;</code>，而对于<code>function</code>来说，直接复制是没有问题的，所以不需要考虑这个。<br>还有一个是<code>document.all</code>，<code>typeof document.all === &#39;undefined&#39;</code>，<code>document.all</code>并不被推荐使用，且其中的关键信息都是只读的，所以在这里不考虑其的复制。<br>还有一个是通过<code>new</code>定义的基本类型变量，这些变量会通过第一步的判断，所以我们留在下一步讨论。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区分基本类型变量和引用类型变量</span></span><br><span class="line"><span class="comment">// 对于基本类型变量可以直接复制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'object) &#123;</span></span><br><span class="line"><span class="string">return arg</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>然后第二步，我们需要分类型考虑各类型的复制。不过在此之前，需要先分辨出各类型。</p><p>在这里，用的是<code>toString</code>，当然，其他的也可以。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(arg)</span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Date]'</span>: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Array]'</span>: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Object]'</span>: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过switch去处理不同类型的克隆，而default分支就用来处理通过了第一步判断的基本类型的变量，可以直接返回。</p><h4 id="RegExp克隆"><a href="#RegExp克隆" class="headerlink" title="RegExp克隆"></a><code>RegExp</code>克隆</h4><p>我们需要先了解几个<code>RegExp</code>的内置属性。</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>source</td><td>source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。</td></tr><tr><td>global</td><td>global 属性表明正则表达式是否使用了 “g” 标志。global 是一个正则表达式实例的只读属性。</td></tr><tr><td>ignoreCase</td><td>ignoreCase 属性表明正则表达式是否使用了 “i” 标志。ignoreCase 是正则表达式实例的只读属性。</td></tr><tr><td>multiline</td><td>multiline 属性表明正则表达式是否使用了 “m” 标志。multiline 是正则表达式实例的一个只读属性。</td></tr></tbody></table><p>我们需要获取源正则对象的字符串和其标志，然后生成一个新的正则。如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: </span><br><span class="line"><span class="keyword">let</span> flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (arg.global) flag.push(<span class="string">'g'</span>)</span><br><span class="line"><span class="keyword">if</span> (arg.ignoreCase) flag.push(<span class="string">'i'</span>)</span><br><span class="line"><span class="keyword">if</span> (arg.multiline) flag.push(<span class="string">'m'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(arg.source, flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在支持es6的环境中，我们可以不用这么麻烦，直接生成即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object RegExp]'</span>: </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为从es6开始，当第一个参数为正则表达式而第二个标志参数存在时，new RegExp(/ab+c/, ‘i’) 不再抛出 TypeError （”从另一个RegExp构造一个RegExp时无法提供标志”）的异常，取而代之，将使用这些参数创建一个新的正则表达式。</p><h4 id="Date克隆"><a href="#Date克隆" class="headerlink" title="Date克隆"></a><code>Date</code>克隆</h4><p>对于时间，我们可以直接获取其时间戳，然后新生成一个即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Date]'</span>: </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array克隆"><a href="#Array克隆" class="headerlink" title="Array克隆"></a><code>Array</code>克隆</h4><p>对于数组，可以通过遍历去处理数组内部每一项的值，而这些值又可能是任何属性，所以这里需要用递归去处理这些值。</p><p>这里要注意，不能使用解构，因为解构并不会改变数组内部值的组成，所以对于内部值，仍然是浅克隆。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Array]'</span>:</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arg.length; i ++) &#123;</span><br><span class="line">      result[i] = deepClone(arg[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object克隆"><a href="#Object克隆" class="headerlink" title="Object克隆"></a><code>Object</code>克隆</h4><p>对于对象，和数组类似，都要使用递归去处理其内部值，而不同点在于，对象还需要处理其原型链、只读属性或者是修改过属性的值等等。</p><p>首先是处理原型链，可以用<code>Object.getPrototypeOf()</code>和<code>Object.create()</code>，前者作用是返回指定对象的原型；后者作用是创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.create(proto)</span><br></pre></td></tr></table></figure><p>然后是只读属性或者是修改过属性的值，可以用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>，前者作用是返回指定对象上一个自有属性对应的属性描述符；后者作用是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rule = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(newObj, <span class="string">'foo'</span>, rule)</span><br></pre></td></tr></table></figure><p>然后合在一起处理就是</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'[object Object]'</span>:</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(arg)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> arg) &#123;</span><br><span class="line">      <span class="keyword">let</span> rule = <span class="built_in">Object</span>.getOwnPropertyDescriptor(arg, item)</span><br><span class="line">      rule.value = rule.value &amp;&amp; deepClone(rule.value)</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(result, item, rule)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dom克隆"><a href="#Dom克隆" class="headerlink" title="Dom克隆"></a><code>Dom</code>克隆</h4><p>Dom可能是几个节点的集合，也可能是单一的节点。因为节点的集合属于<code>HTMLCollection</code>接口，而这个接口是会自动更新的，所以不考虑这个。而对于单一节点，根据其节点名称的不同，<code>toString</code>返回的结果也不相同，所以我们使用节点的一个属性<code>nodeTpy</code>来判断其是否是dom节点。</p><p>这里还要用到一个内置方法<code>Node.cloneNode()</code>，其返回调用该方法的节点的一个副本；接收一个参数<code>deep</code>，参数如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg.nodeType &amp;&amp; <span class="string">'cloneNode'</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.cloneNode(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>目前是做了基本的深度克隆，但是还有很多缺陷，比如没有考虑过循环引用以及层数过多时递归会爆栈，后面会继续做优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">JavaScript高级程序设计</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN</a><br><a href="https://segmentfault.com/a/1190000019912017" target="_blank" rel="noopener">JS最新基本数据类型:BigInt</a><br><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator" target="_blank" rel="noopener">ECMAScript (ECMA-262)</a><br><a href="https://www.jianshu.com/p/2a3728cded4c" target="_blank" rel="noopener">JavaScript中如何实现深度克隆</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
            <tag> 引用类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从数组到栈与队列</title>
      <link href="/blog/2020/07/09/%E4%BB%8E%E6%95%B0%E7%BB%84%E5%88%B0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/blog/2020/07/09/%E4%BB%8E%E6%95%B0%E7%BB%84%E5%88%B0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数组，栈，队列？"><a href="#什么是数组，栈，队列？" class="headerlink" title="什么是数组，栈，队列？"></a>什么是数组，栈，队列？</h2><p>数组是数据的有序列表。在JS中，数组的每一项可以保存任何类型的数据，且不限制操作。<br>栈是一种后进先出的数据结构。又被称为堆栈，对其的增删操作只能在栈顶操作。<br>队列是一种先进先出的数据结构，是一种特殊的线性表。对其的插入操作需要在队尾进行，删除操作需要在队头操作。</p><h2 id="如何实现栈与队列"><a href="#如何实现栈与队列" class="headerlink" title="如何实现栈与队列"></a>如何实现栈与队列</h2><p>因为数组的灵活性，且在JS中，提供了一些类似于栈和队列的方法，所以可以很方便的用数组去实现栈和队列。</p><h3 id="用数组实现栈"><a href="#用数组实现栈" class="headerlink" title="用数组实现栈"></a>用数组实现栈</h3><p>先看栈都有哪些方法。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>pop()</td><td>执行出栈操作，删除栈顶元素</td></tr><tr><td>peek()</td><td>查看栈顶元素，不执行删除操作</td></tr><tr><td>push(item)</td><td>元素入栈</td></tr><tr><td>empty()</td><td>栈是否为空</td></tr><tr><td>search(item)</td><td>在栈中查找元素位置</td></tr></tbody></table><p>然后看看JS给我们提供了哪些原生方法和属性可以帮助我们去实现栈的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.pop() <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line">arr.push(<span class="number">7</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 7] </span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 5</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>是的，能用到的就是这几个，但是，实现起来也很简单，大概思路就是通过 <code>pop()</code> 实现栈的出栈操作， <code>push()</code> 实现栈的入栈操作，恰好可以满足栈的后进先出的规律。<br>下面我们尝试用这些方法去实现一个栈。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="comment">// 私有属性</span></span><br><span class="line">#stack</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">this.#stack = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> size() &#123;</span><br><span class="line">return this.#stack.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">empty = () =&gt; !this.#stack.length</span><br><span class="line"></span><br><span class="line">pop = () =&gt; this.#stack.pop()</span><br><span class="line"></span><br><span class="line">push = item =&gt; this.#stack.push(item)</span><br><span class="line"></span><br><span class="line">peek = () =&gt; this.#stack[this.#stack.length - 1]</span><br><span class="line"></span><br><span class="line">search = item =&gt; this.#stack.findIndex(ele =&gt; ele === item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示栈的内容</span></span><br><span class="line">print = () =&gt; this.#stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">stack.empty() <span class="comment">// true</span></span><br><span class="line">stack.push(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">stack.push(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">stack.push(<span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">stack.push(<span class="number">4</span>) <span class="comment">// 4</span></span><br><span class="line">stack.peek() <span class="comment">// 4</span></span><br><span class="line">stack.pop() <span class="comment">// 4</span></span><br><span class="line">stack.size <span class="comment">// 3</span></span><br><span class="line">stack.search(<span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">stack.print() <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>在这里我还用到了 <code>#stack</code> 私有属性，这个是一个新<a href="https://github.com/tc39/proposal-class-fields#private-fields" target="_blank" rel="noopener">提案</a>，处于第三阶段。<br>对于私有属性，可以用其他方案替代，比如：Symbol、WeakMap、闭包等。下面说明一下如何使用 Symbol 实现私有变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _stack = <span class="built_in">Symbol</span>() <span class="comment">// 定义一个Symbol，作为假的私有变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>[_stack] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> size() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>[_stack].length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">empty = <span class="function"><span class="params">()</span> =&gt;</span> !<span class="keyword">this</span>[_stack].length</span><br><span class="line"></span><br><span class="line">pop = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>[_stack].pop()</span><br><span class="line"></span><br><span class="line">push = <span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>[_stack].push(item)</span><br><span class="line"></span><br><span class="line">peek = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>[_stack][<span class="keyword">this</span>[_stack].length - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">search = <span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>[_stack].findIndex(<span class="function"><span class="params">ele</span> =&gt;</span> ele === item)</span><br><span class="line"></span><br><span class="line">print = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>[_stack]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用数组实现队列"><a href="#用数组实现队列" class="headerlink" title="用数组实现队列"></a>用数组实现队列</h3><p>先看队列都有哪些常用的方法或属性。（看了一下Java的队列，方法有点多，这里只拿一部分做实现）</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>push(item)</td><td>添加一个元素</td></tr><tr><td>pop()</td><td>移除并返回队列头部的元素</td></tr><tr><td>peek()</td><td>返回队列头部的元素</td></tr><tr><td>empty()</td><td>队列是否为空</td></tr></tbody></table><p>然后看看JS给我们提供了哪些原生方法和属性可以帮助我们去实现队列的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3, 4, 5] </span></span><br><span class="line">arr.push(<span class="number">7</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3, 4, 5, 7] </span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>下面我们开始用这些方法去实现。大概思路就是通过 <code>shift()</code> 实现栈的出栈操作， <code>push()</code> 实现栈的入栈操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">#queue</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">this.#queue = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> size() &#123;</span><br><span class="line">return this.#queue.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push = item =&gt; this.#queue.push(item)</span><br><span class="line"></span><br><span class="line">pop = () =&gt; this.#queue.shift()</span><br><span class="line"></span><br><span class="line">peek = () =&gt; this.#queue[0]</span><br><span class="line"></span><br><span class="line">empty = () =&gt; !this.#queue.length</span><br><span class="line"></span><br><span class="line">print = () =&gt; this.#queue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> que = <span class="keyword">new</span> Queue()</span><br><span class="line">que.empty() <span class="comment">// true</span></span><br><span class="line">que.push(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">que.push(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">que.push(<span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">que.push(<span class="number">4</span>) <span class="comment">// 4</span></span><br><span class="line">que.empty() <span class="comment">// false</span></span><br><span class="line">que.size <span class="comment">// 4</span></span><br><span class="line">que.peek() <span class="comment">// 1</span></span><br><span class="line">que.pop() <span class="comment">// 1</span></span><br><span class="line">que.print() <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>这是力扣中的一道<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">面试题</a>。<br>题意很好理解，就是给你一个只支持后进先出的list，实现一个有先进先出功能的list。<br>实现的重点在于<code>pop()</code>这个方法。放在数组里面说，栈的<code>pop()</code>是移除数组最后一位元素，而要实现的队列的<code>pop()</code>是要移除数组第一位元素，那么我们就想到可以将栈反转过来，然后pop出来的就是反转前的第一个元素了。而要反转就需要用到两个栈。下面是实现过程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue2</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="keyword">this</span>.aidStack = <span class="keyword">new</span> Stack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> size() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.stack.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push = <span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">this</span>.stack.push(item)</span><br><span class="line"></span><br><span class="line">pop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aidStack.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.stack.size) &#123;</span><br><span class="line"><span class="keyword">this</span>.aidStack.push(<span class="keyword">this</span>.stack.pop())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> popItem = <span class="keyword">this</span>.aidStack.pop()</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.aidStack.size) &#123;</span><br><span class="line"><span class="keyword">this</span>.stack.push(<span class="keyword">this</span>.aidStack.pop())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> popItem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">peek = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aidStack.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.stack.size) &#123;</span><br><span class="line"><span class="keyword">this</span>.aidStack.push(<span class="keyword">this</span>.stack.pop())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peekItem = <span class="keyword">this</span>.aidStack.peek()</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>.aidStack.size) &#123;</span><br><span class="line"><span class="keyword">this</span>.stack.push(<span class="keyword">this</span>.aidStack.pop())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> peekItem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">empty = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.stack1.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的使用场景"><a href="#栈的使用场景" class="headerlink" title="栈的使用场景"></a>栈的使用场景</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>我之前写过一个<a href>JS位运算符</a>的博客，里面有涉及到进制的转换。而在计算机里的所有内容都是用二进制数字表示的（0和1）。要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止，而将所有的余数反向排列起来组成数字就是最终的结构。将栈的思维加进去，就是说每一次除2都将余数入栈，然后根据栈后进先出的特性，将余数一个个出栈，就可以得到正确的二进制。而推广一下对其他进制也是相同的思维。下面实现一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数进制转换， 最大支持16进制</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; number 要转换的十进制数字</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; hex 进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> hexConversion = <span class="function">(<span class="params">number = <span class="number">0</span>, hex = <span class="number">10</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="comment">// 余数</span></span><br><span class="line">    <span class="keyword">let</span> rem = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 存放特殊字符，转换为16进制的时候需要用到</span></span><br><span class="line">    <span class="keyword">let</span> aidStr = <span class="string">'0123456789ABCDEF'</span> </span><br><span class="line">    <span class="keyword">if</span> (number === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环求余，并把余数入栈</span></span><br><span class="line">    <span class="keyword">while</span>(number &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        rem = <span class="built_in">Math</span>.floor(number % hex)</span><br><span class="line">        stack.push(rem)</span><br><span class="line">        number = <span class="built_in">Math</span>.floor(number / hex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将栈中内容全部出栈，并转换为其进制对应的字符</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.empty()) &#123; </span><br><span class="line">        result += aidStr[stack.pop()]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将高位的无效0删去</span></span><br><span class="line">    <span class="keyword">return</span> result.replace(<span class="regexp">/^0+/</span>,<span class="string">''</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hexConversion(<span class="number">2</span>, <span class="number">2</span>)) <span class="comment">// '010'</span></span><br><span class="line"><span class="built_in">console</span>.log(hexConversion(<span class="number">11</span>, <span class="number">16</span>)) <span class="comment">// 'B'</span></span><br></pre></td></tr></table></figure><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><p>这是力扣里面的<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">一道题</a>。<br>利用栈，可以很简单的解答此题。我们将字符串一位一位入栈，当其中一位和栈顶元素匹配时，两个均出栈，最后获取栈的长度，用字符串的长度减去栈的长度就是最长的包含有效括号的子串的长度。<br>例如对于’(()’，我们一个个压栈，当到’)’时，和第二个’(‘匹配成功，则他不入栈，且第二个’(‘出栈。最后获取栈的长度为1，用字符串的长度3减去1得到2，与正确结果一致。<br>下面是实现过程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设在此处定义了第一节的栈</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i ++) &#123;</span><br><span class="line">        <span class="comment">// 当当前字符为左括号或者当栈顶元素不为左括号时才入栈</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">'('</span> || (s[i] === <span class="string">')'</span> &amp;&amp; stack.peek() !== <span class="string">'('</span>)) &#123;</span><br><span class="line">            stack.push(s[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length - stack.size</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(longestValidParentheses(<span class="string">'(()'</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(longestValidParentheses(<span class="string">')()())'</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>栈的应用场景还有迷宫求解、汉诺塔实现等等，这里不再做讨论。</p><h2 id="队列的使用场景"><a href="#队列的使用场景" class="headerlink" title="队列的使用场景"></a>队列的使用场景</h2><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><p>这是《剑指offer》里面的一道<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题</a>。<br>由题意，我们知道需要不断挪动滑块去获取窗口的最大值。<br>我们设第一次的滑动窗口的位置为(x<sup>i</sup>, y<sup>j</sup>)，并将这三个值入队列，求出其最大值入数组。<br>然后移动滑块，得到第二次的位置为(x<sup>i+1</sup>, y<sup>j+1</sup>)，可知，相对于第一次，队列出队列了x<sup>i</sup>，入队列了y<sup>j+1</sup>，然后求出其最大值入数组。<br>以此类推，直到右边达到数组边界。<br>其中的难点在于求队列中的最大值。我们可以通过遍历这个队列，用辅助变量去求得最大值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设已有队列que</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> aidQue = <span class="keyword">new</span> Queue()</span><br><span class="line"><span class="keyword">while</span>(que.size) &#123;</span><br><span class="line">    <span class="keyword">let</span> popItem = que.pop()</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, popItem)</span><br><span class="line">    aidQue.push(popItem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恢复que的值</span></span><br><span class="line"><span class="keyword">while</span>(aidQue.size) &#123;</span><br><span class="line">que.push(aidQue.pop())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了如何去求最大值，整个题就变得迎刃而解了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已定义Queue类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slideQue = <span class="keyword">new</span> Queue()</span><br><span class="line">    <span class="keyword">let</span> maxArr = []</span><br><span class="line">    <span class="keyword">let</span> r = k - <span class="number">1</span> <span class="comment">// 滑窗右侧坐标</span></span><br><span class="line">    <span class="comment">// 确定初始滑窗</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        slideQue.push(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> getQueueMax = <span class="function">(<span class="params">que</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> aidQue = <span class="keyword">new</span> Queue()</span><br><span class="line">        <span class="keyword">while</span>(que.size) &#123;</span><br><span class="line">            <span class="keyword">let</span> popItem = que.pop()</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, popItem)</span><br><span class="line">            aidQue.push(popItem)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">while</span>(aidQue.size) &#123;</span><br><span class="line">            que.push(aidQue.pop())</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 遍历计算所有可能的滑窗的值</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.length) &#123;</span><br><span class="line">        maxArr.push(getQueueMax(slideQue))</span><br><span class="line">        slideQue.pop()</span><br><span class="line">        slideQue.push(nums[r + <span class="number">1</span>])</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，用数组就会更加简单，这里只是为了体现出队列的用法。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>队列还可用于像击鼓传花这种循环队列、买票排队时的优先队列以及JavaScript的任务队列。JS的任务队列又被称为<a href="https://www.jianshu.com/p/184988903562" target="_blank" rel="noopener">事件循环</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据结构涉及的范围非常之广，而这只是冰山一角，学习下去，只会感觉到JS越来越有趣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">JavaScript高级程序设计</a><br><a href="https://baike.baidu.com/item/%E6%A0%88/12808149" target="_blank" rel="noopener">栈</a><br><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481" target="_blank" rel="noopener">队列</a><br><a href="https://book.douban.com/subject/26639401/" target="_blank" rel="noopener">学习JavaScript数据结构与算法</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux搭建服务器</title>
      <link href="/blog/2020/06/15/Linux%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/blog/2020/06/15/Linux%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux搭建Docker环境"><a href="#Linux搭建Docker环境" class="headerlink" title="Linux搭建Docker环境"></a>Linux搭建Docker环境</h2><ul><li>安装Docker的依赖库</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -y 对所有的问题均回答yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用官方安装脚本自动安装，可跳过2、3步</span></span><br><span class="line">$ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><ul><li>添加Docker CE的软件源信息。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装Docker CE。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将服务器上的软件包信息在本地缓存一下，提高搜索速度</span></span><br><span class="line">$ yum makecache fast</span><br><span class="line">$ yum -y install docker-ce</span><br></pre></td></tr></table></figure><ul><li>启动Docker服务</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure><ul><li>配置Docker的自定义镜像仓库地址</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅针对阿里云服务器</span></span><br><span class="line"><span class="comment"># 请将下面命令中的镜像仓库地址https://kqh8****.mirror.aliyuncs.com替换为阿里云为您提供的专属镜像加速地址。</span></span><br><span class="line"><span class="comment"># 地址：容器镜像服务 -&gt; 镜像中心 -&gt; 镜像加速器</span></span><br><span class="line"></span><br><span class="line">$ tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://kqh8****.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>重新加载服务配置文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br></pre></td></tr></table></figure><ul><li>重启Docker服务</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="docker中安装Nginx并部署静态文件"><a href="#docker中安装Nginx并部署静态文件" class="headerlink" title="docker中安装Nginx并部署静态文件"></a>docker中安装Nginx并部署静态文件</h3><ul><li>查看Docker镜像仓库中Nginx的可用版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search nginx</span><br></pre></td></tr></table></figure><ul><li>拉取最新版的Nginx镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>查看本地镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure><ul><li>运行容器</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># --name nginx-test   -&gt; 容器名称。</span></span><br><span class="line"><span class="comment"># -p 8080:80          -&gt; 端口进行映射，将本地8080端口映射到容器内部的80端口。</span></span><br><span class="line"><span class="comment"># -d nginx            -&gt; 设置容器在后台一直运行。</span></span><br></pre></td></tr></table></figure><p>运行完之后可以在浏览器地址栏输入http://&lt;ECS公网地址&gt;:8080访问Nginx服务</p><ul><li><p>如果访问不通，需要检查容器是否启动正常，以及服务器是否开放了当前端口</p><ul><li>查看当前启动的容器</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><ul><li>阿里云开放端口</li></ul><p>对应菜单：云服务器 ECS -&gt; 网络与安全 -&gt; 安全组<br>点进安全组，选择手动添加，具体配置如下图<br><img src="https://jacokwu.cn/images/blog/linux-SecurityGroup.png" alt="安全组配置"></p></li></ul><ul><li>自定义nginx配置</li></ul><p>我们往往希望自己定制nginx的配置，这时候需要将nginx的配置挪出来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container cp nginx-test:/etc/nginx .</span><br><span class="line"><span class="comment"># 上面命令的含义是，把mynginx容器的/etc/nginx拷贝到当前目录。不要漏掉最后那个点。</span></span><br></pre></td></tr></table></figure><p>执行完成后，当前目录应该多出一个nginx子目录。然后，把这个子目录改名为conf。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv nginx conf</span><br></pre></td></tr></table></figure><p>然后在conf目录下的配置文件中就可以对nginx进行配置了。同样，对于log日志和静态文件也可以自定义。<br>在conf同级目录下执行下列命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir logs www</span><br></pre></td></tr></table></figure><p>然后我们将静态文件放入www文件夹中。因为我们改了配置，所以需要重启nginx。</p><ul><li>重启nginx</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止nginx-test</span></span><br><span class="line">$ docker stop nginx-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">$ docker run -d \</span><br><span class="line">  -p 127.0.0.2:8080:80 \</span><br><span class="line">  -rm -v <span class="variable">$PWD</span>/conf/nginx.conf:/etc/nginx/conf.d/nginx.conf \</span><br><span class="line">  -v <span class="variable">$PWD</span>/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">  -v <span class="variable">$PWD</span>/html:/usr/share/nginx/html \</span><br><span class="line">  --name my_nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -- -rm  -&gt; 容器停止运行后，自动删除容器文件</span></span><br><span class="line"><span class="comment"># -- -v   -&gt; 绑定一个卷</span></span><br><span class="line"><span class="comment"># -- $PWD -&gt; 当前目录</span></span><br></pre></td></tr></table></figure><p>这时候再去访问8080端口，就可以看到放在www文件夹中静态文件输出的内容了。</p><h2 id="docker上安装node-js"><a href="#docker上安装node-js" class="headerlink" title="docker上安装node.js"></a>docker上安装node.js</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看Docker镜像仓库中node的可用版本</span></span><br><span class="line">$ docker search node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取最新版的Nginx镜像</span></span><br><span class="line">$ docker pull node:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行node容器</span></span><br><span class="line">$ docker run -itd --name node-test node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -- -i  -&gt; 以交互模式运行容器，通常与 -t 同时使用</span></span><br><span class="line"><span class="comment"># -- -t  -&gt; 为容器重新分配一个伪输入终端，通常与 -i 同时使用</span></span><br><span class="line"><span class="comment"># -- -d  -&gt; 后台运行容器，并返回容器ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入node容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it node-test /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># -- -i  -&gt; 即使没有附加也保持 STDIN 打开</span></span><br><span class="line"><span class="comment"># -- -t  -&gt; 分配一个伪终端</span></span><br></pre></td></tr></table></figure><ul><li>STDIN ? </li></ul><p>STDIN 通常和 STDOUT 、STDERR 一起出现，他们是终端的标准输入(standard input)、标准输出(standard output)和标准错误输出(standard error)。当linux开始执行程序的时候，程序默认会打开这3个文件流，这样就可以对终端进行输入输出操作。</p><h2 id="docker安装MySQL"><a href="#docker安装MySQL" class="headerlink" title="docker安装MySQL"></a>docker安装MySQL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看mysql可用版本</span></span><br><span class="line">$ docker search mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取官方的最新版本的镜像</span></span><br><span class="line">$ docker pull mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地镜像</span></span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ docker run --name mysqlserver \</span><br><span class="line">   -v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d \ </span><br><span class="line">   -v <span class="variable">$PWD</span>/logs:/logs \</span><br><span class="line">   -v <span class="variable">$PWD</span>/data:/var/lib/mysql \</span><br><span class="line">   -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">   -d -i -p 3306:3306 mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。</span></span><br><span class="line"><span class="comment"># -v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</span></span><br><span class="line"><span class="comment"># -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。</span></span><br><span class="line"><span class="comment"># -v $PWD/data:/var/lib/mysql ：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql 。</span></span><br><span class="line"><span class="comment"># -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it mysqlserver bash</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="noopener">Nginx 容器教程</a><br><a href="https://developer.aliyun.com/adc/scenario/exp/9fd79b8711984e309f20d82bc65a26fa" target="_blank" rel="noopener">快速搭建Docker环境</a><br><a href="https://www.cnblogs.com/yy-cola/p/11226924.html" target="_blank" rel="noopener">使用docker安装mysql并连接</a><br><a href="https://blog.csdn.net/xmzzy2012/article/details/80584910" target="_blank" rel="noopener">linux下的stdin,stdout和stderr理解</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原生 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS大数运算与精度</title>
      <link href="/blog/2020/06/13/JS%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B2%BE%E5%BA%A6/"/>
      <url>/blog/2020/06/13/JS%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在项目上涉及到大数的展示，不仅是个大数，还是个小数。然后我们对数字进行验证的时候，发现数字太大了，前端这边根本无法算出正确的结果，而且小数部分还存在精度误差问题。这时候想到了利用 <a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">bignumber.js</a> 来解决这个问题；但是我们的系统已经基本进入了后期优化阶段，因为各种原因，这个时候再引入一个新的库有些得不偿失，而且用到的地方就这一个(其他涉及到数字的地方都有专门的方案用来解决精度问题，但是无法解决大数的问题)。所以我就想写个方法专门用来解决这个地方的精度问题以及计算问题。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p>造成精度丢失的原因目前我见过的常见的可能有以下几种：</p><ol><li>后台传过来的就是浮点型，数字太大了，在传输到显示的过程中，哪怕不加任何运算，精度也会丢失;</li><li><code>toFixed()</code>方法造成的精度丢失;</li><li>浮点数加减法造成的精度丢失。</li></ol><p>下面我们来分别讨论下这三种问题产生的原因以及解决方法。</p><h3 id="大数精度"><a href="#大数精度" class="headerlink" title="大数精度"></a>大数精度</h3><p>我们发现在js中，数字一旦超过安全值，就开始变得不再精准，哪怕是简单的加法运算。产生这种问题的原因是js采用的是 IEEE 754 即IEEE二进制浮点数算术标准中的双精度浮点数。何为 IEEE 754？网上已经又很多详细的解释了，这里不再赘述。</p><p>js的安全值范围是(-9007199254740991 ~ 9007199254740991)。也就是 <code>-(Math.pow(2, 53) - 1) ~ (Math.pow(2, 53) - 1)</code>。为了避免超出安全值范围导致精度丢失，只需要让后端传String类型即可。</p><h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h3><p>我们先看以下几个toFixed结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.345</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.34 -- 错误</span></span><br><span class="line">(<span class="number">1.375</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.38 -- 正确</span></span><br><span class="line">(<span class="number">1.666</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.67 -- 正确</span></span><br><span class="line">(<span class="number">1.636</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.64 -- 正确</span></span><br><span class="line">(<span class="number">1.423</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.42 -- 正确</span></span><br><span class="line">(<span class="number">1.483</span>).toFixed(<span class="number">2</span>) <span class="comment">// 1.48 -- 正确</span></span><br></pre></td></tr></table></figure><p>经过几次试探，我们发现<code>x.toFixed(f)</code>偶尔会发生精度丢失的问题。<br>现在看看为什么会出现这样的问题。研究了一下<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-number.prototype.tofixed" target="_blank" rel="noopener">ECMA 262</a>中对<code>Number.prototype.toFixed9(fractionDigits)</code>指定的规则。纯英文的，我就不翻译了。涉及到精度的步骤大概是下面这样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1.345).toFixed(2)</span></span><br><span class="line"><span class="comment">// 步骤10.a</span></span><br><span class="line"><span class="number">134</span> / <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="number">2</span>) - <span class="number">1.345</span> <span class="comment">// -0.004999999999999893</span></span><br><span class="line"><span class="number">135</span> / <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="number">2</span>) - <span class="number">1.345</span> <span class="comment">// 0.0050000000000001155</span></span><br><span class="line"><span class="comment">// 我们取最接近0的值为 -0.004999999999999893，然后根据步骤10.c得到值为 1.34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.375).toFixed(2)</span></span><br><span class="line"><span class="comment">// 步骤10.a</span></span><br><span class="line"><span class="number">137</span> / <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="number">2</span>) - <span class="number">1.375</span> <span class="comment">// -0.004999999999999893</span></span><br><span class="line"><span class="number">138</span> / <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="number">2</span>) - <span class="number">1.375</span> <span class="comment">// 0.004999999999999893</span></span><br><span class="line"><span class="comment">// 两个值的绝对值大小相同，所以我们取较大的值 0.004999999999999893，然后根据步骤10.c得到值为 1.38</span></span><br></pre></td></tr></table></figure><p><strong>*为什么1.345对应的步骤10.a要用134和135？</strong></p><p>在规范中没有解释这个n的来源，我根据上下文理解应该是 <code>n = (x * Math.pow(10, f)).toString().split(&#39;.&#39;)[0]</code>，其中x为原值，f为参数；然后又因为四舍五入只可能为当前值或者当前值加1，所以用的是134和135。</p><p>显然，根据内部的运算规则，toFixed的精度丢失是不可避免的，所以我们可以通过重写toFixed方法来解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未优化</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.toFixed = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> params = <span class="built_in">Number</span>(f)</span><br><span class="line">    <span class="keyword">const</span> num = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;num&#125;</span>`</span> <span class="comment">// 处理NaN返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(params)) params = <span class="number">0</span> <span class="comment">// 处理参数NaN情况</span></span><br><span class="line">    <span class="keyword">if</span> (params &gt; <span class="number">100</span> || params &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'toFixed() digits argument must be between 0 and 100'</span>) <span class="comment">// 处理参数大小问题</span></span><br><span class="line">    <span class="keyword">let</span> temp = num * <span class="built_in">Math</span>.pow(<span class="number">10</span>, params) <span class="comment">//  这里是为了使得需要保留的放在整数位，需要舍去的放在小数位</span></span><br><span class="line">    <span class="keyword">const</span> tempInteger = temp.toString().split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">// temp的整数位</span></span><br><span class="line">    <span class="keyword">const</span> judgeInteger = (temp + <span class="number">0.5</span>).toString().split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="comment">// temp + 0.5的整数位</span></span><br><span class="line">    <span class="keyword">const</span> tempArr = tempInteger.split(<span class="string">''</span>)</span><br><span class="line">    tempArr.splice(tempArr.length - f, <span class="number">0</span>, <span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">const</span> judgeArr = judgeInteger.split(<span class="string">''</span>)</span><br><span class="line">    judgeArr.splice(judgeArr.length - f, <span class="number">0</span>, <span class="string">'.'</span>)</span><br><span class="line">    <span class="comment">// 判断temp + 0.5之后是否大于temp，大于则说明尾数需要进位，相等则代表不需要</span></span><br><span class="line">    <span class="keyword">return</span> judgeInteger &gt; tempInteger ? <span class="string">`<span class="subst">$&#123;judgeArr.join(<span class="string">''</span>)&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;tempArr.join(<span class="string">''</span>)&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数加减"><a href="#浮点数加减" class="headerlink" title="浮点数加减"></a>浮点数加减</h3><p>我们经常会遇到这种问题，<code>0.1 + 0.2 !== 0.3</code>。这是因为js在运算的时候会先把数字转换为二进制，但是一些小数转为二进制是无限循环的，所以会造成结果的误差。看以下代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">0.1</span>).toString(<span class="number">2</span>)       <span class="comment">// 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101   --&gt; 对于后三位：1001 最后一个1进位得到 101,即 101</span></span><br><span class="line">(<span class="number">0.2</span>).toString(<span class="number">2</span>)       <span class="comment">// 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 01    --&gt; 对于后三位：0011 最后一个1进位得到 010,即 01</span></span><br><span class="line">(<span class="number">0.3</span>).toString(<span class="number">2</span>)       <span class="comment">// 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 11    --&gt; 对于后三位：1100 最后两个0舍去得到 11</span></span><br><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).toString(<span class="number">2</span>) <span class="comment">// 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101       --&gt; 转换为十进制为 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>小数转换二进制时的无限循环不可避免。所以我有个想法就是将其转换为字符串，然后按小数点分割成两部分，每部分都一位一位算，最后再将两部分和小数点拼接起来，因为计算的时候都是18以内（为何是18？单位最大为9，9 + 9 = 18）的整数加减法，所以这样可以避免因为小数转二进制而造成的误差。下一节，详细介绍一下这个思路的实现过程。</p><h2 id="大数运算（浮点数运算）"><a href="#大数运算（浮点数运算）" class="headerlink" title="大数运算（浮点数运算）"></a>大数运算（浮点数运算）</h2><p>现在我们详细介绍一下上一节所说的思路的实现过程。首先我们看加法。</p><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><p>在开始以前，我们先做一些准备，考虑一下都有哪些可能性，以及可能出现的BUG。</p><h4 id="符号及NaN"><a href="#符号及NaN" class="headerlink" title="符号及NaN"></a>符号及NaN</h4><p>先写一个简单的<code>add(x, y)</code>方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure><p>通过传不同的参数，可能会出现以下几种情况：</p><ol><li>传入两个非负数，正常计算；</li><li>一正一负，加法变减法；</li><li>均为负数，绝对值加法运算，然后取负；</li><li>一个或多个为非数字，即为NaN，会导致结果出错；</li><li>一个或多个为Boolean类型或者null时，需先转换为其对应的数值再进行计算；</li></ol><p>然后我们在add方法里面处理一下这几种情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; x </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; y </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x = <span class="string">''</span>, y = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(x)) || <span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(y))) <span class="keyword">return</span> x + y <span class="comment">// 当一个或多个为非数字，直接拼接字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'boolean'</span> || x === <span class="literal">null</span>) x = <span class="built_in">Number</span>(x).toString() <span class="comment">// 当x为boolean类型或者null时，转换为其对应的数值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'boolean'</span> || y === <span class="literal">null</span>) y = <span class="built_in">Number</span>(y).toString() <span class="comment">// 当y为boolean类型或者null时，转换为其对应的数值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> calMethood = <span class="literal">true</span> <span class="comment">// 运算方式，true为加法运算，false为减法运算（一正一负时需要减法运算）</span></span><br><span class="line"><span class="keyword">let</span> allAegative = <span class="literal">false</span> <span class="comment">// 是否需要给结果添加负号，true需要，false不需要</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="string">''</span> <span class="comment">// 和，字符串加减，所以定义为空串</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span> <span class="comment">// 进位标志，加法：当当前位计算大于9时，需要进位，加法进位只可能为0或1，减法：当当前位计算被减数不够减时，需要借位，减法借位只可能为0或-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了方便一正一负时的减法计算，将x和y存为默认的减数与被减数</span></span><br><span class="line"><span class="keyword">let</span> subtracted = x <span class="comment">// 被减数，默认为x</span></span><br><span class="line"><span class="keyword">let</span> minus = y <span class="comment">// 减数，默认为y</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.includes(<span class="string">'-'</span>) &amp;&amp; y.includes(<span class="string">'-'</span>)) &#123; <span class="comment">// 全是负数时，计算方法同全正数计算，只需要在最后的结果将负号加上即可，所以在此处将负号删去</span></span><br><span class="line">allAegative = <span class="literal">true</span></span><br><span class="line">calMethood = <span class="literal">true</span></span><br><span class="line">subtracted = x.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line">minus = y.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.includes(<span class="string">'-'</span>) || y.includes(<span class="string">'-'</span>)) &#123; <span class="comment">// x为负数或y为负数时,执行减法运算,绝对值小的为减数</span></span><br><span class="line">        <span class="comment">// 减法运算总是大的减小的</span></span><br><span class="line">calMethood = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> tempX = x.split(<span class="string">'-'</span>)[<span class="number">0</span>] ? x.split(<span class="string">'-'</span>)[<span class="number">0</span>] : x.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> tempY = y.split(<span class="string">'-'</span>)[<span class="number">0</span>] ? y.split(<span class="string">'-'</span>)[<span class="number">0</span>] : y.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> (+tempX &gt; +tempY) &#123;</span><br><span class="line">subtracted = tempX</span><br><span class="line">minus = tempY</span><br><span class="line">            allAegative = x.includes(<span class="string">'-'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认为x - y，如果改为y - x需要给结果添加负号</span></span><br><span class="line">subtracted = tempY</span><br><span class="line">minus = tempX</span><br><span class="line">            allAegative = y.includes(<span class="string">'-'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo：计算过程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x) + <span class="built_in">Number</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心计算过程"><a href="#核心计算过程" class="headerlink" title="核心计算过程"></a>核心计算过程</h4><p>处理完了符号，以及可能出现的报错，下面就开始计算部分了。这里采用的是先将字符串用split转换为数组，然后反转数组，使得数组从第零位到最后一位分别对应数字的个位到最大位，最后一位一位计算得到结果。可以写一个方法用来计算。整个实现过程也非常简单</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组求和</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr1 被减数转换的数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr2 减数转换的数组</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; sum 和</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; flag 进位标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> arrSum = (arr1, arr2, sum, flag) &#123;</span><br><span class="line">    <span class="comment">// 以位数大的数的长度为标准遍历，其中用到的未定义变量均为上一节中定义的变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.max(arr1.length, arr2.length); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (calMethood) &#123; <span class="comment">// 加法</span></span><br><span class="line">            <span class="comment">// 当前位计算，没有则为0，同时加上进位</span></span><br><span class="line">            <span class="keyword">const</span> temp = (+arr1[i] || <span class="number">0</span>) + (+arr2[i] || <span class="number">0</span>) + flag</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">10</span>) &#123; <span class="comment">// 判断是否需要进位</span></span><br><span class="line">                sum = <span class="string">`<span class="subst">$&#123;temp&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = <span class="string">`<span class="subst">$&#123;temp - <span class="number">10</span>&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 减法</span></span><br><span class="line">            <span class="keyword">let</span> temp = (arr1[i] || <span class="number">0</span>) - (arr2[i] || <span class="number">0</span>) + flag</span><br><span class="line">            <span class="keyword">if</span> ((+arr1[i] || <span class="number">0</span>) &lt; (+arr2[i] || <span class="number">0</span>)) &#123; <span class="comment">// 被减数太小,需要借位</span></span><br><span class="line">                temp += <span class="number">10</span></span><br><span class="line">                flag = <span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="string">`<span class="subst">$&#123;temp&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回flag是为了判断是否有溢出的进位</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sum,</span><br><span class="line">        flag,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在添加一下字符串转换数组的过程。需要注意的是，我们需要特殊考虑一下小数，因为小数的字符串在分割时会将小数点也作为一位分割，所以我们先按小数点分割，将字符串分割为整数和小数两部分。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> integerA = subtracted.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse() <span class="comment">// 被减数的整数部分的反转数组，方便遍历时从个位开始计算</span></span><br><span class="line"><span class="keyword">let</span> decimalA = [] <span class="comment">// 被减数的小数部分的反转数组</span></span><br><span class="line"><span class="keyword">let</span> integerB = minus.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse() <span class="comment">// 减数的整数部分的反转数组</span></span><br><span class="line"><span class="keyword">let</span> decimalB = [] <span class="comment">// 减数的小数部分的反转数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.includes(<span class="string">'.'</span>)) &#123; <span class="comment">// 是小数再去计算小数部分的数组</span></span><br><span class="line">    decimalA = subtracted.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y.includes(<span class="string">'.'</span>)) &#123;</span><br><span class="line">    decimalB = minus.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据小数的特殊性，需要根据两个数字的最长长度去给另一个填充0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.max(decimalA.length, decimalB.length); i ++) &#123;</span><br><span class="line">    decimalA[i] = +decimalA[i] || <span class="number">0</span></span><br><span class="line">    decimalB[i] = +decimalB[i] || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">decimalA = decimalA.reverse()</span><br><span class="line">decimalB = decimalB.reverse()</span><br></pre></td></tr></table></figure><p>然后进行计算，先算小数后算整数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">decimalA = decimalA.reverse()</span><br><span class="line">decimalB = decimalB.reverse()</span><br><span class="line"><span class="keyword">const</span> decimalAns = arrSum(decimalA, decimalB, sum, flag)</span><br><span class="line">sum = decimalAns.sum.replace(<span class="regexp">/0*$/</span>, <span class="string">''</span>) <span class="comment">// 去除小数部分末尾的0</span></span><br><span class="line">flag = decimalAns.flag</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数部分计算不为空,则添加小数点</span></span><br><span class="line"><span class="keyword">if</span> (sum !== <span class="string">''</span>) sum = <span class="string">`.<span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> integerAns = arrSum(integerA, integerB, sum, flag)</span><br><span class="line">sum = integerAns.sum</span><br><span class="line">flag = integerAns.flag</span><br><span class="line"><span class="comment">// 进位溢出，前面再添加一位</span></span><br><span class="line"><span class="keyword">if</span> (flag !== <span class="number">0</span>) &#123;</span><br><span class="line">    sum = <span class="string">`<span class="subst">$&#123;flag&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">sum = sum.replace(<span class="regexp">/^0*/</span>, <span class="string">''</span>) <span class="comment">// 去除最左侧的0</span></span><br></pre></td></tr></table></figure><p>然后最后只需要将最后的sum和符号拼起来就是最终的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> allAegative ? <span class="string">`-<span class="subst">$&#123;sum&#125;</span>`</span> : sum</span><br></pre></td></tr></table></figure><h3 id="大数减法"><a href="#大数减法" class="headerlink" title="大数减法"></a>大数减法</h3><p>减法与加法类似，且在上面的过程中，已经有了一个雏形。<br>比如说 <code>x - y</code>可以看成是 <code>x + (-y)</code>，所以就有了一个思路是，增加一个参数用来判断是否是减法，如果是减法就给y值取反，然后仍然进行加法运算。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; x </span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; y </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; methood </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y, methood = <span class="string">'+'</span></span>) =&gt;</span> &#123;</span><br><span class="line">    y = methood === <span class="string">'-'</span> ? -y : y</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 5</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'-'</span>) <span class="comment">// -1</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">-3</span>, <span class="string">'-'</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>参照这个思路，我们可以在已经写好的加法上稍作改造，加以下几行代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; x </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; y </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; methood </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x = <span class="string">''</span>, y = <span class="string">''</span>, methood = <span class="string">'+'</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (methood === <span class="string">'-'</span>) &#123;</span><br><span class="line">b = b.includes(<span class="string">'-'</span>) ? b.split(<span class="string">'-'</span>)[<span class="number">1</span>] : <span class="string">`-<span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>市面上已经有非常成熟的解决方案了，我这就是属于重复造轮子了，纯当学习.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baike.baidu.com/item/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0" target="_blank" rel="noopener">双精度浮点数</a><br><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-number.prototype.tofixed" target="_blank" rel="noopener">ECMAScript (ECMA-262)</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算大数</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; a </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; b </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; mthood 运算方式 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> addLargeNumber = <span class="function">(<span class="params">a = <span class="string">''</span>, b = <span class="string">''</span>, methood = <span class="string">'+'</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 传小数进行计算在toString的时候就会丢失精度，太大的时候一拿到就已经没有精度了。。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(a)) || <span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(b))) <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">if</span> (methood === <span class="string">'-'</span>) &#123;</span><br><span class="line">b = b.includes(<span class="string">'-'</span>) ? b.split(<span class="string">'-'</span>)[<span class="number">1</span>] : <span class="string">`-<span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> calMethood = <span class="literal">true</span> <span class="comment">// 运算方式,true为加法运算,false为减法运算</span></span><br><span class="line"><span class="keyword">let</span> allAegative = <span class="literal">false</span> <span class="comment">// 是否需要加负号</span></span><br><span class="line"><span class="keyword">let</span> subtracted = a <span class="comment">// 被减数,默认为a</span></span><br><span class="line"><span class="keyword">let</span> minus = b <span class="comment">// 减数,默认为b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.includes(<span class="string">'-'</span>) &amp;&amp; b.includes(<span class="string">'-'</span>)) &#123; <span class="comment">// 全是负数时，计算方法同全正数计算，只需要在最后的结果将负号加上即可，所以在此处将负号删去</span></span><br><span class="line">allAegative = <span class="literal">true</span></span><br><span class="line">calMethood = <span class="literal">true</span></span><br><span class="line">subtracted = a.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line">minus = b.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.includes(<span class="string">'-'</span>) || b.includes(<span class="string">'-'</span>)) &#123; <span class="comment">// a为负数或b为负数时,执行减法运算,绝对值小的为减数</span></span><br><span class="line"><span class="comment">// 减法运算总是大的减小的</span></span><br><span class="line">calMethood = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> tempX = a.split(<span class="string">'-'</span>)[<span class="number">0</span>] ? a.split(<span class="string">'-'</span>)[<span class="number">0</span>] : a.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> tempY = b.split(<span class="string">'-'</span>)[<span class="number">0</span>] ? b.split(<span class="string">'-'</span>)[<span class="number">0</span>] : b.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(+tempX, +tempY, +tempX &gt; +tempY)</span><br><span class="line"><span class="keyword">if</span> (+tempX &gt; +tempY) &#123;</span><br><span class="line">subtracted = tempX</span><br><span class="line">minus = tempY</span><br><span class="line">            allAegative = a.includes(<span class="string">'-'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认为x - y，如果改为y - x需要给结果添加负号</span></span><br><span class="line">subtracted = tempY</span><br><span class="line">minus = tempX</span><br><span class="line">            allAegative = b.includes(<span class="string">'-'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">let</span> integerA = subtracted.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse() <span class="comment">// 被减数的整数部分的反转数组，方便遍历时从个位开始计算</span></span><br><span class="line">    <span class="keyword">let</span> decimalA = [] <span class="comment">// 被减数的小数部分的反转数组</span></span><br><span class="line">    <span class="keyword">let</span> integerB = minus.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse() <span class="comment">// 减数的整数部分的反转数组</span></span><br><span class="line"><span class="keyword">let</span> decimalB = [] <span class="comment">// 减数的小数部分的反转数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span> <span class="comment">// 进位标志，当当前位计算大于9时，需要进位，加法进位只可能为0或1</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span> <span class="comment">// 和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.includes(<span class="string">'.'</span>)) &#123; <span class="comment">// 是小数再去计算小数部分的数组</span></span><br><span class="line">decimalA = subtracted.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b.includes(<span class="string">'.'</span>)) &#123;</span><br><span class="line">decimalB = minus.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据小数的特殊性，需要根据两个数字的最长长度去给另一个填充0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.max(decimalA.length, decimalB.length); i ++) &#123;</span><br><span class="line">decimalA[i] = +decimalA[i] || <span class="number">0</span></span><br><span class="line">decimalB[i] = +decimalB[i] || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">decimalA = decimalA.reverse()</span><br><span class="line">decimalB = decimalB.reverse()</span><br><span class="line"><span class="keyword">const</span> decimalAns = arrSum(decimalA, decimalB, sum, flag)</span><br><span class="line">sum = decimalAns.sum.replace(<span class="regexp">/0*$/</span>, <span class="string">''</span>) <span class="comment">// 去除小数部分末尾的0</span></span><br><span class="line">flag = decimalAns.flag</span><br><span class="line"><span class="comment">// 小数部分计算不为空,则添加小数点</span></span><br><span class="line"><span class="keyword">if</span> (sum !== <span class="string">''</span>) sum = <span class="string">`.<span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> integerAns = arrSum(integerA, integerB, sum, flag)</span><br><span class="line">sum = integerAns.sum</span><br><span class="line">flag = integerAns.flag</span><br><span class="line"><span class="keyword">if</span> (flag !== <span class="number">0</span>) &#123;</span><br><span class="line">sum = <span class="string">`<span class="subst">$&#123;flag&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">sum = sum.replace(<span class="regexp">/^0*/</span>, <span class="string">''</span>) || <span class="string">'0'</span> <span class="comment">// 去除最左侧的0，同时避免因结果是0而产生空串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr1 被减数转换的数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr2 减数转换的数组</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; sum 和</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; flag 进位标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrSum</span>(<span class="params">arr1, arr2, sum, flag</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.max(arr1.length, arr2.length); i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (calMethood) &#123; <span class="comment">// 加法</span></span><br><span class="line"><span class="keyword">const</span> temp = (+arr1[i] || <span class="number">0</span>) + (+arr2[i] || <span class="number">0</span>) + flag</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">10</span>) &#123;</span><br><span class="line">sum = <span class="string">`<span class="subst">$&#123;temp&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum = <span class="string">`<span class="subst">$&#123;temp - <span class="number">10</span>&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 减法</span></span><br><span class="line"><span class="keyword">let</span> temp = (+arr1[i] || <span class="number">0</span>) - (+arr2[i] || <span class="number">0</span>) + flag</span><br><span class="line"><span class="keyword">if</span> ((arr1[i] || <span class="number">0</span>) &lt; (arr2[i] || <span class="number">0</span>)) &#123; <span class="comment">// 被减数太小,需要借位</span></span><br><span class="line">temp += <span class="number">10</span></span><br><span class="line">flag = <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">sum = <span class="string">`<span class="subst">$&#123;temp&#125;</span><span class="subst">$&#123;sum&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">sum,</span><br><span class="line">flag,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> allAegative ? <span class="string">`-<span class="subst">$&#123;sum&#125;</span>`</span> : sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS位运算符</title>
      <link href="/blog/2020/06/09/JS%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/blog/2020/06/09/JS%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前对js的一些涉及到二进制的运算符一直似懂非懂，看到了就一脸懵逼，还得去控制台算一下。然后最近看算法的时候又看到了这个运算符，这里就简单介绍一下学习这些位运算符的过程。<br>注意：<strong>以下运算均不涉及到小数。</strong></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><h4 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h4><blockquote><p>“&lt;&lt;”运算符执行无符号左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。</p></blockquote><p>先说这句话是什么意思。左移位是二进制的一种运算，就是在不改变二进制数值32位长度的前提下，将每位的数字都向左移动，左边移出去的直接丢弃，右边空出来的位置用0填充。无符号就是保持符号位不变，即本来是正数，移位后一样为正数。</p><h5 id="正数的无符号左移位运算"><a href="#正数的无符号左移位运算" class="headerlink" title="正数的无符号左移位运算"></a>正数的无符号左移位运算</h5><p>这里以 <code>7 &lt;&lt; 2</code> 为例。</p><p>首先将7转为二进制是 <code>0000 0000 0000 0000  0000 0000 0000 0111</code>.<br>然后对其向左移两位.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            0000 0000 0000 0000  0000 0000 0000 0111    --&gt; 7</span><br><span class="line">                                                </span><br><span class="line">&lt;&lt; 2     00 0000 0000 0000 0000  0000 0000 0001 11      --&gt; 左边超出部分移除，坐标填充0</span><br><span class="line">----------------------------------------------------</span><br><span class="line">=           0000 0000 0000 0000  0000 0000 0001 1100    --&gt; 28</span><br></pre></td></tr></table></figure><p>得到值为 <code>0000 0000 0000 0000  0000 0000 0001 1100</code>.<br>转换为十进制为 28.即 <code>7 &lt;&lt; 2 = 28</code>。</p><p>然后我们对以上的运算过程做一个处理，将这些二进制转换为我们熟悉的十进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            0000 0000 0000 0000  0000 0000 0000 0111 = 2^2 + 2^1 + 2^0 = 7</span><br><span class="line">&lt;&lt; 2     00 0000 0000 0000 0000  0000 0000 0001 1100 = 2^4 + 2^3 + 2^2 = 28</span><br></pre></td></tr></table></figure><p>对移位后的算式进行合并项可得到 <code>2^4 + 2^3 + 2^2 = (2^2 + 2^1 + 2^0) * 2^2</code>，即 <code>2^4 + 2^3 + 2^2 = (2^2 + 2^1 + 2^0) * 2^2 = 7 * 2^2</code>。由此我们可得出 <code>7 &lt;&lt; 2 = 7 * 2^2 = 28</code>。<br>我们通过计算几个简单的左移位运算，与标准答案进行比较，验证一下这个结论。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 &lt;&lt; 1 = 4 * 2^1 = 8</span><br><span class="line">12 &lt;&lt; 1 = 12 * 2^1 = 24</span><br><span class="line">66 &lt;&lt; 3 = 66 * 2^3 = 528</span><br><span class="line">100 &lt;&lt; 5 = 100 * 2^5 = 3200</span><br><span class="line">9999 &lt;&lt; 6 = 9999 * 2^6 = 639936</span><br></pre></td></tr></table></figure><p>在控制台中以上几个算式的结果为</p><p><img src="https://jacokwu.cn/images/blog/operator-left.png" alt="控制台左移位运算"></p><p>答案完全一致。说明我们的结论是正确的。当然这个结论<strong>仅限于那些二进制移位不会左移移出的数字的简单运算</strong>。当我们遇到一些简单的可以口算的左移位运算时就可以使用这个结论快速得到结果，如果对于 <code>99999 &lt;&lt; 66</code> 这种较复杂的运算你也用这个结论计算，也没有人会介意。</p><h5 id="负数的无符号左移位运算"><a href="#负数的无符号左移位运算" class="headerlink" title="负数的无符号左移位运算"></a>负数的无符号左移位运算</h5><p>下面我们看一下负数的左移位运算。以 <code>-66 &lt;&lt; 2</code> 为例。<br>首先，我们先复习一下负数如何转换为二进制。<br>负数转换为二进制的步骤有三：</p><ol><li>确定负数对应正数的二进制</li><li>求第一步得到的二进制的反码</li><li>第二步得到的二进制加一</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-66</span><br><span class="line">    66      -&gt; 0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">    反码    -&gt; 1111 1111 1111 1111  1111 1111 1011 1101</span><br><span class="line">    +1      -&gt; 1111 1111 1111 1111  1111 1111 1011 1110</span><br></pre></td></tr></table></figure><p>然后对其向左移两位.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            1111 1111 1111 1111  1111 1111 1011 1110    --&gt; -66</span><br><span class="line"></span><br><span class="line">&lt;&lt; 2     11 1111 1111 1111 1111  1111 1110 1111 10      --&gt; 左边超出部分移除，坐标填充0</span><br><span class="line">----------------------------------------------------</span><br><span class="line">=           1111 1111 1111 1111  1111 1110 1111 1000    --&gt; 28</span><br></pre></td></tr></table></figure><p>得到值为 <code>1111 1111 1111 1111  1111 1110 1111 1000</code>.然后我们将其转换成十进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111  1111 1110 1111 1000</span><br><span class="line">    -1     -&gt; 1111 1111 1111 1111  1111 1110 1111 0111</span><br><span class="line">    反码   -&gt; 0000 0000 0000 0000 0000 0001 0000 1000</span><br><span class="line">    转换   -&gt; -264                                       --&gt; 别忘了带符号</span><br></pre></td></tr></table></figure><p>转换为十进制为 -264.即 <code>-66 &lt;&lt; 2 = -264</code>。</p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><ol><li>拓展1</li></ol><p>刚刚我们计算 -66 的二进制得到的是 <code>1111 1111 1111 1111  1111 1111 1011 1110</code>。我们在控制台验证一下我们得到的这个二进制。<br><img src="https://jacokwu.cn/images/blog/operator-left2.png" alt="-66的二进制表示"><br>欸，这差距有点大呀。是我们算的不对吗？肯定不是。是因为js的引擎在做处理的时候是先按无符号数字进行处理，转换完了才会加上符号。所以 -66 的二进制应该是先得出66的二进制，然后加上负号，就得到了 <code>-1000010</code>。</p><ol start="2"><li>拓展2</li></ol><p>我们比较一下下面几个算式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">33 &lt;&lt; 2 = 132</span><br><span class="line">-33 &lt;&lt; 2 = -132</span><br><span class="line">66 &lt;&lt; 2 = 264</span><br><span class="line">-66 &lt;&lt; 2 = -264</span><br><span class="line">999 &lt;&lt; 2 = 3996</span><br><span class="line">-999 &lt;&lt; 2 = -3996</span><br></pre></td></tr></table></figure><p>是的没错，进行无符号左移位运算时，当两个数的绝对值相等时，其相同位数的移位的绝对值一定相等。</p><h4 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h4><blockquote><p>“&gt;&gt;”运算符执行<strong>有符号</strong>右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。</p></blockquote><h5 id="正数的有符号右移位运算"><a href="#正数的有符号右移位运算" class="headerlink" title="正数的有符号右移位运算"></a>正数的有符号右移位运算</h5><p>这里以 <code>666 &gt;&gt; 3</code> 为例。</p><p>首先将666转换为二进制是 <code>0000 0000 0000 0000  0000 0010 1001 1010</code>。<br>然后对其向右移三位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        0000 0000 0000 0000  0000 0010 1001 1010        --&gt; 666</span><br><span class="line">                                                </span><br><span class="line">&gt;&gt; 3       0 0000 0000 0000  0000 0000 0101 0011 010    --&gt; 因为是正数所以左边填充0，右边超出部分移除</span><br><span class="line">------------------------------------------------</span><br><span class="line">=       0000 0000 0000 0000  0000 0000 0101 0011        --&gt; 83</span><br></pre></td></tr></table></figure><p>得到值为 <code>0000 0000 0000 0000  0000 0000 0101 0011</code>.<br>转换为十进制为 83.即 <code>666 &gt;&gt; 3 = 83</code>。</p><p>然后我们对以上的运算过程做一个处理，将这些二进制转换为我们熟悉的十进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        0000 0000 0000 0000  0000 0010 1001 1010        = 2^9 + 2^7 + 2^4 + 2^3 + 2^1 = 666</span><br><span class="line">&gt;&gt; 3       0 0000 0000 0000  0000 0000 0101 0011 010    = 2^6 + 2^4 + 2^1 + 2^0       = 28</span><br></pre></td></tr></table></figure><p>这个规律好像不太好总结？</p><h5 id="负数的有符号右移位运算"><a href="#负数的有符号右移位运算" class="headerlink" title="负数的有符号右移位运算"></a>负数的有符号右移位运算</h5><p>这里以 <code>-666 &gt;&gt; 3</code>为例。</p><p>因为是有符号的运算，所以这里不再适用上一小节说的js的特殊处理。先将-666转换为二进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-666</span><br><span class="line">    666     -&gt; 0000 0000 0000 0000  0000 0010 1001 1010</span><br><span class="line">    反码    -&gt; 1111 1111 1111 1111  1111 1101 0110 0101</span><br><span class="line">    +1      -&gt; 1111 1111 1111 1111  1111 1101 0110 0110</span><br></pre></td></tr></table></figure><p>即-666的二进制形式为 <code>1111 1111 1111 1111  1111 1101 0110 0110</code>，然后对其进行有符号右移位运算</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        1111 1111 1111 1111  1111 1101 0110 0110        --&gt; -666</span><br><span class="line">                                                </span><br><span class="line">&gt;&gt; 3       1 1111 1111 1111  1111 1111 1010 1100 110    --&gt; 因为是负数所以左边填充1，右边超出部分移除</span><br><span class="line">------------------------------------------------</span><br><span class="line">=       1111 1111 1111 1111  1111 1111 1010 1100        --&gt; -84</span><br></pre></td></tr></table></figure><p>移位后得到的值为 <code>1111 1111 1111 1111  1111 1111 1010 1100</code>，是一个负值，我们将其转成十进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111  1111 1111 1010 1100</span><br><span class="line">    -1     -&gt; 1111 1111 1111 1111  1111 1111 1010 1011</span><br><span class="line">    反码   -&gt; 0000 0000 0000 0000 0000 0000 0101 0100</span><br><span class="line">    转换   -&gt; -84                                       --&gt; 别忘了带符号</span><br></pre></td></tr></table></figure><p>我们对此结果进行验证。</p><p><img src="https://jacokwu.cn/images/blog/operator-right2.png" alt="控制台有符号右移位运算验证"></p><p>可见，我们的运算是完全正确的。</p><h4 id="gt-gt-gt"><a href="#gt-gt-gt" class="headerlink" title="&gt;&gt;&gt;"></a>&gt;&gt;&gt;</h4><blockquote><p>“&gt;&gt;&gt;”运算符执行无符号右移位运算。它把无符号的 32 位整数所有效位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p></blockquote><h5 id="正数无符号右移位运算"><a href="#正数无符号右移位运算" class="headerlink" title="正数无符号右移位运算"></a>正数无符号右移位运算</h5><p>这里我们以 <code>666 &gt;&gt;&gt; 3</code>为例。</p><p>首先将666转换为二进制是 <code>0000 0000 0000 0000  0000 0010 1001 1010</code>。<br>然后对其向右移三位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        0000 0000 0000 0000  0000 0010 1001 1010        --&gt; 666</span><br><span class="line">                                                </span><br><span class="line">&gt;&gt; 3       0 0000 0000 0000  0000 0000 0101 0011 010    --&gt; 左边空出部分填充0，右边超出部分移除</span><br><span class="line">------------------------------------------------</span><br><span class="line">=       0000 0000 0000 0000  0000 0000 0101 0011        --&gt; 83</span><br></pre></td></tr></table></figure><p>得到值为 <code>0000 0000 0000 0000  0000 0000 0101 0011</code>.<br>转换为十进制为 83.即 <code>666 &gt;&gt; 3 = 83</code>。</p><h5 id="负数无符号右移位运算"><a href="#负数无符号右移位运算" class="headerlink" title="负数无符号右移位运算"></a>负数无符号右移位运算</h5><p>这里以 <code>-666 &gt;&gt; 3</code>为例。</p><p>因为是有符号的运算，所以这里不再适用上一小节说的js的特殊处理。先将-666转换为二进制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-666</span><br><span class="line">    666     -&gt; 0000 0000 0000 0000  0000 0010 1001 1010</span><br><span class="line">    反码    -&gt; 1111 1111 1111 1111  1111 1101 0110 0101</span><br><span class="line">    +1      -&gt; 1111 1111 1111 1111  1111 1101 0110 0110</span><br></pre></td></tr></table></figure><p>即-666的二进制形式为 <code>1111 1111 1111 1111  1111 1101 0110 0110</code>，然后对其进行有符号右移位运算</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        1111 1111 1111 1111  1111 1101 0110 0110        --&gt; -666</span><br><span class="line">                                                </span><br><span class="line">&gt;&gt; 3       1 1111 1111 1111  1111 1111 1010 1100 110    --&gt; 左边空出部分填充0，右边超出部分移除</span><br><span class="line">------------------------------------------------</span><br><span class="line">=       0001 1111 1111 1111  1111 1111 1010 1100        --&gt; 536870828</span><br></pre></td></tr></table></figure><p>移位后得到的值为 <code>0001 1111 1111 1111  1111 1111 1010 1100</code>，转成十进制为536870828。<br>是不是超级大。因为是无符号右移位运算，所以在左边空出部分不论正负都会填充0.</p><p>我们对此结果进行验证。</p><p><img src="https://jacokwu.cn/images/blog/operator-right3.png" alt="控制台无符号右移位运算验证"></p><p>可见，我们的运算是完全正确的。</p><p>注意：因为对负数进行无符号右移位运算时，所得结果很大，所以在使用过程中需要格外注意。</p><p>疑问：左移位和右移位根本都是只对位置进行了移动，那么对于 <code>x1 &gt;&gt; k = y1</code> 和 <code>y2 &lt;&lt; k = x2</code> 中的 <code>x1</code> 等于 <code>x2</code>，<code>y1</code> 等于 <code>y2</code> 吗？</p><p>不一定。因为我们不能确保移动过程中被丢弃的值均为0。但凡有一个1被丢弃，就不会相等。而如果被丢弃的都是0，那么 <code>x1 === x2 y1 === y2</code>。如下图所示。</p><p><img src="https://jacokwu.cn/images/blog/operator-right.png" alt="控制台左右移位运算比较"></p><h3 id="逻辑位运算符"><a href="#逻辑位运算符" class="headerlink" title="逻辑位运算符"></a>逻辑位运算符</h3><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><blockquote><p>“&amp;”运算符（位与）用于对两个二进制操作数逐位进行比较，并根据下表所示的换算表返回结果。</p></blockquote><table><thead><tr><th>第一个数的位值</th><th>第二个数的位值</th><th>运算结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>这里以 <code>66 &amp; 33</code> 为例。</p><p>首先将两个数转换为二进制是 <code>0000 0000 0000 0000  0000 0000 0100 0010</code> 和 <code>0000 0000 0000 0000  0000 0000 0010 0001</code>。<br>然后对其进行与运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">&amp;   0000 0000 0000 0000  0000 0000 0010 0001</span><br><span class="line">--------------------------------------------    --&gt; 按上述表格进行运算</span><br><span class="line">    0000 0000 0000 0000  0000 0000 0000 0000    --&gt; 0</span><br></pre></td></tr></table></figure><p>得出结果为 0.</p><p>负数的与运算与正数并无区别，不做讨论。</p><h4 id><a href="#" class="headerlink" title="|"></a>|</h4><blockquote><p>“|”运算符（位或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。</p></blockquote><table><thead><tr><th>第一个数的位值</th><th>第二个数的位值</th><th>运算结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>这里以 <code>66 | 66</code> 为例。</p><p>首先将两个数转换为二进制是 <code>0000 0000 0000 0000  0000 0000 0100 0010</code> 和 <code>0000 0000 0000 0000  0000 0000 0100 0010</code>。<br>然后对其进行与运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">|   0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">--------------------------------------------    --&gt; 按上述表格进行运算</span><br><span class="line">    0000 0000 0000 0000  0000 0000 0100 0010    --&gt; 66</span><br></pre></td></tr></table></figure><p>得出结果为 66.</p><p>负数的与运算与正数并无区别，不做讨论。</p><h4 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h4><blockquote><p>“^”运算符（位异或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。</p></blockquote><table><thead><tr><th>第一个数的位值</th><th>第二个数的位值</th><th>运算结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>这里以 <code>66 ^ 66</code> 为例。</p><p>首先将两个数转换为二进制是 <code>0000 0000 0000 0000  0000 0000 0100 0010</code> 和 <code>0000 0000 0000 0000  0000 0000 0100 0010</code>。<br>然后对其进行与运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">|   0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">--------------------------------------------    --&gt; 按上述表格进行运算</span><br><span class="line">    0000 0000 0000 0000  0000 0000 0000 0000    --&gt; 0</span><br></pre></td></tr></table></figure><p>得出结果为 0.</p><p>负数的与运算与正数并无区别，不做讨论。</p><h4 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h4><blockquote><p>“~”运算符（位非）用于对一个二进制操作数逐位进行取反操作。</p></blockquote><p>这里以 <code>~66</code> 为例。</p><p>首先将其转换为二进制是 <code>0000 0000 0000 0000  0000 0000 0100 0010</code>。<br>然后对其进行与运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~   0000 0000 0000 0000  0000 0000 0100 0010</span><br><span class="line">--------------------------------------------    --&gt; 对每一位都进行取反操作</span><br><span class="line">    1111 1111 1111 1111  1111 1111 1011 1101    --&gt; -67</span><br></pre></td></tr></table></figure><p>将结果（<code>1111 1111 1111 1111  1111 1111 1011 1101</code>）转换为十进制</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111  1111 1111 1011 1101</span><br><span class="line">    -1     -&gt; 1111 1111 1111 1111  1111 1111 1011 1100</span><br><span class="line">    反码   -&gt; 0000 0000 0000 0000  0000 0000 0100 0011</span><br><span class="line">    转换   -&gt; -67                                       --&gt; 别忘了符号</span><br></pre></td></tr></table></figure><p>得出结果为 -67.</p><p>这里我们再我看几个例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~2 = -3</span><br><span class="line">~10 = -11</span><br><span class="line">~66 = -67</span><br><span class="line">~99 = -100</span><br><span class="line">~-99 = 98</span><br></pre></td></tr></table></figure><p>从中我们可以看出，<strong>位非操作就是对数字加一，然后取负</strong>。我们可以写个简单的判断方法来验证。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeResult</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~num === -(num + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">judgeResult() <span class="comment">// false</span></span><br><span class="line">judgeResult(<span class="number">10</span>) <span class="comment">// true</span></span><br><span class="line">judgeResult(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">judgeResult(<span class="number">-66</span>) <span class="comment">// true</span></span><br><span class="line">judgeResult(<span class="number">324</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位运算符运算结果非常有趣，在平时可以多加应用，但是一定要注意可能产生大数的预算，避免产生不必要的BUG。<br>这篇文章只是做了一个简单的介绍。后面有空了会做一下在实际开发中的应用，虽然我可能很久都遇不到。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/js/" target="_blank" rel="noopener">JavaScript学习指南：JS入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks是什么？</title>
      <link href="/blog/2020/04/28/Hooks%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/blog/2020/04/28/Hooks%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一下学习hooks时候的一点心得.</p><h2 id="什么是Hooks？"><a href="#什么是Hooks？" class="headerlink" title="什么是Hooks？"></a>什么是Hooks？</h2><p>在我的理解中，Hooks可以让我们在函数组件中优雅的使用React的特性，比如生命周期函数以及state。它的存在让函数组件更加的强大。</p><h2 id="常用Hooks"><a href="#常用Hooks" class="headerlink" title="常用Hooks"></a>常用Hooks</h2><h3 id="State-Hooks"><a href="#State-Hooks" class="headerlink" title="State Hooks"></a>State Hooks</h3><p>我们通过从React中导入 <code>useState</code> 来使用State Hooks，这使得我们在函数组件中可以使用本地state。示例如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&#123;count&#125;</span><br><span class="line">&lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;++<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useState作为一个方法接收一个参数<code>initialState</code>，initialState可以是一个有返回值的方法或者一个值。返回一个长度为2的数组，其中分别为state和setState。类型定义如下</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicStateAction&lt;S&gt; = (<span class="function"><span class="params">S</span> =&gt;</span> S) | S;</span><br><span class="line"><span class="keyword">type</span> Dispatch&lt;A&gt; = <span class="function"><span class="params">A</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> useState&lt;S&gt; = <span class="function">(<span class="params">initialState: (<span class="params">(<span class="params"></span>) =&gt; S</span>) | S</span>) =&gt;</span> [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> react </tag>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑之旅</title>
      <link href="/blog/2019/11/26/%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/"/>
      <url>/blog/2019/11/26/%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="Building-fresh-packages"><a href="#Building-fresh-packages" class="headerlink" title="Building fresh packages"></a>Building fresh packages</h2><h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4/4] Building fresh packages...</span><br><span class="line">[-/5] ⠄ waiting...</span><br><span class="line">[-/5] ⠄ waiting...</span><br><span class="line">[-/5] ⠄ waiting...</span><br><span class="line">[4/5] ⡀ phantomjs-prebuilt</span><br></pre></td></tr></table></figure><p>如上，yarn 或者 npm install 的时候到了第四步 Building fresh packages 一直waiting，或者是直接报错。</p><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>一直在转圈的 phantomjs-prebuilt ，或者是其他包在外网上，无法下载下来，需要配置国内镜像。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在项目根目录下新建 <code>.yarnrc</code> 或者 <code>.npmrc</code> 文件，然后添加如下内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &quot;https://registry.npm.taobao.org&quot;</span><br><span class="line"></span><br><span class="line">sass_binary_site &quot;https://npm.taobao.org/mirrors/node-sass/&quot;</span><br><span class="line">phantomjs_cdnurl &quot;http://cnpmjs.org/downloads&quot;</span><br><span class="line">electron_mirror &quot;https://npm.taobao.org/mirrors/electron/&quot;</span><br><span class="line">sqlite3_binary_host_mirror &quot;https://foxgis.oss-cn-shanghai.aliyuncs.com/&quot;</span><br><span class="line">profiler_binary_host_mirror &quot;https://npm.taobao.org/mirrors/node-inspector/&quot;</span><br><span class="line">chromedriver_cdnurl &quot;https://cdn.npm.taobao.org/dist/chromedriver&quot;</span><br></pre></td></tr></table></figure><p>装完之后可以删除了，有试过在 React 项目中 删除此文件以及 <code>node-modules</code> 然后重新安装依赖，没有报错或者一直waiting。</p><h2 id="React-配置-webpack-之-alias-路径别名"><a href="#React-配置-webpack-之-alias-路径别名" class="headerlink" title="React 配置 webpack 之 alias 路径别名"></a>React 配置 webpack 之 alias 路径别名</h2><p>这里提供的是使用 <code>react-app-rewired</code> 的方式。(<a href="https://github.com/timarney/react-app-rewired/blob/master/README_zh.md" target="_blank" rel="noopener">README</a>)</p><p>首先安装 <code>react-app-rewired</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-app-rewired</span><br></pre></td></tr></table></figure><p>然后在项目根目录创建 <code>config-overrides.js</code> 文件，在此文件中做个性化配置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config-overrides.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>webpack配置均在 <code>override</code> 方法中配置，其他配置可以参照上面的 README。<br>在文件中添加如下配置以配置路径别名。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// react-app-rewired 配置 webpack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径拼接</span></span><br><span class="line"><span class="keyword">const</span> resolvePath = <span class="function"><span class="params">dir</span> =&gt;</span> path.resolve(__dirname, dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 配置文件夹别名</span></span><br><span class="line">    config.resolve.alias = &#123;</span><br><span class="line">        <span class="string">"@"</span>: resolvePath(<span class="string">'./src'</span>),</span><br><span class="line">        <span class="string">"pages"</span>: resolvePath(<span class="string">'./src/pages'</span>),</span><br><span class="line">        <span class="string">"components"</span>: resolvePath(<span class="string">'./src/components'</span>),</span><br><span class="line">        <span class="string">"assets"</span>: resolvePath(<span class="string">'./src/assets'</span>),</span><br><span class="line">        <span class="string">"router"</span>: resolvePath(<span class="string">'./src/router'</span>),</span><br><span class="line">        <span class="string">"store"</span>: resolvePath(<span class="string">'./src/store'</span>),</span><br><span class="line">        <span class="string">"utils"</span>: resolvePath(<span class="string">'./src/utils'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="在React中将table导出为Excel"><a href="#在React中将table导出为Excel" class="headerlink" title="在React中将table导出为Excel"></a>在React中将table导出为Excel</h2><h3 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h3><p>直接查询数据库数据，并将其结果渲染在表格内，可导出为Excel。</p><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener">FilReader</a>、<a href="https://github.com/eligrey/FileSaver.js" target="_blank" rel="noopener">FileSaver</a>、<a href="https://www.runoob.com/tags/tag-a.html" target="_blank" rel="noopener">a</a>、<a href="https://baike.baidu.com/item/CSV/10739" target="_blank" rel="noopener">csv</a>、<a href="https://tool.oschina.net/commons" target="_blank" rel="noopener">Content-type</a>、<a href="https://stackoverflow.com/questions/17912307/u-ufeff-in-python-string" target="_blank" rel="noopener">\ufeff</a>、<a href="https://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6" target="_blank" rel="noopener">转义字符</a></p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>直接从数据库查数据，结果是完全不固定的，所以只能根据结果动态生成表格。首先处理列，将所有列都显示出来，且不会重复。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getDynamicColumns = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> headerObj = &#123;&#125; <span class="comment">// 存放所有行结果的集合体</span></span><br><span class="line">    <span class="keyword">const</span> headerColumns = [] <span class="comment">// 存放表格动态列</span></span><br><span class="line">    <span class="comment">// 将数组中所有项的键集合到一起</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      headerObj = &#123;</span><br><span class="line">        ...headerObj,</span><br><span class="line">        ...item,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 生成动态列    使用的是AntD，这里直接按ant的模板处理</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(headerObj).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      headerColumns.push(&#123;</span><br><span class="line">        dataIndex: item,</span><br><span class="line">        title: item,</span><br><span class="line">        align: <span class="string">'center'</span>,</span><br><span class="line">        width: <span class="number">120</span>,</span><br><span class="line">        render: <span class="function"><span class="params">record</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Popover</span> <span class="attr">content</span>=<span class="string">&#123;record&#125;</span>&gt;</span>&#123;record || '-'&#125;<span class="tag">&lt;/<span class="name">Popover</span>&gt;</span></span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> headerColumns</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据显示很简单，主要就是生成Excel了。</p><h3 id="导出表格"><a href="#导出表格" class="headerlink" title="导出表格"></a>导出表格</h3><p>在做的时候，尝试了不同的方法，这里会一一介绍。</p><h4 id="方法一-Blob-FileSaver"><a href="#方法一-Blob-FileSaver" class="headerlink" title="方法一 Blob + FileSaver"></a>方法一 Blob + FileSaver</h4><p>思路：使用Blob生成FileSaver可以识别的文件流，然后调用FileSaver的saveAs方法下载。</p><p>实现：</p><p>首先安装 FileSaver 依赖。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add file-saver</span><br></pre></td></tr></table></figure><p>然后在文件中引入 FileSaver。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FileSaver <span class="keyword">from</span> <span class="string">'file-saver'</span></span><br></pre></td></tr></table></figure><p>然后将数据处理成cvs文件形式。<br>注意：此段代码及之后的代码应位于你的导出方法之内</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; columns, data &#125; = <span class="keyword">this</span>.state</span><br><span class="line"><span class="keyword">let</span> blobData = <span class="string">'\uFEFF'</span> <span class="comment">// 字节顺序标记 使用了BOM或者utf-16？</span></span><br><span class="line">blobData += <span class="string">`<span class="subst">$&#123;columns.map(item =&gt; item.dataIndex).join(<span class="string">','</span>)&#125;</span> \n`</span></span><br><span class="line">data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> itemData = []</span><br><span class="line">  columns.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">     itemData.push(item[ele.dataIndex] || <span class="string">'-'</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   blobData += <span class="string">`<span class="subst">$&#123;itemData.join(<span class="string">','</span>)&#125;</span>\n`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上面这段代码，已经将数据转换为逗号分隔类型数据，第一行为表头，其他行为数据。<br>然后使用Blob将上面这段生成的 blobData 转换为Blob类文件格式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([blobData], &#123;</span><br><span class="line">  <span class="comment">// type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet’, // xlsx</span></span><br><span class="line">  type: <span class="string">'application/vnd.ms-excel;charset=utf-8'</span>, <span class="comment">// xls</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用xlsx时，导出的文件会提示文件扩展名或文件类型无效，手动将文件后缀改为xls后，可正常打开</span></span><br></pre></td></tr></table></figure><p>最后使用FileSaver下载文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FileSaver.saveAs(blob, <span class="string">`执行结果-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.xls`</span>);</span><br></pre></td></tr></table></figure><h5 id="缺陷优化"><a href="#缺陷优化" class="headerlink" title="缺陷优化"></a>缺陷优化</h5><p>打开生成的文件后，会发现长数字类型的字段全部变成了科学记数法，很尴尬是不是。<br>出现此问题是因为excel在处理数据时，将纯数字的字符串识别为数字类型，然后又因为长度太长转换为科学记数法了。<br>解决方法很简单，在第一步处理数据的时候额外处理一下纯数字就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> itemData = []</span><br><span class="line">  columns.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> val = item[ele.dataIndex] || <span class="string">'-'</span></span><br><span class="line">     <span class="keyword">if</span> ((+val).toString() === val) &#123; <span class="comment">// 判断当前值是否为纯数字</span></span><br><span class="line">        val = <span class="string">`\t<span class="subst">$&#123;  val.toString()&#125;</span>`</span> <span class="comment">// 纯数字加一个制表符，正常文件中不显示，但是会让excel不再特殊处理纯数字字符串</span></span><br><span class="line">     &#125;</span><br><span class="line">     itemData.push(val)</span><br><span class="line">   &#125;)</span><br><span class="line">   blobData += <span class="string">`<span class="subst">$&#123;itemData.join(<span class="string">','</span>)&#125;</span>\n`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="方法二-FileReader-Blob-FileSaver"><a href="#方法二-FileReader-Blob-FileSaver" class="headerlink" title="方法二 FileReader + Blob + FileSaver"></a>方法二 FileReader + Blob + FileSaver</h4><p>思路：使用html模板，将表格元素放入模板中，然后通过FileReader 将模板文件字符串转成base64，再使用FileSaver下载文件。</p><p>实现：<br>首先写一个html模板</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tagName = <span class="string">'table'</span> <span class="comment">// excel当前工作表的名称</span></span><br><span class="line"><span class="keyword">const</span> template = </span><br><span class="line">  <span class="string">`&lt;html</span></span><br><span class="line"><span class="string">    xmlns:o="urn:schemas-microsoft-com:office:office"</span></span><br><span class="line"><span class="string">    xmlns:x="urn:schemas-microsoft-com:office:excel"</span></span><br><span class="line"><span class="string">    xmlns="http://www.w3.org/TR/REC-html40"&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv=Content-Type content="text/html; charset=utf-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name=ProgId content=Excel.Sheet&gt;</span></span><br><span class="line"><span class="string">    &lt;!--[if gte mso 9]&gt;</span></span><br><span class="line"><span class="string">      &lt;xml&gt;</span></span><br><span class="line"><span class="string">        &lt;x:ExcelWorkbook&gt;</span></span><br><span class="line"><span class="string">          &lt;x:ExcelWorksheets&gt;</span></span><br><span class="line"><span class="string">            &lt;x:ExcelWorksheet&gt;</span></span><br><span class="line"><span class="string">              &lt;x:Name&gt;<span class="subst">$&#123;tagName&#125;</span>&lt;/x:Name&gt;</span></span><br><span class="line"><span class="string">              &lt;x:WorksheetOptions&gt;</span></span><br><span class="line"><span class="string">                &lt;x:DisplayGridlines/&gt;</span></span><br><span class="line"><span class="string">              &lt;/x:WorksheetOptions&gt;</span></span><br><span class="line"><span class="string">            &lt;/x:ExcelWorksheet&gt;</span></span><br><span class="line"><span class="string">          &lt;/x:ExcelWorksheets&gt;</span></span><br><span class="line"><span class="string">        &lt;/x:ExcelWorkbook&gt;</span></span><br><span class="line"><span class="string">      &lt;/xml&gt;</span></span><br><span class="line"><span class="string">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="string">    &lt;style type="text/css"&gt;</span></span><br><span class="line"><span class="string">      table td &#123;</span></span><br><span class="line"><span class="string">        text-align: center;</span></span><br><span class="line"><span class="string">      &#125;;</span></span><br><span class="line"><span class="string">      .header&#123;</span></span><br><span class="line"><span class="string">        background-color:'gray'</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      .align-left &#123;text-align: left !important;&#125;</span></span><br><span class="line"><span class="string">      .align-right &#123;text-align: right !important;&#125;</span></span><br><span class="line"><span class="string">      .align-center &#123;text-align: center !important;&#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;table&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="built_in">document</span>.getElementsByTagName(<span class="string">'thead'</span>)[<span class="number">0</span>].innerHTML&#125;</span></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="built_in">document</span>.getElementsByTagName(<span class="string">'tbody'</span>)[<span class="number">0</span>].innerHTML&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/htmlxmlns:o="urn:schemas-microsoft-com:office:office"&gt;`</span>;</span><br></pre></td></tr></table></figure><p>因为用了ant，所以在代码中体现的就是 thead 和 tbody 在两个table里面，只能分别放入模板中。</p><p>然后就使用fileReader+Blob来转换文件流。因为 fileReader 是读取文件，所以需要先通过Blob将模板转换为类文件，然后通过 fileReader 将其转换为base64。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line"><span class="comment">// 字符串转blob</span></span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="string">`<span class="subst">$&#123;template&#125;</span>`</span>],&#123;<span class="attr">type</span>:<span class="string">"application/vnd.ms-excel;charset=utf-8"</span>&#125;);</span><br><span class="line"><span class="comment">// blob转成base64</span></span><br><span class="line">fileReader.readAsDataURL(blob);</span><br><span class="line">fileReader.onloadend = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 当文件读取完成后，开始</span></span><br><span class="line">    FileSaver.saveAs(fileReader.result, <span class="string">`执行结果-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.xls`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="缺陷与优点"><a href="#缺陷与优点" class="headerlink" title="缺陷与优点"></a>缺陷与优点</h5><p>先说优点，就是可以设置表格的样式，以及当前工作区的名称。<br>缺陷：<br>首先是数字会变成科学记数法。可以通过改样式来解决。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">td</span>&#123;</span><br><span class="line">    <span class="attribute">mso-number-format</span>:<span class="string">'\@'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类型为单元格的格式。可以在Excel中设置单元格格式，在自定义中看到。</p><p>还有一个缺陷就是，直接获取html标签，如果表格有多页，就无法获取到后面页的数据，需要点击其他页，重新导出。<br>解决思路就是，将数据自己生成为tbody放入模板中。</p><h4 id="方法三-H5-a标签"><a href="#方法三-H5-a标签" class="headerlink" title="方法三 H5 a标签"></a>方法三 H5 a标签</h4><p>思路：直接使用a标签的dowload属性下载文件。当前前提是先获取文件的url或者base64.</p><p>实现：</p><p>首先将数据处理成 csv形式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; columns, data &#125; = <span class="keyword">this</span>.state</span><br><span class="line"><span class="keyword">let</span> blobData = <span class="string">'\uFEFF'</span></span><br><span class="line">blobData += <span class="string">`<span class="subst">$&#123;columns.map(item =&gt; <span class="string">`<span class="subst">$&#123;item.dataIndex&#125;</span>`</span>).join(<span class="string">','</span>)&#125;</span>\n`</span></span><br><span class="line">data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> itemData = []</span><br><span class="line">  columns.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = item[ele.dataIndex] || <span class="string">'-'</span></span><br><span class="line">    <span class="keyword">if</span> ((+val).toString() === val) &#123;</span><br><span class="line">      val = <span class="string">`\t<span class="subst">$&#123;  val.toString()&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    itemData.push(val)</span><br><span class="line">  &#125;)</span><br><span class="line">  blobData += <span class="string">`<span class="subst">$&#123;itemData.join(<span class="string">','</span>)&#125;</span>\n`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后对处理好的字符串进行编码，并拼接上base64的头信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uri = <span class="string">`data:text/csv;charset=utf-8,<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(blobData)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>然后生成一个临时的a标签来执行其点击事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">link.href = uri;</span><br><span class="line"><span class="comment">// 对下载的文件命名</span></span><br><span class="line">link.download = <span class="string">`执行结果-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.csv`</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">link.click();</span><br></pre></td></tr></table></figure><p>最后别忘了移除a标签</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.removeChild(link);</span><br></pre></td></tr></table></figure><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>缺陷？不能自定义样式吧。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法千千万，总有一个适合你。</p><h2 id="React刷新当前组件"><a href="#React刷新当前组件" class="headerlink" title="React刷新当前组件"></a>React刷新当前组件</h2><h3 id="业务背景-1"><a href="#业务背景-1" class="headerlink" title="业务背景"></a>业务背景</h3><p>当前页面有一个抽屉，在抽屉中，执行一定操作后需要重新调获取数据的接口更新form表单的数据，而当前抽屉结构较复杂，需要执行多个方法。为了方便起见，决定用刷新当前组件的方法去重新获取数据渲染组件。</p><h3 id="如何刷新当前抽屉组件？"><a href="#如何刷新当前抽屉组件？" class="headerlink" title="如何刷新当前抽屉组件？"></a>如何刷新当前抽屉组件？</h3><p>因为是个抽屉，就想到了在父组件中关闭再重新打开。然后我就试了一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件抽屉关闭方法</span></span><br><span class="line">onClose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">showSlideFrame</span>: <span class="literal">false</span> &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">showSlideFrame</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后出现了不可预料的问题，状态反了，看了一下代码，是项目上封装的问题。于是我又写了一个demo，用antd的Drawer试了一下，在完全没有其他操作的情况下虽然重新打开了抽屉，但是会有一个闪现的过程，非常丑，而且组件并没有被销毁，需要手动销毁，可看demo中的打开1。</p><p>然后经过一番百度，发现可以手动调用 <code>componentDidMount()</code> 方法。感觉自己发现了新大陆。赶紧试一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件需要刷新组件的方法</span></span><br><span class="line">onCloseSide = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 其他操作</span></span><br><span class="line">  <span class="keyword">this</span>.componentDidMount()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完全好使，同样demo了一下，可看demo中的打开2。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p><a href="https://jacokwu.cn/react-demo/dist/#/drawer/drawer-demo">DEMO</a></p><h3 id="拓展：路由跳转刷新组件"><a href="#拓展：路由跳转刷新组件" class="headerlink" title="拓展：路由跳转刷新组件"></a>拓展：路由跳转刷新组件</h3><p>如果要刷新的组件是一个完整的页面的话，可以创建一个指向空白的路由，然后跳转到空白路由再跳转回来。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用CSS画一些特殊图案</title>
      <link href="/blog/2019/09/15/%E7%94%A8CSS%E7%94%BB%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%9B%BE%E6%A1%88/"/>
      <url>/blog/2019/09/15/%E7%94%A8CSS%E7%94%BB%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%9B%BE%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>本篇博文主要是介绍用css画一些特殊的图案，以及一些特殊的效果。<br>在以下的内容中，可能会用到以下知识点: transform、transition、animation、景深等。首先简单介绍一下这些知识点。</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>transform可以对元素进行移动、旋转、缩放、拉伸等转换。具体的用法可以参照<a href="https://www.runoob.com/css3/css3-2dtransforms.html" target="_blank" rel="noopener">2D转换</a>和<a href="https://www.runoob.com/css3/css3-3dtransforms.html" target="_blank" rel="noopener">3D转换</a>。</p><h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>transition用来给元素的变换添加一些效果。具体的用法可以参照<a href="https://www.runoob.com/css3/css3-transitions.html" target="_blank" rel="noopener">过渡</a>。</p><h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><p>animation用来给元素添加动画。使用 @keyframes 规则。具体的用法可以参照<a href="https://www.runoob.com/css3/css3-animations.html" target="_blank" rel="noopener">动画</a>。</p><h4 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h4><p>景深就是肉眼距离屏幕的距离，将当前容器变成3D的，让本来的皮影戏变成舞台剧。景深设置的越大，元素离我们越远。用法如下。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        perspective: 500px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="浏览器坐标轴"><a href="#浏览器坐标轴" class="headerlink" title="浏览器坐标轴"></a>浏览器坐标轴</h4><p>这里以一个正方形的div为例。当一个元素进行一些2D或者3D变换时，作用的坐标轴的中心点就是这个元素的中心。需要注意的是，当元素进行变换时，其坐标轴会跟随移动，始终保持在元素中心。</p><p><img src="https://jacokwu.cn/images/blog/browser-coor.png" alt="浏览器坐标轴"></p><h3 id="正方体"><a href="#正方体" class="headerlink" title="正方体"></a>正方体</h3><h4 id="六个面"><a href="#六个面" class="headerlink" title="六个面"></a>六个面</h4><p>正方体是一个3D的图案，需要借助景深将屏幕变成一个具有z轴的3D空间。首先我们先写出正方体的六个面。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cube-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item front"</span>&gt;</span>front<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item behind"</span>&gt;</span>behind<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item top"</span>&gt;</span>top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item down"</span>&gt;</span>down<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们将正方体的舞台搭建起来。核心是设置景深，以及让子元素在3D空间内变换。添加如下css代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(rgba(0, 0, 0, 0) <span class="number">10%</span>, <span class="built_in">rgba</span>(0, 0, 0, .5) <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-radial-gradient</span>(rgba(0, 0, 0, 0) <span class="number">10%</span>, <span class="built_in">rgba</span>(0, 0, 0, .5) <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-o-radial-gradient</span>(rgba(0, 0, 0, 0) <span class="number">10%</span>, <span class="built_in">rgba</span>(0, 0, 0, .5) <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-moz-radial-gradient</span>(rgba(0, 0, 0, 0) <span class="number">10%</span>, <span class="built_in">rgba</span>(0, 0, 0, .5) <span class="number">100%</span>);</span><br><span class="line">    <span class="comment">/* 设置景深 */</span></span><br><span class="line">    <span class="attribute">perspective</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cube-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="comment">/* 让所有的元素在3D空间中呈现 */</span></span><br><span class="line">    <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将正方体的6个面画出来。添加如下CSS代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候正方体的6个面都已经堆叠在一起了，是时候让他们各自归位了，首先先看正面和背面。</p><p>正面是不需要动的，只需要安静的呆在你的面前就可以了。而背面需要向z轴负半轴方向移动正方体的边长的长度。为了方便四个侧面的处理，这里将正面向z轴正半轴的方法移动半个边长的长度，背面向z轴负半轴方向移动半个边长的长度。元素的移动就需要用到 transform 的 translate 方法。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, -50px); <span class="comment">/* 在x轴上移动50px的距离，在y轴上移动-50px的距离。当只写一个值时，默认在y轴上不移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(50px, 50px, 50px); <span class="comment">/* 3D转换。3个值分别为x轴、y轴、z轴 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(50px); <span class="comment">/* 3D转换。在x轴方向上移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(50px); <span class="comment">/* 3D转换。在y轴方向上移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(50px); <span class="comment">/* 3D转换。在z轴方向上移动 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加如下CSS代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(50px);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.behind</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他们的中心坐标始终都在同一个XY坐标点上。所以这时候只能透过半透明的 front 看到后面“变小”的其他面。</p><p>现在我们来处理左边和右边这两面。发挥你的想象力想象一下，他们两个都是绕Y轴进行旋转，也就是要用到 transform 的 rotate 方法。而为了让其能够正常的旋转到正确的位置上，还需要利用 translate 将其旋转点移动到两边。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg); <span class="comment">/* 顺时针旋转45度。也就是绕z轴旋转 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(1, 0, 0, 45deg); <span class="comment">/* 3D转换。前三个值代表在改方向上是否进行旋转，第四个值代表旋转的角度。 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(45deg); <span class="comment">/* 3D转换。绕x轴旋转 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(45deg); <span class="comment">/* 3D转换。绕y轴旋转 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(45deg); <span class="comment">/* 3D转换。绕z轴旋转 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加如下css代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="comment">/* 先将 left 在x轴上向左移动半个边长的长度，使 left 的中心点在 front 的左边边线上，然后将其旋转90度，使其与 front 和 behind 垂直，逆时针旋转，使其正面朝外 */</span></span><br><span class="line">    <span class="comment">/* 需要注意的是，当使用多个 transform 方法时，需要注意其顺序，不同的顺序会导致不同的结果。 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50px) <span class="built_in">rotateY</span>(90deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(50px) <span class="built_in">rotateY</span>(-90deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思想，让我们处理一下 top 和 down 这两个面。这两个面为了出现在上面和下面，需要绕x轴旋转90度。添加如下css代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="comment">/* 先将 top 在y轴上向左移动半个边长的长度，使 top 的中心点在 front 的上边边线上，然后将其旋转90度，使其与 front 和 behind 垂直，逆时针旋转，使其正面朝外 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50px) <span class="built_in">rotateX</span>(90deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.down</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(50px) <span class="built_in">rotateX</span>(-90deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候一个正方体就已经成型了，可是还是只能看到一个面啊，那我们就让其动起来。</p><h4 id="正方体旋转动画"><a href="#正方体旋转动画" class="headerlink" title="正方体旋转动画"></a>正方体旋转动画</h4><p>这里默认你已经了解了上面我所说的 animation 相关的知识点了。</p><p>首先我们定义一个旋转的动画,控制不同阶段的不同旋转角度，命名为 cubeRotating。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> cubeRotating &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    25% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(180deg);</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(360deg) <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(360deg) <span class="built_in">rotateZ</span>(180deg);</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了5个阶段的状态。0% 和 100% 都是初始状态。中间的几个阶段分别进行了不同程度和方向上的旋转。需要注意的是，在每个阶段完成后添加下个阶段的变换时，都需要以变换后的新坐标系为基准添加。</p><p>前面我们定义了正方体外壳 div 的位置，其中心点刚好是正方体的正中心。给其添加此动画。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cube-box</span> &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        以数字表示 animation 第几个属性</span></span><br><span class="line"><span class="comment">        1: 动画名称</span></span><br><span class="line"><span class="comment">        2: 动画持续时长,即完成一个周长所需的时间，默认为0</span></span><br><span class="line"><span class="comment">        3: 动画的速度曲线，默认为ease，详细的曲线介绍可以参考[速度曲线](https://www.runoob.com/cssref/css3-pr-animation-timing-function.html)</span></span><br><span class="line"><span class="comment">        4: 动画的延迟执行时间,只会在第一次执行时延迟，多次执行间无延迟</span></span><br><span class="line"><span class="comment">        5: 动画的执行次数，可以是数字或者 infinite(无限次)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attribute">animation</span>: cubeRotating <span class="number">6s</span> linear <span class="number">1s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码-amp-预览"><a href="#源码-amp-预览" class="headerlink" title="源码&amp;预览"></a>源码&amp;预览</h4><p>预览：<a href="https://jacokwu.cn/web-plug-in/cube/index.html">DEMO</a></p><p>源码：<a href="https://github.com/JaCoxxx/web-plug-in/tree/master/cube" target="_blank" rel="noopener">GITHUB</a></p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Canvas实现手写板的插件</title>
      <link href="/blog/2019/08/20/%E5%88%A9%E7%94%A8Canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%9D%BF%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
      <url>/blog/2019/08/20/%E5%88%A9%E7%94%A8Canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%9D%BF%E7%9A%84%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>此插件基于Vue。每一大章节都有对应的源码和DEMO。</p><p>前两天在遇到了一个需求，详细是在移动端实现手写板完成名字签署,不需要考虑笔画粗细、颜色等。效果如下图所示。</p><p><img src="https://jacokwu.cn/images/blog/tablets-effect.png" alt="效果图"></p><p>实现起来很简单，于是就自己写了一个小插件。此篇文章就在此基础上对笔画粗细、颜色等加以扩展，写一个移动端的手写板。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>对touch和canvas有所了解的可以略过本节。</p><p>在画板上写字，整个写字的过程大概分为三部分，分别为落笔、运笔、提笔（自己瞎概括的）。这三个步骤分别对应了三个移动端的监听方法。其中</p><ul><li>落笔对应的为：<code>touchstart</code>，此方法当手指触摸到屏幕时触发。</li><li>运笔对应的为：<code>touchmove</code>，此方法当手指在屏幕上滑动时触发。</li><li>提笔对应的为：<code>touchend</code>，此方法当手指离开屏幕时触发。</li></ul><p>运行这三个方法就可以模拟写字的整个过程。下面通过一个小例子来描述这三个方法的具体功能与用法。</p><h4 id="touch例子"><a href="#touch例子" class="headerlink" title="touch例子"></a>touch例子</h4><p>功能需求：点击屏幕生成一个小圆，当手指按住移动时小圆随之移动，当手指移开时，小圆消失。<br>类似于手机上的触摸反馈。例子很简单，就不多做介绍了。<br><strong>注意：</strong>如果是在PC端浏览此文章，请打开控制台在手机模式下查看测试下面的例子。</p><iframe height="530" style="width: 100%;" scrolling="no" title="ExYgooN" src="//codepen.io/jacoxxx/embed/ExYgooN/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/jacoxxx/pen/ExYgooN/" target="_blank" rel="noopener">ExYgooN</a> by Jaco Wu  (<a href="https://codepen.io/jacoxxx" target="_blank" rel="noopener">@jacoxxx</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>经过上面的例子我想应该学会了如何在移动端控制自己手指触控屏幕的过程，但是现在还没有笔迹，没有画板，所以我们需要先通过canvas构建一个画板，然后生成笔迹。下面介绍一下这个插件所需要用到的canvas相关方法。</p><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><ul><li>方法</li></ul><ol><li><code>getContext(&#39;2d&#39;)</code> 获取一个context 2d对象，即渲染上下文，其中有很多画图相关的方法，对应的还有3d对象。</li><li><code>beginPath()</code> 开始绘制路径</li><li><code>lineTo()</code> 线段的终点</li><li><code>moveTo()</code> 线段的起s点</li><li><code>stroke()</code> 给线段上色</li><li><code>closePath()</code> 结束路径绘制</li><li><code>clearRect(x1, y1, x2, y2)</code> 清空一定范围内的内容</li><li><code>toDataURL()</code> 将Canvas数据重新转化成图片文件</li></ol><ul><li>线条相关属性</li></ul><ol><li><code>strokeStyle</code> 线条颜色</li><li><code>lineWidth</code> 线条宽度</li><li><code>lineCap</code> 线条结束线帽<ul><li>butt：默认值。平直边缘</li><li>round：圆形线帽</li><li>square：正方形线帽</li></ul></li><li><code>lineJoin</code> 线条转弯处的线帽<ul><li>值类型同上。</li></ul></li></ol><p>同样以一个小例子来介绍上面的方法和属性。</p><h4 id="canvas例子"><a href="#canvas例子" class="headerlink" title="canvas例子"></a>canvas例子</h4><p>功能需求：在canvas中画一个正方形。</p><iframe height="530" style="width: 100%;" scrolling="no" title="KKPgRYd" src="//codepen.io/jacoxxx/embed/KKPgRYd/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/jacoxxx/pen/KKPgRYd/" target="_blank" rel="noopener">KKPgRYd</a> by Jaco Wu  (<a href="https://codepen.io/jacoxxx" target="_blank" rel="noopener">@jacoxxx</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><h3 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h3><h4 id="搭架子"><a href="#搭架子" class="headerlink" title="搭架子"></a>搭架子</h4><p>首先我们先搭起一个大的架子。其中需要通过props传入的值均先由data替代。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hand-writing&quot;&gt;</span><br><span class="line">      &lt;canvas </span><br><span class="line">        ref=&quot;writingCanvas&quot; </span><br><span class="line">        class=&quot;writing-box&quot; </span><br><span class="line">        :width=&quot;canvasWidth&quot; </span><br><span class="line">        :height=&quot;canvasHeight&quot; </span><br><span class="line">        @touchstart=&quot;onStart&quot;</span><br><span class="line">        @touchmove=&quot;onMove&quot; </span><br><span class="line">        @touchend=&quot;onEnd&quot;&gt;</span><br><span class="line">      &lt;/canvas&gt;</span><br><span class="line">      &lt;div class=&quot;btn-box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;btn btn-clear&quot; @click=&quot;onClear&quot;&gt;清屏&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;btn btn-generate&quot; @click=&quot;onGenerate&quot;&gt;生成&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HandWriting&apos;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 画板坐标</span><br><span class="line">      offsetWidth: 0,</span><br><span class="line">      offsetHeight: 0,</span><br><span class="line">      // 画板宽度</span><br><span class="line">      canvasWidth: &apos;&apos;,</span><br><span class="line">      // 画板高度</span><br><span class="line">      canvasHeight: &apos;&apos;,</span><br><span class="line">      // 线条宽度</span><br><span class="line">      lineWidth: 10,</span><br><span class="line">      // 线条颜色</span><br><span class="line">      lineColor: &apos;#000&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      this.init()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      // 画板初始化</span><br><span class="line">      init () &#123;&#125;,</span><br><span class="line">      // 开始触摸</span><br><span class="line">      onStart (e) &#123;&#125;,</span><br><span class="line">      // 移动</span><br><span class="line">      onMove (e) &#123;&#125;,</span><br><span class="line">      // 停止触摸</span><br><span class="line">      onEnd (e) &#123;&#125;,</span><br><span class="line">      // 点击取消</span><br><span class="line">      onClear () &#123;&#125;,</span><br><span class="line">      // 点击确认</span><br><span class="line">      onGenerate () &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;css&quot; scoped&gt;</span><br><span class="line">.hand-writing &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background: #fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.writing-box &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 80%;</span><br><span class="line">    background: #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.btn-box &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 20%;</span><br><span class="line">&#125;</span><br><span class="line">.btn &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  margin: 20px 25px;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  border: 1px solid #1890ff;</span><br><span class="line">  border-radius: 10px;</span><br><span class="line">  background: #1890ff;</span><br><span class="line">  color: #fff;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn:active &#123;</span><br><span class="line">  background: #fff;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这样一个架子就搭完了，效果如下图所示。</p><p><img src="https://jacokwu.cn/images/blog/tablets-eg1.png" alt="架子效果图"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>然后我们开始进入整体，首先需要获取canvas的context对象。在<code>init()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init () &#123;</span><br><span class="line">  <span class="comment">// 获取canvas</span></span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="keyword">this</span>.$refs.writingCanvas</span><br><span class="line">  <span class="comment">// 显式的宽高赋值</span></span><br><span class="line">  <span class="keyword">this</span>.canvasWidth = canvas.offsetWidth</span><br><span class="line">  <span class="keyword">this</span>.canvasHeight = canvas.offsetHeight</span><br><span class="line">  <span class="comment">// 获取context对象</span></span><br><span class="line">  <span class="keyword">this</span>.ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><p>获取到了context对象就可以开始画东西了。在<code>onStart()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onStart (e) &#123;</span><br><span class="line">  <span class="comment">// 获取画板相对于屏幕的偏移量，即左上角的坐标</span></span><br><span class="line">  <span class="keyword">this</span>.offsetLeft = e.target.offsetLeft</span><br><span class="line">  <span class="keyword">this</span>.offsetTop = e.target.offsetTop</span><br><span class="line">  <span class="comment">// 获取点击点的坐标（实际坐标 = 点击点相对于屏幕的坐标 - 画板相对于屏幕的坐标）</span></span><br><span class="line">  <span class="keyword">let</span> x = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft</span><br><span class="line">  <span class="keyword">let</span> y = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop</span><br><span class="line">  <span class="comment">// 开始绘制</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.beginPath()</span><br><span class="line">  <span class="comment">// 设置线条属性</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.lineWidth = <span class="keyword">this</span>.lineWidth</span><br><span class="line">  <span class="keyword">this</span>.ctx.strokeStyle = <span class="keyword">this</span>.lineColor</span><br><span class="line">  <span class="keyword">this</span>.ctx.lineCap = <span class="string">'round'</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.lineJoin = <span class="string">'round'</span></span><br><span class="line">  <span class="comment">// 绘制点击点</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(x, y)</span><br><span class="line">  <span class="keyword">this</span>.ctx.stroke()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="onMove"><a href="#onMove" class="headerlink" title="onMove"></a>onMove</h4><p>现在调试这个DEMO，就可以发现已经可以在画板中点击画点了。下面开始让这个点移动起来。在<code>onMove()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onMove (e) &#123;</span><br><span class="line">  <span class="comment">// 获取点击点的坐标</span></span><br><span class="line">  <span class="keyword">let</span> x = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft</span><br><span class="line">  <span class="keyword">let</span> y = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop</span><br><span class="line">  <span class="comment">// 绘制</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(x, y)</span><br><span class="line">  <span class="keyword">this</span>.ctx.stroke()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="onEnd"><a href="#onEnd" class="headerlink" title="onEnd"></a>onEnd</h4><p>现在再调试，已经可以正常的画线了，但是有始有终，当我们停止手指触摸时，应该关闭路径绘制。在<code>onEnd()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onEnd () &#123;</span><br><span class="line">  <span class="comment">// 停止绘制</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.closePath()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="onClear"><a href="#onClear" class="headerlink" title="onClear"></a>onClear</h4><p>到此画图的部分已经做完了，下面我们来实现清除画板功能和生成图片功能。首先是清除功能。在<code>onClear()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onClear () &#123;</span><br><span class="line">  <span class="comment">// 清空画板</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="onGenerate"><a href="#onGenerate" class="headerlink" title="onGenerate"></a>onGenerate</h4><p>然后来添加生成图片的功能。在<code>onGenerate()</code>方法中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onGenerate () &#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = <span class="keyword">this</span>.$refs.writingCanvas.toDataURL()</span><br><span class="line">  <span class="built_in">console</span>.log(filePath)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h4><p>点击生成按钮就可以在控制台看到打印的png类型的图片的base64地址。现在让我们将其显示在屏幕上。修改整体代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hand-writing&quot;&gt;</span><br><span class="line">      &lt;img v-if=&quot;filePath&quot; :src=&quot;filePath&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;canvas </span><br><span class="line">        v-else</span><br><span class="line">        ref=&quot;writingCanvas&quot; </span><br><span class="line">        class=&quot;writing-box&quot; </span><br><span class="line">        :width=&quot;canvasWidth&quot; </span><br><span class="line">        :height=&quot;canvasHeight&quot; </span><br><span class="line">        @touchstart=&quot;onStart&quot;</span><br><span class="line">        @touchmove=&quot;onMove&quot; </span><br><span class="line">        @touchend=&quot;onEnd&quot;&gt;</span><br><span class="line">      &lt;/canvas&gt;</span><br><span class="line">      &lt;div class=&quot;btn-box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;btn btn-clear&quot; @click=&quot;onClear&quot;&gt;清屏&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;btn btn-generate&quot; @click=&quot;onGenerate&quot;&gt;生成&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HandWriting&apos;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      // 图片地址</span><br><span class="line">      filePath: &apos;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      this.init()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      // 点击取消</span><br><span class="line">      onClear () &#123;</span><br><span class="line">        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight)</span><br><span class="line">        this.filePath = &apos;&apos;</span><br><span class="line">        // 清空filePath会造成DOM更新，而DOM更新会有延迟，所以放在nextTick中在DOM更新完后执行</span><br><span class="line">        // 清空filePath会让canvas重新生成，所以需要重新初始化</span><br><span class="line">        this.$nextTick(() =&gt; &#123;</span><br><span class="line">          this.init()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 点击确认</span><br><span class="line">      onGenerate () &#123;</span><br><span class="line">        // 当生成之后再点击将无效</span><br><span class="line">        this.filePath = this.filePath ? this.filePath : this.$refs.writingCanvas.toDataURL()</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>可以看到刚刚写的代码非常冗余，让我们优化一下。可以将所有的绘制提取出来，如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将onStart 和 onMove中的公共代码提取出来</span></span><br><span class="line">handleDraw (e) &#123;</span><br><span class="line">  <span class="comment">// 获取点击点的坐标</span></span><br><span class="line">  <span class="keyword">let</span> x = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft</span><br><span class="line">  <span class="keyword">let</span> y = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop</span><br><span class="line">  <span class="comment">// 绘制</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(x, y)</span><br><span class="line">  <span class="keyword">this</span>.ctx.stroke()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>作为一个插件我们需要提供一些暴露给外部的方法，变量，以及需要接收一些变量，更改如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'HandWriting'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    path: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">      <span class="comment">// 画板初始化</span></span><br><span class="line">      init () &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.path !== <span class="string">''</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.filePath = <span class="keyword">this</span>.path</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 点击取消</span></span><br><span class="line">      onClear () &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除的回调</span></span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'onClear'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 点击确认</span></span><br><span class="line">      onGenerate () &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.filePath) &#123;</span><br><span class="line">          <span class="keyword">this</span>.filePath = <span class="keyword">this</span>.filePath</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.filePath = <span class="keyword">this</span>.$refs.writingCanvas.toDataURL()</span><br><span class="line">          <span class="comment">// 生成图片的回调</span></span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'onComplete'</span>, <span class="keyword">this</span>.filePath)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里props只接收了图片，当然也可以接收canvas的宽度、高度等。方法都一样，就不再赘述。</p><h4 id="在线预览-amp-源码"><a href="#在线预览-amp-源码" class="headerlink" title="在线预览&amp;源码"></a>在线预览&amp;源码</h4><p>预览请打开控制台在手机模式下运行。笔画位置有误差请刷新浏览器。<br><a href="https://jacokwu.cn/vue-demo/dist/#/hand-writing">DEMO</a></p><p>源码：<a href="https://github.com/JaCoxxx/vue-demo/blob/master/src/views/HandWritingBoard/index.vue" target="_blank" rel="noopener">GitHub</a></p><h3 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h3><p>此章节开始所有的ui及样式将使用Ant Design Vue。之前的代码无需更改，并无冲突。</p><h4 id="更改画笔粗细"><a href="#更改画笔粗细" class="headerlink" title="更改画笔粗细"></a>更改画笔粗细</h4><p>更改笔画粗细首先需要一个调节笔画粗细的组件。这里使用了antd的气泡卡片作为调节的容器。使用滑动输入条调节粗细。在文件中添加、更改如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hand-writing&quot;&gt;</span><br><span class="line">    &lt;img v-if=&quot;filePath&quot; :src=&quot;filePath&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">    &lt;canvas</span><br><span class="line">      v-else</span><br><span class="line">      ref=&quot;writingCanvas&quot;</span><br><span class="line">      class=&quot;writing-box&quot;</span><br><span class="line">      :width=&quot;canvasWidth&quot;</span><br><span class="line">      :height=&quot;canvasHeight&quot;</span><br><span class="line">      @touchstart=&quot;onStart&quot;</span><br><span class="line">      @touchmove=&quot;onMove&quot;</span><br><span class="line">      @touchend=&quot;onEnd&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">    &lt;div class=&quot;btn-box&quot;&gt;</span><br><span class="line">      &lt;!-- 添加开始 --&gt;</span><br><span class="line">      &lt;!-- 调节弹框 --&gt;</span><br><span class="line">      &lt;a-popover v-model=&quot;adjustVisible&quot;&gt;</span><br><span class="line">        &lt;template slot=&quot;title&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;adjust-header&quot;&gt;</span><br><span class="line">            &lt;span&gt;调节笔画&lt;/span&gt;</span><br><span class="line">            &lt;a-icon type=&quot;close-circle&quot; @click=&quot;adjustVisible = false&quot; /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">        &lt;template slot=&quot;content&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;adjust-content&quot;&gt;</span><br><span class="line">            &lt;a-row&gt;</span><br><span class="line">              &lt;a-col :span=&quot;4&quot;&gt;线条粗细&lt;/a-col&gt;</span><br><span class="line">              &lt;a-col :span=&quot;12&quot;&gt;</span><br><span class="line">                &lt;a-slider :min=&quot;1&quot; :max=&quot;20&quot; v-model=&quot;lineWidth&quot; /&gt;</span><br><span class="line">              &lt;/a-col&gt;</span><br><span class="line">            &lt;/a-row&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">        &lt;a-button</span><br><span class="line">          type=&quot;primary&quot;</span><br><span class="line">          class=&quot;btn btn-adjust&quot;</span><br><span class="line">          @click=&quot;adjustVisible = true&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          调节笔画</span><br><span class="line">        &lt;/a-button&gt;</span><br><span class="line">      &lt;/a-popover&gt;</span><br><span class="line">      &lt;!-- 添加结束 --&gt;</span><br><span class="line">      &lt;a-button type=&quot;primary&quot; class=&quot;btn btn-clear&quot; @click=&quot;onClear&quot;</span><br><span class="line">        &gt;清屏&lt;/a-button</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;a-button type=&quot;primary&quot; class=&quot;btn btn-generate&quot; @click=&quot;onGenerate&quot;</span><br><span class="line">        &gt;生成&lt;/a-button</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HandWriting&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    path: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      // 添加卡片隐藏控制变量</span><br><span class="line">      adjustVisible: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;css&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.btn-box &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding-top: 10px;</span><br><span class="line">  height: 20%;</span><br><span class="line">&#125;</span><br><span class="line">.btn &#123;</span><br><span class="line">  margin: 0 15px;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.adjust-header &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.adjust-header span &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.adjust-header .anticon&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    text-align: right;</span><br><span class="line">    line-height: 21px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>更改之后，点击调节笔画，就可以在弹框中调节粗细了。</p><h4 id="更改画笔颜色"><a href="#更改画笔颜色" class="headerlink" title="更改画笔颜色"></a>更改画笔颜色</h4><p>这里使用<a href="https://github.com/xiaokaike/vue-color" target="_blank" rel="noopener">vue-color</a>调色板来调节颜色。</p><p>首先安装vue-color。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i vue-color</span><br><span class="line">or</span><br><span class="line">yarn add vue-color</span><br></pre></td></tr></table></figure><p>然后在文件中引入，这里使用的Chrome样式的调色板。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Chrome &#125; <span class="keyword">from</span> <span class="string">'vue-color'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pickerColor: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="string">"chrome-picker"</span>: Chrome</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;chrome-picker v-model=<span class="string">"pickerColor"</span> /&gt;</span><br></pre></td></tr></table></figure><p>直接通过这个插件获取到的值是一个对象，我们需要处理这个对象。添加如下代码，当调色板颜色发生变化时，改变线条颜色。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  pickerColor: <span class="function"><span class="keyword">function</span>(<span class="params">now</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lineColor = now.hex8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>添加完成之后，就可以开始愉快的更改画笔颜色，但是有点丑，让我们稍微修改一下样式。在文件中添加一些代码。</p><p>在template中，添加以下代码。其中整个线条的颜色的选择器放在了一个浮动的div里面，没有继续使用popover是因为，内层的关闭会造成外层同时关闭。所以自己写了一个类似的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-popover</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"adjustVisible"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:arrowPointAtCenter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>调节笔画<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"close-circle"</span> @<span class="attr">click</span>=<span class="string">"adjustVisible = false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-row</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span>线条粗细<span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"16"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-slider</span> <span class="attr">:min</span>=<span class="string">"1"</span> <span class="attr">:max</span>=<span class="string">"20"</span> <span class="attr">v-model</span>=<span class="string">"lineWidth"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a-row</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-row</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span>线条颜色<span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"16"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"color-body"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:style</span>=<span class="string">"&#123; background: lineColor &#125;"</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">"colorVisible = true"</span></span></span><br><span class="line"><span class="tag">          &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"picker-box"</span> <span class="attr">v-if</span>=<span class="string">"colorVisible"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a-icon</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"picker-cancel"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"close-circle"</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">"colorVisible = false"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">chrome-picker</span> <span class="attr">v-model</span>=<span class="string">"pickerColor"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"btn btn-adjust"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"adjustVisible = true"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    调节笔画</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a-popover</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为popover是直接挂载在 body 上的，所以我们还需要将其挂载在当前组件的根节点上才可以改变器样式。首先在根节点上注册一个ref。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"hand-writing"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后写一个方法，返回注册好的节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleGetContainer() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$refs.box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在popover上使用此方法，就可以更改popover的样式了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-popover</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:getPopupContainer</span>=<span class="string">"handleGetContainer"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-popover</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加如下样式代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.adjust-header</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">188px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.adjust-header</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.adjust-header</span> <span class="selector-class">.anticon</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">21px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ant-row</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">36px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.color-body</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: sub;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picker-box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.15);</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picker-box</span> <span class="selector-class">.picker-cancel</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.picker-box</span> <span class="selector-class">.vc-chrome</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看效果就会发现好很多了，虽然还是有点丑，就不再继续优化了。</p><h4 id="橡皮檫功能"><a href="#橡皮檫功能" class="headerlink" title="橡皮檫功能"></a>橡皮檫功能</h4><p>橡皮檫的实现类似于清除功能，不同的是，清除是擦除整个屏幕，而橡皮檫是擦除某一部分。一样的需要用到 onStart、 onMove、 onEnd 三个方法。所以我们需要一个新变量来存储当前鼠标（也就是手指？我也不知道叫什么合适。。。）的状态，判断当前究竟是画笔还是橡皮擦。不同的状态执行不同的方法。<br>首先在data中添加一个变量 <code>mouseStatus: &quot;brush&quot;</code>。<br>然后在template中添加一个按钮控制其变化</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-button</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"btn btn-switch"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">"mouseStatus = mouseStatus === 'brush' ? 'eraser' : 'brush'"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  切换为&#123;&#123; mouseStatus === "brush" ? "橡皮檫" : "画笔" &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="代码优化-1"><a href="#代码优化-1" class="headerlink" title="代码优化"></a>代码优化</h5><p>然后为了避免代码的冗余，我们需要对代码进行一次大换血，首先定义以下几个方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 通过mouseStatus的值以及鼠标当前的动作阶段来判断该执行哪个方法</span></span><br><span class="line"><span class="comment"> * e: event</span></span><br><span class="line"><span class="comment"> * type: 鼠标当前的动作阶段（start、move、end）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">handleSelectTouch(e, type) &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 画笔画图三步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">onBrushStart(e) &#123;&#125;</span><br><span class="line">onBrushMove(e) &#123;&#125;</span><br><span class="line">onBrushEnd() &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 橡皮檫三步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">onEraserStart(e) &#123;&#125;</span><br><span class="line">onEraserMove(e) &#123;&#125;</span><br><span class="line">onEraserEnd() &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 擦除方法，擦除以点击点为圆心，画笔宽度为直径的圆</span></span><br><span class="line"><span class="comment"> * x: 点击点x坐标</span></span><br><span class="line"><span class="comment"> * y: 点击点y坐标</span></span><br><span class="line"><span class="comment"> * radius: 半径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clearArc(x, y, radius) &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 擦除辅助方法，将擦出点连接起来</span></span><br><span class="line"><span class="comment"> * e: event</span></span><br><span class="line"><span class="comment"> * radius: 半径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clearLine(e, radius) &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要将以下几个方法的内容移至新方法内，并删除。</p><p><del><code>onStart()</code></del> -&gt; <code>onBrushStart()</code><br><del><code>onMove()</code></del> -&gt; <code>onBrushMove()</code><br><del><code>onEnd()</code></del> -&gt; <code>onBrushEnd()</code></p><p>更改部分html代码如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将判断是画笔还是橡皮檫的代码全部放在一个方法里，方便处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">touchstart</span>=<span class="string">"handleSelectTouch($event, 'start')"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">touchmove</span>=<span class="string">"handleSelectTouch($event, 'move')"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">touchend</span>=<span class="string">"handleSelectTouch($event, 'end')"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加判断画笔属性的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleSelectTouch(e, type) &#123;</span><br><span class="line">  <span class="keyword">let</span> _data = <span class="keyword">this</span>.getInitialCapital(<span class="keyword">this</span>.mouseStatus);</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"start"</span>:</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">`on<span class="subst">$&#123;_data&#125;</span>Start`</span>](e); <span class="comment">// 这种调用方法看习惯了就好了</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"move"</span>:</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">`on<span class="subst">$&#123;_data&#125;</span>Move`</span>](e);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">      <span class="keyword">this</span>[<span class="string">`on<span class="subst">$&#123;_data&#125;</span>End`</span>](e);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 将字符串转换为首字母大写的形式</span></span><br><span class="line">getInitialCapital(val) &#123;</span><br><span class="line">  <span class="keyword">return</span> val.replace(<span class="regexp">/\S/</span>, item =&gt; item.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候在橡皮檫的三步方法里添加打印代码后，通过改变画笔属性就可以看到不同的效果了。接下来进入擦除的正题。</p><h5 id="擦除圆形"><a href="#擦除圆形" class="headerlink" title="擦除圆形"></a>擦除圆形</h5><p>在 canvas 的API里面我们发现擦除的方法只有一个 clearRect，而且此方法只能擦除一个矩形，而不能擦除其他图形，这不符合我们的想法。我们只能通过其他方法曲线救国。也就是 clip，clip 是 Canvas 2D API 将当前创建的路径设置为当前剪切路径的方法。也就是说我们可以先画一个圆，然后将这个圆设置为剪切路径，然后使用 clearReact 方法将其擦除。添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onEraserStart(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.offsetLeft = e.target.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.offsetTop = e.target.offsetTop;</span><br><span class="line">  <span class="keyword">this</span>.c1px = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.c1py = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop;</span><br><span class="line">  <span class="keyword">this</span>.clearArc(<span class="keyword">this</span>.c1px, <span class="keyword">this</span>.c1py, <span class="keyword">this</span>.lineWidth / <span class="number">2</span>);</span><br><span class="line">&#125;,</span><br><span class="line">onEraserMove(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.offsetLeft = e.target.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.offsetTop = e.target.offsetTop;</span><br><span class="line">  <span class="keyword">this</span>.c1px = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.c1py = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop;</span><br><span class="line">  <span class="keyword">this</span>.clearArc(<span class="keyword">this</span>.c1px, <span class="keyword">this</span>.c1py, <span class="keyword">this</span>.lineWidth / <span class="number">2</span>);</span><br><span class="line">&#125;,</span><br><span class="line">onEraserEnd() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;,</span><br><span class="line">clearArc(x, y, radius) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ctx.save();</span><br><span class="line">  <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">  <span class="comment">// 画圆，以点击点为圆心坐标，线条的宽度为直径画圆</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.arc(x, y, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  <span class="comment">// 设置为剪切路径</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.clip();</span><br><span class="line">  <span class="comment">// 擦除</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight);</span><br><span class="line">  <span class="keyword">this</span>.ctx.restore();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这时就可以正常的使用橡皮擦了，但是当鼠标移动快一点的时候就会发现擦除的路径是不连续的，造成这种问题的原因是，快速移动的时候，只会画一个圆，但是圆与圆之间的路径是不会被画上的。下面，让我们来优化一下这个橡皮擦。</p><h5 id="优化橡皮擦"><a href="#优化橡皮擦" class="headerlink" title="优化橡皮擦"></a>优化橡皮擦</h5><p>因为画笔的宽度在使用的途中是固定的，也就是说我们在画路径的时候只需要将两个圆之间的矩形也画上就可以了。如下图所示。</p><p><img src="https://jacokwu.cn/images/blog/tablets-arc1.png" alt="矩形路径"></p><p>画这个矩形我们需要知道矩形的四个顶点，但是目前我们只知道其中两条边的中点，也就是两个圆的圆心，我们需要计算以下这四个顶点。<br>首先，我们在上图中添加几条辅助线。如下图所示。</p><p><img src="https://jacokwu.cn/images/blog/tablets-arc2.png" alt="路径辅助线"></p><p>可以看出我们需要得出四个顶点的坐标就必须先求得顶点与圆心的所在的直角三角形的两条直角边的长度。非常简单的相似三角形，有多种方法可以解决，这里使用的是三角函数。方法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sinX = <span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.atan((y2 - y1) / (x2 - x1)))</span><br><span class="line"><span class="keyword">let</span> cosY = <span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.atan((y2 - y1) / (x2 - x1)))</span><br></pre></td></tr></table></figure><p>借助上面的图，可以很轻松的理解这两个计算式。得到了两条直角边的长度，剩下的就是计算四个顶点坐标，然后画矩形了。添加及更改如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onEraserStart(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.offsetLeft = e.target.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.offsetTop = e.target.offsetTop;</span><br><span class="line">  <span class="keyword">this</span>.c1px = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.c1py = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop;</span><br><span class="line">  <span class="comment">// 在矩形起点画圆</span></span><br><span class="line">  <span class="keyword">this</span>.clearArc(<span class="keyword">this</span>.c1px, <span class="keyword">this</span>.c1py, <span class="keyword">this</span>.lineWidth / <span class="number">2</span>);</span><br><span class="line">&#125;,</span><br><span class="line">onEraserMove(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLine(e, <span class="keyword">this</span>.lineWidth / <span class="number">2</span>);</span><br><span class="line">&#125;,</span><br><span class="line">onEraserEnd() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;,</span><br><span class="line">clearArc(x, y, radius) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ctx.save();</span><br><span class="line">  <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">  <span class="keyword">this</span>.ctx.arc(x, y, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  <span class="keyword">this</span>.ctx.clip();</span><br><span class="line">  <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight);</span><br><span class="line">  <span class="keyword">this</span>.ctx.restore();</span><br><span class="line">&#125;,</span><br><span class="line">clearLine(e, radius) &#123;</span><br><span class="line">  <span class="keyword">this</span>.offsetLeft = e.target.offsetLeft;</span><br><span class="line">  <span class="keyword">this</span>.offsetTop = e.target.offsetTop;</span><br><span class="line">  <span class="keyword">let</span> endX = e.touches[<span class="number">0</span>].clientX - <span class="keyword">this</span>.offsetLeft;</span><br><span class="line">  <span class="keyword">let</span> endY = e.touches[<span class="number">0</span>].clientY - <span class="keyword">this</span>.offsetTop;</span><br><span class="line">  <span class="comment">// 在矩形重点画圆</span></span><br><span class="line">  <span class="keyword">this</span>.clearArc(endX, endY, radius);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算辅助边长</span></span><br><span class="line">  <span class="keyword">let</span> sinX =</span><br><span class="line">    radius * <span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.atan((endY - <span class="keyword">this</span>.c1py) / (endX - <span class="keyword">this</span>.c1px)));</span><br><span class="line">  <span class="keyword">let</span> cosY =</span><br><span class="line">    radius * <span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.atan((endY - <span class="keyword">this</span>.c1py) / (endX - <span class="keyword">this</span>.c1px)));</span><br><span class="line">  <span class="keyword">this</span>.ctx.save();</span><br><span class="line">  <span class="comment">// 画矩形</span></span><br><span class="line">  <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">  <span class="keyword">this</span>.ctx.moveTo(<span class="keyword">this</span>.c1px - sinX, <span class="keyword">this</span>.c1py + cosY);</span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.c1px + sinX, <span class="keyword">this</span>.c1py - cosY);</span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(endX + sinX, endY - cosY);</span><br><span class="line">  <span class="keyword">this</span>.ctx.lineTo(endX - sinX, endY + cosY);</span><br><span class="line">  <span class="keyword">this</span>.ctx.closePath();</span><br><span class="line">  <span class="keyword">this</span>.ctx.clip();</span><br><span class="line">  <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight);</span><br><span class="line">  <span class="keyword">this</span>.ctx.restore();</span><br><span class="line">  <span class="keyword">this</span>.c1px = endX;</span><br><span class="line">  <span class="keyword">this</span>.c1py = endY;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>细心的可以看到在方法中有这样两句代码 <code>this.ctx.save();</code> 以及 <code>this.ctx.restore();</code>，第一句代码是保存当前的绘图环境，第二句是重置当前的绘图环境，如果不加这两句的话，在使用完橡皮擦后，绘图会被限制在剪切范围内。</p><h4 id="撤销-amp-还原"><a href="#撤销-amp-还原" class="headerlink" title="撤销&amp;还原"></a>撤销&amp;还原</h4><p>撤销和还原应该算是一个画图板的基本功能，这里就来实现一下。主要思路是定义一个栈（就是数组）来放置每一次更改画板的状态，然后通过一个指针（就是数组下标）来确定当前所在的状态。撤销操作就是将指针移至上一个状态（数组下标减一），还原操作就是将指针移至下一个状态（数组下标加一）。现在来实现这个思路，首先我们需要两个按键来帮助我们实现这两个功能。添加如下代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">class</span>=<span class="string">"btn btn-undo"</span> @<span class="attr">click</span>=<span class="string">"onUndo"</span>&gt;</span></span><br><span class="line">  撤销</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">class</span>=<span class="string">"btn btn-reduction"</span> @<span class="attr">click</span>=<span class="string">"onReduction"</span>&gt;</span></span><br><span class="line">  还原</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 撤销</span></span><br><span class="line">onUndo() &#123;&#125;,</span><br><span class="line"><span class="comment">// 还原</span></span><br><span class="line">onReduction() &#123;&#125;,</span><br></pre></td></tr></table></figure><p>然后在data中定义两个辅助变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">boardData: [],</span><br><span class="line">boardStatus: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后定义一个方法来执行入栈操作（向数组push值）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setBoardStatus(data) &#123;</span><br><span class="line">  <span class="keyword">this</span>.boardData.push(data);</span><br><span class="line">  <span class="keyword">this</span>.boardStatus += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 init 方法中对其初始化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  <span class="comment">// 这里赋值为 -1 是因为下面的入栈操作会对boardStatus进行 +1 处理，这里为了保证一致性</span></span><br><span class="line">  <span class="keyword">this</span>.boardStatus = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">this</span>.boardData = [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.path !== <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filePath = <span class="keyword">this</span>.path;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有默认图片再 push 默认状态</span></span><br><span class="line">    <span class="keyword">this</span>.setBoardStatus(</span><br><span class="line">      <span class="keyword">this</span>.ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后我们需要在每个改变画板状态的动作执行完后执行入栈操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onBrushEnd() &#123;</span><br><span class="line">  <span class="keyword">this</span>.ctx.closePath();</span><br><span class="line">  <span class="keyword">this</span>.setBoardStatus(</span><br><span class="line">    <span class="keyword">this</span>.ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br><span class="line">onEraserEnd() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setBoardStatus(</span><br><span class="line">    <span class="keyword">this</span>.ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvasWidth, <span class="keyword">this</span>.canvasHeight)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>接下来我们开始实现撤销功能，就是将当前的画板置为上一个状态。在 onUndo() 中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onUndo() &#123;</span><br><span class="line">  <span class="keyword">this</span>.boardStatus--;</span><br><span class="line">  <span class="comment">// 判断上一个状态是否存在，存在则将当前画板置为上一个状态，否则提示错误，下标归位。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.boardStatus &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx.putImageData(<span class="keyword">this</span>.boardData[<span class="keyword">this</span>.boardStatus], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.boardStatus++;</span><br><span class="line">    <span class="keyword">this</span>.$message.info(<span class="string">"已经是第一步了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>还原功能类似与撤销功能，就是将当前的画板置为下一个状态。在 onReduction() 中添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onReduction() &#123;</span><br><span class="line">  <span class="keyword">this</span>.boardStatus++;</span><br><span class="line">  <span class="comment">// 判断下一个状态是否存在，存在则将当前画板置为下一个状态，否则提示错误，下标归位。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.boardStatus &lt; <span class="keyword">this</span>.boardData.length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx.putImageData(<span class="keyword">this</span>.boardData[<span class="keyword">this</span>.boardStatus], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.boardStatus--;</span><br><span class="line">    <span class="keyword">this</span>.$message.info(<span class="string">"已经是最新的了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>至此撤销还原功能就完全实现了，有一个缺点就是当动作执行的比较多了之后会比较占内存。可以考虑使用 history 实现同样的功能。</p><h4 id="源码-amp-在线预览"><a href="#源码-amp-在线预览" class="headerlink" title="源码&amp;在线预览"></a>源码&amp;在线预览</h4><p>预览请打开控制台在手机模式下运行。笔画位置有误差请刷新浏览器。<br><a href="https://jacokwu.cn/vue-demo/dist/#/hand-writing2">DEMO</a></p><p>源码：<a href="https://github.com/JaCoxxx/vue-demo/blob/master/src/views/HandWritingBoard2/index.vue" target="_blank" rel="noopener">GitHub</a></p><h3 id="功能菜单样式优化"><a href="#功能菜单样式优化" class="headerlink" title="功能菜单样式优化"></a>功能菜单样式优化</h3><p>看着惨不忍睹的界面是时候优化一下样式了。目前的想法是做一个收缩可移动的菜单。效果如图所示。</p><p><img src="https://jacokwu.cn/images/blog/tablets-eg2.png" alt="效果图1"><br><img src="https://jacokwu.cn/images/blog/tablets-eg3.png" alt="效果图2"></p><p>首先说一下实现这个所需要掌握的知识点。包括：touch相关三个方法、transform与transition。（emmmm，好像也没有什么高深的技术。）</p><h4 id="菜单控制按钮的实现"><a href="#菜单控制按钮的实现" class="headerlink" title="菜单控制按钮的实现"></a>菜单控制按钮的实现</h4><p>这是一个在移动端比较常见的菜单按键。这里自己实现一下。</p><h5 id="菜单按钮"><a href="#菜单按钮" class="headerlink" title="菜单按钮"></a>菜单按钮</h5><p>首先我们需要在上一章节的基础上更改一下HTML的结构。如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"hand-writing"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"!app"</span> <span class="attr">style</span>=<span class="string">"height: 100%"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-if</span>=<span class="string">"filePath"</span> <span class="attr">:src</span>=<span class="string">"filePath"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"menu-box"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">"&#123; top: `$&#123;menuTop&#125;px`, left: `$&#123;menuLeft&#125;px` &#125;"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchstart</span>=<span class="string">"onMenuStart($event)"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchmove</span>=<span class="string">"onMenuMove($event)"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchend</span>=<span class="string">"onMenuEnd($event)"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; 'list-show': menuShow &#125;"</span> <span class="attr">class</span>=<span class="string">"menu-list"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:class</span>=<span class="string">"&#123; 'btn-checked': menuShow &#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"menu-btn"</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">"onClickMenuBtn"</span></span></span><br><span class="line"><span class="tag">          &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"menu-btn-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"menu-btn-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"menu-btn-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item item-checked"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>暂不支持QQ浏览器,请选择其他浏览器打开。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在canvas同层结构外添加了一层div，是为了将QQ浏览器屏蔽掉。你也可以去掉这一层。然后删除了之前所有的功能按钮，添加了一个菜单控制按钮。菜单按钮的动态style是为了方便控制菜单的位置。然后我们添加及更改一下样式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-tag">div</span><span class="selector-class">.list-show</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-class">.menu-list</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">27px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-class">.menu-list</span> <span class="selector-class">.menu-btn</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-class">.menu-list</span> <span class="selector-class">.menu-btn</span> <span class="selector-class">.menu-btn-item</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: transform .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-checked</span> <span class="selector-class">.menu-btn-item</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(7px) <span class="built_in">rotate</span>(45deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-class">.menu-list</span> <span class="selector-class">.btn-checked</span> <span class="selector-class">.menu-btn-item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-checked</span> <span class="selector-class">.menu-btn-item</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu-box</span> <span class="selector-class">.menu-list</span> <span class="selector-class">.list-item</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-checked</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式很简单，就不多介绍了，如果你对transform和transition不太了解，可以关注一下我的下一篇博客。</p><p>然后我们定义一个控制菜单开关的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onClickMenuBtn() &#123;</span><br><span class="line">  <span class="keyword">this</span>.menuShow = !<span class="keyword">this</span>.menuShow;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>到了这里其实大部分都已经完成了，剩下的只有div的移动，而在前两个章节，我们都在于此打交道，所以是很简单了。我们继续。</p><h5 id="菜单移动"><a href="#菜单移动" class="headerlink" title="菜单移动"></a>菜单移动</h5><p>在data中添加几个辅助变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 菜单相关</span></span><br><span class="line">      menuShow: <span class="literal">false</span>, <span class="comment">// 控制菜单的显示隐藏</span></span><br><span class="line">      menuTop: <span class="number">0</span>, <span class="comment">// 菜单的top</span></span><br><span class="line">      menuLeft: <span class="number">0</span>, <span class="comment">// 菜单的left</span></span><br><span class="line">      menuX: <span class="number">0</span>, <span class="comment">// 辅助坐标X</span></span><br><span class="line">      menuY: <span class="number">0</span> <span class="comment">// 辅助坐标Y</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们添加一下控制移动的三个方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onMenuStart(e) &#123;</span><br><span class="line">  <span class="comment">// 将点击点存起来</span></span><br><span class="line">  <span class="keyword">this</span>.menuX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">  <span class="keyword">this</span>.menuY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;,</span><br><span class="line">onMenuMove(e) &#123;</span><br><span class="line">  <span class="comment">// 获取当前点击点</span></span><br><span class="line">  <span class="keyword">let</span> x = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">  <span class="keyword">let</span> y = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">  <span class="comment">// 当前点和在onMenuStart中保存的点的距离就是菜单移动的距离</span></span><br><span class="line">  <span class="keyword">this</span>.menuTop += y - <span class="keyword">this</span>.menuY;</span><br><span class="line">  <span class="keyword">this</span>.menuLeft += x - <span class="keyword">this</span>.menuX;</span><br><span class="line">  <span class="comment">// 将当前点存起来</span></span><br><span class="line">  <span class="keyword">this</span>.menuX = x;</span><br><span class="line">  <span class="keyword">this</span>.menuY = y;</span><br><span class="line">&#125;,</span><br><span class="line">onMenuEnd() &#123;</span><br><span class="line">  <span class="comment">//   console.log("object");</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这时候就可以进行正常的移动的，但是一不小心移出去了怎么办？让我们添加一个边界判断的方法，让菜单只在可视内容区域移动。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入当前的left、top，如果超出边界就处理一下。</span></span><br><span class="line">handleBorderJudgment(left, top) &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="keyword">this</span>.canvasWidth - <span class="number">35</span>) &#123; <span class="comment">// 这里减去菜单的宽度为了避免菜单宽度造成的影响</span></span><br><span class="line">    left = <span class="keyword">this</span>.canvasWidth - <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top &gt; <span class="keyword">this</span>.canvasHeight - <span class="number">27</span>) &#123; <span class="comment">// 这里减去菜单的高度为了避免菜单高度造成的影响</span></span><br><span class="line">    top = <span class="keyword">this</span>.canvasHeight - <span class="number">27</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    left,</span><br><span class="line">    top</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后我们只需要在移动过程中使用这个方法就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onMenuMove(e) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">  <span class="keyword">let</span> y = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">  <span class="keyword">this</span>.menuTop += y - <span class="keyword">this</span>.menuY;</span><br><span class="line">  <span class="keyword">this</span>.menuLeft += x - <span class="keyword">this</span>.menuX;</span><br><span class="line">  <span class="comment">// 将计算出来的值判断一下然后重新赋值</span></span><br><span class="line">  <span class="keyword">let</span> _data = <span class="keyword">this</span>.handleBorderJudgment(<span class="keyword">this</span>.menuLeft, <span class="keyword">this</span>.menuTop);</span><br><span class="line">  <span class="keyword">this</span>.menuTop = _data.top;</span><br><span class="line">  <span class="keyword">this</span>.menuLeft = _data.left;</span><br><span class="line">  <span class="keyword">this</span>.menuX = x;</span><br><span class="line">  <span class="keyword">this</span>.menuY = y;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这时候移动到边界会发现还有一个bug，就是打开菜单的时候会撑开内容区域，这不是我们想要的，所以在 onMenuMove 第一行添加一行代码 <code>this.menuShow = false;</code>，当移动时，我们手动让他关闭就可以了。</p><h5 id="菜单功能添加"><a href="#菜单功能添加" class="headerlink" title="菜单功能添加"></a>菜单功能添加</h5><p>菜单使用的都是icon，但是ant的图标不多，所以我在阿里图标库创建了一个小应用，你可以直接拿去用。</p><p>首先，按照ant的介绍，添加如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Icon &#125; <span class="keyword">from</span> <span class="string">'ant-design-vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IconFont = Icon.createFromIconfontCN(&#123;</span><br><span class="line">  scriptUrl: <span class="string">'//at.alicdn.com/t/font_1372570_awwwx5suzr.js'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    IconFont,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更改HTML部分代码如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">"&#123; 'item-checked': mouseStatus === 'brush' &#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"list-item"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-popover</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"adjustVisible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placement</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:arrowPointAtCenter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:getPopupContainer</span>=<span class="string">"handleGetContainer"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>调节笔画<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"close-circle"</span> @<span class="attr">click</span>=<span class="string">"adjustVisible = false"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span>线条粗细<span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"16"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a-slider</span> <span class="attr">:min</span>=<span class="string">"1"</span> <span class="attr">:max</span>=<span class="string">"20"</span> <span class="attr">v-model</span>=<span class="string">"lineWidth"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-row</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span>线条颜色<span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"16"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"color-body"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:style</span>=<span class="string">"&#123; background: lineColor &#125;"</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">"colorVisible = true"</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"picker-box"</span> <span class="attr">v-if</span>=<span class="string">"colorVisible"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a-icon</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"picker-cancel"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">"close-circle"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">click</span>=<span class="string">"colorVisible = false"</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">chrome-picker</span> <span class="attr">v-model</span>=<span class="string">"pickerColor"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-row</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"edit"</span> @<span class="attr">click</span>=<span class="string">"onClickEdit"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-popover</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">"&#123; 'item-checked': mouseStatus === 'eraser' &#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"list-item"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-popover</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"eraserVisible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placement</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:arrowPointAtCenter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:getPopupContainer</span>=<span class="string">"handleGetContainer"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>调节橡皮擦<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"close-circle"</span> @<span class="attr">click</span>=<span class="string">"eraserVisible = false"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"adjust-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"8"</span>&gt;</span>橡皮宽度<span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-col</span> <span class="attr">:span</span>=<span class="string">"16"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a-slider</span> <span class="attr">:min</span>=<span class="string">"1"</span> <span class="attr">:max</span>=<span class="string">"50"</span> <span class="attr">v-model</span>=<span class="string">"eraserWidth"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">a-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-row</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">icon-font</span> <span class="attr">type</span>=<span class="string">"icon-eraser"</span> @<span class="attr">click</span>=<span class="string">"onClickEraser"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-popover</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span><span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"undo"</span> @<span class="attr">click</span>=<span class="string">"onUndo"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"redo"</span> @<span class="attr">click</span>=<span class="string">"onReduction"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span><span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"delete"</span> @<span class="attr">click</span>=<span class="string">"onClear"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">"save"</span> @<span class="attr">click</span>=<span class="string">"onGenerate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要功能都是将之前章节的直接拿过来了，无需更多的更改。然后添加两个方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击画笔</span></span><br><span class="line">onClickEdit() &#123;</span><br><span class="line">  <span class="keyword">this</span>.adjustVisible = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.mouseStatus = <span class="string">"brush"</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 点击橡皮</span></span><br><span class="line">onClickEraser() &#123;</span><br><span class="line">  <span class="keyword">this</span>.eraserVisible = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.mouseStatus = <span class="string">"eraser"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个插件的功能也扩展完成了，样式也改了，其他的小细节，就自己再改一改就好了。</p><h4 id="源码-amp-在线预览-1"><a href="#源码-amp-在线预览-1" class="headerlink" title="源码&amp;在线预览"></a>源码&amp;在线预览</h4><p>预览请打开控制台在手机模式下运行。笔画位置有误差请刷新浏览器。<br><a href="https://jacokwu.cn/vue-demo/dist/#/hand-writing3">DEMO</a></p><p>源码：<a href="https://github.com/JaCoxxx/vue-demo/blob/master/src/views/HandWritingBoard3/index.vue" target="_blank" rel="noopener">GitHub</a></p><h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h3><ol><li><strong>HTML5 实现橡皮擦的擦除效果</strong>: <a href="https://www.cnblogs.com/axes/p/3850309.html" target="_blank" rel="noopener">博客地址</a></li><li><strong>手把手教你实现一个canvas智绘画板</strong>: <a href="https://juejin.im/post/5c7bf106e51d454b47558882" target="_blank" rel="noopener">博客地址</a></li><li><strong>使用 CSS overscroll-behavior 控制滚动行为：自定义下拉刷新和溢出效果</strong>: <a href="https://segmentfault.com/a/1190000012014962" target="_blank" rel="noopener">博客地址</a></li><li><strong>Vue Color Pickers for Sketch, Photoshop, Chrome &amp; more</strong>: <a href="https://github.com/xiaokaike/vue-color" target="_blank" rel="noopener">博客地址</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> canvas </tag>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter开发Bug总结</title>
      <link href="/blog/2019/07/31/Flutter%E5%BC%80%E5%8F%91Bug%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2019/07/31/Flutter%E5%BC%80%E5%8F%91Bug%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本篇文章总结一下在Flutter开发过程中遇到的BUG及其解决方案，不定期更新。</p><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><ul><li>系统：Windows 10 家庭中文版</li><li>编译器：VS code</li><li>Android版本：Android8.1.0</li><li>Android SDK Tools: 26.1.1</li></ul><h3 id="flutter-RangeError-index-Invalid-value-Valid-value-range-is-empty-0"><a href="#flutter-RangeError-index-Invalid-value-Valid-value-range-is-empty-0" class="headerlink" title="flutter RangeError (index): Invalid value: Valid value range is empty: 0"></a>flutter RangeError (index): Invalid value: Valid value range is empty: 0</h3><ul><li><p>问题描述：在页面类中定义了一个List，然后在 initState() 中通过 add() 对其赋值，没有语法错误，但是在运行过程中报错。</p></li><li><p>代码详情：</p></li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RootPage</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RootPage</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span> _currentIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; pages = <span class="built_in">List</span>();</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    pages</span><br><span class="line">    ..add(HomePage())</span><br><span class="line">    ..add(ShopPage());</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// print(pages[0]);</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: pages[_currentIndex],</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>错误详情：看报错是因为List中没有值，然后使用的时候就会出现引用错误。</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">I/flutter ( <span class="number">3569</span>): ══╡ EXCEPTION CAUGHT BY WIDGETS LIBRARY ╞═══════════════════════════════════════════════════════════</span><br><span class="line">I/flutter ( <span class="number">3569</span>): The following RangeError was thrown building BottomAppBarNav(dirty, state:</span><br><span class="line">I/flutter ( <span class="number">3569</span>): BottomAppBArNavState#<span class="number">0</span>f3a1):</span><br><span class="line">I/flutter ( <span class="number">3569</span>): RangeError (index): Invalid value: Valid value range <span class="keyword">is</span> empty: <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>解决方案：在项目根目录运行此命令：<code>flutter clean</code>，然后再次运行项目，正常运行。</p></li><li><p>答案来源：<a href="https://github.com/flutter/flutter/issues/17831#issuecomment-391808736" target="_blank" rel="noopener">GITHUB</a></p></li><li><p>问题扩展：依据此issues，如果出现错误<code>RangeError: RangeError (index): Invalid value: Only valid value is 0: 1</code>，一样可以用此方法解决。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUG </tag>
            
            <tag> FLutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站与工具收藏</title>
      <link href="/blog/2019/07/30/%E7%BD%91%E7%AB%99%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F/"/>
      <url>/blog/2019/07/30/%E7%BD%91%E7%AB%99%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<p>平时工作、学习中收藏的一些比较好用的资源，做一个分类整理，方便使用。<br>谷歌扩展在每一类中的最后一个小类中展示，不再特别分类。</p><h2 id="搜索-amp-分享-amp-社区"><a href="#搜索-amp-分享-amp-社区" class="headerlink" title="搜索&amp;分享&amp;社区"></a>搜索&amp;分享&amp;社区</h2><ul><li><a href="https://search.chongbuluo.com/" target="_blank" rel="noopener">虫部落</a></li></ul><p>虫部落是一个将搜索和社区整合到一起的一个网站吧，在这里你可以通过快搜搜索图片、音乐、资源、学术文章、数据、电子书等等你能想到的大部分东西；你还可以在虫部落的社区分享自己的技能、知识，查看别人的分享。<br>注册需要答题，相对有点难度，但是只要用心就一定可以做出来。不过不注册也可以，不登录也可以查看大部分内容。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h4><ul><li><a href="https://imweb.io/" target="_blank" rel="noopener">Web前端 腾讯IMWeb 团队社区</a></li></ul><p>一个前端学习社区，目前搜搜引擎好像搜索不到论文内的文章？</p><ul><li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a></li></ul><p>这个就不用多说了吧。</p><ul><li><a href="https://segmentfault.com" target="_blank" rel="noopener">思否</a></li></ul><p>可以提问可以发文章的地方。</p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ul><li><a href="https://www.zhangxinxu.com" target="_blank" rel="noopener">张鑫旭</a></li></ul><p>目前只存了这一个大佬的博客</p><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><ul><li><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/" target="_blank" rel="noopener">Vue.js 技术揭秘</a></li></ul><p>深入了解Vue</p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><p>这个名字起的真的是。。。</p><ul><li><a href="https://console.firebase.google.com/" target="_blank" rel="noopener">firebase</a></li></ul><p>谷歌出品的一个网络数据库，存储的是JSON格式的，方便前端调试，需要科学上网才能使用。</p><ul><li><a href="https://www.wilddog.com/" target="_blank" rel="noopener">野狗云</a></li></ul><p>提供数据存储、智能短信、音视频通讯等服务，但是之前好像融资不成功，偶尔会有问题。</p><ul><li><a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener">JSONPlaceholder</a></li></ul><p>提供返回JSON格式数据的接口，类型很多，平时调试很方便。</p><ul><li><a href="https://www.juhe.cn/" target="_blank" rel="noopener">聚合数据</a></li></ul><p>提供数据接口，接口类型非常多，而且还有提供免费试用的接口，以及后端的API模板。甚至还有返回冷笑话的接口。</p><ul><li><a href="https://dashboard.heroku.com/apps" target="_blank" rel="noopener">Heroku</a></li></ul><p>免费的云服务器，可以上传5个应用，但是需要科学上网，不然太慢了。替代品：GitHub。</p><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><ul><li><a href="https://book.flutterchina.club/" target="_blank" rel="noopener">Flutter 实战</a></li></ul><p>学习Flutter必备</p><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li></ul><p>神器呀，有木有。</p><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><ul><li><a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React 小书</a></li></ul><p>配备了一个小DEMO，适合初学者。写的不错。</p><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ul><li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">Node.js 包教不包会</a></li></ul><p>对初学者不太友好，还没有写完，看了一部分，还不错。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><a href="https://docschina.org/" target="_blank" rel="noopener">印记中文</a></li></ul><p>对前端知识的网站的一个整理。</p><ul><li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">awesome</a></li></ul><p>对所有知识的一个整理，不局限于前端。</p><ul><li><a href="https://color.adobe.com/zh/create/color-wheel/" target="_blank" rel="noopener">色轮</a></li></ul><p>在线调配颜色，非常方便。</p><h4 id="谷歌扩展"><a href="#谷歌扩展" class="headerlink" title="谷歌扩展"></a>谷歌扩展</h4><ul><li>Google 翻译</li></ul><p>看英文文档必备</p><ul><li>React Developer Tools</li></ul><p>React调试工具</p><ul><li>Redux DevTools</li></ul><p>Redux调试工具</p><ul><li>Vue.js devtools</li></ul><p>Vue调试工具</p><ul><li>WEB前端助手(FeHelper)</li></ul><p>Awesome，All In One的一个工具，包含多个独立小应用，比如：Json工具、代码美化工具、代码压缩、二维码工具、markdown工具、网页油猴工具、便签笔记工具、信息加密与解密、随机密码生成、Crontab等等。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p>做毕业设计的时候存了好多转换的网站。。。之前是啥效果已经忘了，有空了筛选一下。</p><ul><li><a href="https://www.docspal.com/" target="_blank" rel="noopener">Online File Converter</a></li></ul><p>国外网站，可以转常见的格式文件</p><ul><li><a href="https://www.hipdf.com/" target="_blank" rel="noopener">Hipdf</a></li></ul><p>国外网站，主要是针对PDF的转换，需要注册后使用。</p><ul><li><a href="https://ocr.abbyy.cn/" target="_blank" rel="noopener">泰比</a></li></ul><p>ABBYY提供免费的在线OCR服务，让你转换扫描和拍摄图像、PDF文档到Word。<br>需要提供邮箱。网站很丑。。</p><ul><li><a href="http://www.pdfdo.com/pdf-to-word.aspx" target="_blank" rel="noopener">PDF转换器</a></li></ul><p>可以转换PDF和图片。</p><ul><li><a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">iLovePDF</a></li></ul><p>完全免费的PDF文件在线管理工具，无需安装。</p><ul><li><a href="https://www.onlineocr.net/" target="_blank" rel="noopener">Free Online OCR</a></li></ul><p>英文网站，界面很简单。</p><ul><li><a href="https://smallpdf.com/cn/unlock-pdf" target="_blank" rel="noopener">PDF解密</a></li></ul><p>可以试用7天。</p><ul><li><a href="http://www.docpe.com/" target="_blank" rel="noopener">档铺</a></li></ul><p>提供Word、Excel、PPT、PDF、图片、HTML转换，工作的时候用的Excel转HTML，效果不错，就是代码量太大了。。。</p><h3 id="BT"><a href="#BT" class="headerlink" title="BT"></a>BT</h3><p>BT网站只提供网站，不想介绍了。。</p><ul><li><p><a href="https://www.torrentkitty.tv/search/" target="_blank" rel="noopener">Torrent Kitty</a></p></li><li><p><a href="https://zooqle.com" target="_blank" rel="noopener">Zooqle</a></p></li><li><p><a href="https://btsow.pw/tags" target="_blank" rel="noopener">BTSOW</a></p></li><li><p><a href="btkitty.pet">BT Kitty</a></p></li><li><p><a href="https://www.868888.net" target="_blank" rel="noopener">申博</a></p></li><li><p><a href="https://www.69m.xyz" target="_blank" rel="noopener">69MAG</a></p></li><li><p><a href="btlibrary.co">P2P种子</a></p></li><li><p><a href="https://www.cilimao.cc" target="_blank" rel="noopener">磁力猫</a></p></li><li><p><a href="www.minibt.com">MiniBT</a></p></li><li><p><a href="www.btbit.fun/index.html">Btbit</a></p></li><li><p><a href="https://eztv.io" target="_blank" rel="noopener">EZTV</a></p></li></ul><h3 id="其他-这里有好东西哦"><a href="#其他-这里有好东西哦" class="headerlink" title="其他 - 这里有好东西哦"></a>其他 - 这里有好东西哦</h3><ul><li><a href="http://www.atool9.com/" target="_blank" rel="noopener">在线工具</a></li></ul><p>小工具还是挺多的，也没有广告。</p><ul><li><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a></li></ul><p>在线Visio，帮我解决了很多问题，就是只能存9张图。</p><ul><li><a href="http://www.dayanzai.me/" target="_blank" rel="noopener">大眼仔</a></li></ul><p>提供软件下载。广告较少，无辣眼广告。</p><ul><li><a href="http://www.sdifen.com/" target="_blank" rel="noopener">史蒂芬周的博客</a></li></ul><p>提供软件下载。广告较少，无辣眼广告。</p><ul><li><a href="https://hoodiearon.github.io/fq-book/#/" target="_blank" rel="noopener">这本书能让你连接互联网 Ⅱ</a></li></ul><p>看书名就知道了吧。</p><ul><li><a href="https://github.com/hoodiearon/WebSiteOutlook" target="_blank" rel="noopener">WebSiteOutlook</a></li></ul><p>冲出你的窗口。上本书的仓库，对知识的整合。</p><ul><li><a href="https://stool.cf/" target="_blank" rel="noopener">阅后即焚</a></li></ul><p>将一段话生成一个网址，看完即删除。</p><ul><li><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">云短信</a></li></ul><p>提供手机号用以注册网站，很方便。</p><ul><li><a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">临时邮箱</a></li></ul><p>提供邮箱账号用以注册网站，很方便。</p><ul><li><a href="http://chromecj.com/" target="_blank" rel="noopener">Chrome插件</a></li></ul><p>对谷歌插件的整合。</p><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>（未完待续）</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[原]JS原生数组方法的用法及其实现（二）</title>
      <link href="/blog/2019/03/26/%E5%8E%9F-JS%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/blog/2019/03/26/%E5%8E%9F-JS%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文原载于<a href="https://blog.csdn.net/jacoox/article/details/88805641" target="_blank" rel="noopener">CSDN</a></p></blockquote><p>（接上一篇，过去了好几个月了，突然想到这里还留了一个坑。。。）</p><h3 id="九、entries"><a href="#九、entries" class="headerlink" title="九、entries()"></a>九、entries()</h3><blockquote><p><code>entries()</code> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</p></blockquote><p>entries()函数返回的是一个数组的迭代对象，与Generator 函数（可以参考阮一峰大叔写的ES6入门中的介绍<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数</a>）的返回结果是一样的，所以直接通过 <code>.next()</code>依次得到结果，其中。如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> ent = arr.entries()</span><br><span class="line"><span class="built_in">console</span>.log(ent.next()) <span class="comment">// &#123;value: Array(2), done: false&#125;</span></span><br><span class="line"><span class="comment">// 其中，value是一个数组，为 [0, 1]，分别代表下标，以及下标对应的值</span></span><br><span class="line"><span class="comment">// done 是一个Boolean类型的值，代表遍历是否以经结束</span></span><br><span class="line"><span class="built_in">console</span>.log(ent.next()) <span class="comment">// &#123;value: Array(2), done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ent.next()) <span class="comment">// &#123;value: Array(2), done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ent.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="comment">// 遍历结束，done值变为true</span></span><br></pre></td></tr></table></figure><p>实现方法的核心就是<code>Generator 函数</code>。利用其的特性来完成数组的迭代。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myEntries = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// function* () 是Generator函数的定义方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// 遍历数组，返回一个包含下标和对应值的数组</span></span><br><span class="line"><span class="keyword">yield</span> [key - <span class="number">1</span>, <span class="keyword">this</span>[key - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十、find"><a href="#十、find" class="headerlink" title="十、find()"></a>十、find()</h3><blockquote><p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p></blockquote><p><code>find()</code>类似于<code>some()</code>，不同的是，<code>some()</code>是判断目标数组中是否含有满足条件的值，返回一个<code>Boolean</code>类型的值，而<code>find()</code>是找到目标数组中满足条件的第一个值，并返回该值。使用方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.find(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// =&gt; es6箭头函数</span></span><br><span class="line">arr.find(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">5</span>) <span class="comment">// undefined</span></span><br><span class="line">arr.find(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">5</span>) <span class="comment">// Uncaught TypeError: undefined is not a function</span></span><br><span class="line"><span class="comment">// find()中的参数函数依旧接收三个参数，分别为 value, index, arr</span></span><br></pre></td></tr></table></figure><p>可见，<code>find()</code>依旧是通过遍历来查找符合条件的值，实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFind = <span class="function"><span class="keyword">function</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = <span class="keyword">this</span>.length</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="comment">// 参数必须类型为函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a funciton`</span>)</span><br><span class="line"><span class="comment">// 抛出一个错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一、findIndex"><a href="#十一、findIndex" class="headerlink" title="十一、findIndex()"></a>十一、findIndex()</h3><blockquote><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</p></blockquote><p><code>findIndex()</code>与<code>find()</code>唯一的区别就是一个返回元素本身，一个返回索引。使用方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.findIndex(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">3</span>) <span class="comment">// -1</span></span><br><span class="line">arr.findIndex() <span class="comment">// Uncaught TypeError: undefined is not a function</span></span><br><span class="line"><span class="comment">// findIndex()中的参数函数依旧接收三个参数，分别为 value, index, arr</span></span><br></pre></td></tr></table></figure><p>实现方法与<code>find()</code>的实现也是仅有一点差别，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFindIndex = <span class="function"><span class="keyword">function</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = <span class="keyword">this</span>.length</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="comment">// 参数必须类型为函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)) &#123;</span><br><span class="line">     <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a funciton`</span>)</span><br><span class="line"><span class="comment">// 抛出一个错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="comment">// 没有查找到符合条件的，返回-1，find()的实现中没写，默认返回 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二、flat"><a href="#十二、flat" class="headerlink" title="十二、flat()"></a>十二、flat()</h3><blockquote><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p></blockquote><p>刚看到的时候一脸懵逼，啥时候居然有这么厉害的方法了。。。<br><code>flat()</code>照我的理解就是将一个多维数组转换为低维数组，以及去掉其中的空项，同时，此方法不会改变原数组。使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flat 接收一个参数，默认参数值为 1</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]]</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, , <span class="number">3</span>, <span class="number">4</span>, <span class="literal">undefined</span>, <span class="literal">null</span>] <span class="comment">// 稀疏数组</span></span><br><span class="line">arr1.flat() <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr2.flat() <span class="comment">// [1, 2, 3, [4, 5, [6, 7]]]</span></span><br><span class="line"><span class="comment">// 采用默认值 1，只提取了一层的多维数组，让维度从4变为3</span></span><br><span class="line">arr2.flat(<span class="number">3</span>) <span class="comment">// [1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line">arr3.flat() <span class="comment">// [1, 3, 4, undefined, null]</span></span><br><span class="line"><span class="comment">// 只去掉了空项，而不管值是否为 undefined，或 null</span></span><br></pre></td></tr></table></figure><p>实现的话，二维降一维很简单，通过解构就可以实现，那么多维降维，就需要多次解构，但是这个次数是不一定的，所以可以通过递归实现。实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFlat = <span class="function"><span class="keyword">function</span>(<span class="params">src = <span class="number">1</span>, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [], <span class="comment">// 存放生成的新数组</span></span><br><span class="line">oArr = [] <span class="comment">// 临时数组</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> src === <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (src === <span class="number">1</span>) &#123;</span><br><span class="line">oArr = [].concat(...this)</span><br><span class="line"><span class="comment">// 通过解构对数组降维，每次降一维</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">oArr = [].concat(...this.myFlat(src - <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 递归降维</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;src&#125;</span> is not a number.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">oArr.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> newArr.push(ele))</span><br><span class="line"><span class="comment">// 通过forEach去掉空项，map也可以实现</span></span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上有个缺陷，就是对输入的过大的参数没有处理。</p><h3 id="十三、includes"><a href="#十三、includes" class="headerlink" title="十三、includes()"></a>十三、includes()</h3><blockquote><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p></blockquote><p>看到这个方法就想到了<code>some()</code>，二者有异曲同工之妙，<code>some()</code>是判断指定数组是否有元素符合条件，而<code>includes()</code>则将这个条件直接限制为了一个具体的值。使用方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// includes 接收两个参数，第一个是要查找的值 src，第二个是开始查找的索引 index</span></span><br><span class="line"><span class="comment">// 如果第二个参数即索引为正，则从该索引处开始查找</span></span><br><span class="line"><span class="comment">// 如果第二个参数即索引为负，则从 arr.length + index 处开始查找</span></span><br><span class="line"><span class="comment">// 第二个参数的默认值为 0</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.includes(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="number">2</span>, <span class="number">-1</span>) <span class="comment">// false</span></span><br><span class="line">arr.includes()  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实现方法类似于<code>some()</code>的实现，不再赘述，直接开始：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myIncludes = <span class="function"><span class="keyword">function</span> (<span class="params">src, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>, <span class="comment">// 返回值，默认返回 false</span></span><br><span class="line">len = <span class="keyword">this</span>.length</span><br><span class="line">index = index &gt;= <span class="number">0</span> ? index : len + index <span class="comment">// 判断索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = index; i &lt; len; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] === src) &#123; </span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十四丶indexOf"><a href="#十四丶indexOf" class="headerlink" title="十四丶indexOf"></a>十四丶indexOf</h3><blockquote><p><code>indexOf()</code>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p></blockquote><p>（未完待续）</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arrays </tag>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]JS原生数组方法的用法及其实现</title>
      <link href="/blog/2018/09/13/%E5%8E%9F-JS%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2018/09/13/%E5%8E%9F-JS%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文原载于<a href="https://blog.csdn.net/jacoox/article/details/82693994" target="_blank" rel="noopener">CSDN</a></p></blockquote><p>此文章将会介绍数组大部分的原生方法的用法，并自己实现一个具有相同功能的方法，不定期更新。顺序暂时看起来比较乱，所有方法都写完后会重新整理一下。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JS原生数组方法的参数都大致符合下面的通式（针对不同的参数，会在遇到之后补充），比较常见的方法一大部分都是遍历一遍数组，然后给每个元素执行一次提供的函数，也就是回调函数，所以实现基本都是基于遍历的。其他的，会在后面详细说明。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.method( <span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// value : 必选，当前元素</span></span><br><span class="line">    <span class="comment">// index : 可选，当前元素索引值</span></span><br><span class="line">    <span class="comment">// arr : 可选，当前数组</span></span><br><span class="line">    <span class="comment">// thisValue : 可选，替换当前的this指向</span></span><br><span class="line">&#125;, thisValue)</span><br></pre></td></tr></table></figure><p>大致将数组方法分为两类，一类是改变原数组的方法，一类是不改变原数组的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 改变原数组</span></span><br><span class="line">arr.push();</span><br><span class="line">arr.pop();</span><br><span class="line">arr.unshift();</span><br><span class="line">arr.shift();</span><br><span class="line">arr.reverse();</span><br><span class="line">arr.solice();</span><br><span class="line">arr.sort();</span><br><span class="line">arr.copyWithin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不改变原数组</span></span><br><span class="line">arr.concat();</span><br><span class="line">arr.toString();</span><br><span class="line">arr.slice();</span><br><span class="line">arr.join();</span><br><span class="line">arr.split();</span><br><span class="line">arr.forEach();</span><br><span class="line">arr.map();</span><br><span class="line">arr.filter();</span><br><span class="line">arr.some();</span><br><span class="line">arr.every();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><blockquote><p><code>forEach()</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。</p></blockquote><p><code>forEach()</code> 没有什么好说的，就是遍历数组的所有元素，需要注意的就是此方法不会改变原数组。使用方法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>实现起来也很简单，就是遍历一次数组，然后给每个元素都执行一次回调函数，直接上实现代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123; <span class="comment">// 第一个参数必须是函数才能执行，否则报错</span></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i ++) &#123;</span><br><span class="line">            fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>) <span class="comment">// 将this绑定到回调函数之上，并传入参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，</span></span><br><span class="line"><span class="comment">// fn : 回调函数</span></span><br><span class="line"><span class="comment">// callback : this指向</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote><p><code>map()</code> 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p></blockquote><p><code>map()</code> 就相当于是在 <code>forEach()</code> 方法上的扩展，遍历所有元素并以相同的规则改变元素后返回一个新数组。用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val * index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [0, 2, 6, 12]</span></span><br></pre></td></tr></table></figure><p><code>map()</code> 就是加强版的 <code>forEach()</code> ，所以实现方法大致相同，只是多了一个返回新数组，实现如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [] <span class="comment">// 与 forEach() 的区别所在，返回一个新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i ++) &#123;</span><br><span class="line">        arr.push(fn.call(callback, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p></blockquote><p>filter 过滤，透过；顾名思义，<code>filter()</code> 就是过滤元素的方法，返回一个由过滤的元素组成的新数组。用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (val % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p><code>filter()</code> 方法实现的重点就在于理解 return 返回值的真假决定了正在遍历的该元素是否加入新数组。在实现过程中用到了<code>push()</code>方法，此方法会在后面详细介绍。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>, length3 = <span class="keyword">this</span>.length; k &lt; length3; k++)&#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值必定是一个 boolean 类型的</span></span><br><span class="line">            <span class="comment">// 所以可以直接利用 ‘&amp;&amp;’ 来判断当返回值为真的时候，将此元素加入到新数组之中   </span></span><br><span class="line">            fn.call(callback, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>) &amp;&amp; arr.push(<span class="keyword">this</span>[k])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><blockquote><p><code>some()</code> 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p></blockquote><p>some 一些。<code>some()</code> 就是当数组中只要有一个元素符合条件就返回真。用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> flag = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(flag) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>some()</code> 看起来用法和上面的几种差不多，实现起来自然也不会有太大差别，仅仅是多了一层 if 判断，判断是否符合条件，实现如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个不知道该称为什么点的一个点是用来设定当数组中有符合条件的值就是返回真</span></span><br><span class="line">    <span class="comment">// 并同时跳出循环，因为 some 只需要有至少一个满足就可以了</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, length2 = <span class="keyword">this</span>.length; j &lt; length2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="comment">// 这句是为了严谨起见</span></span><br><span class="line">            <span class="comment">// 虽然本身就已经是一个 boolean 值了，但是还是要加 !! 来强转一下</span></span><br><span class="line">            flag = !! fn.call(callback, <span class="keyword">this</span>[j], j, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><blockquote><p><code>every()</code> 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p></blockquote><p>every 所以。说到some，自然离不开every。every就是判断数组中是否所有的元素都满足条件，一旦有一个不满足就返回 false，用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> flag = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">val ,index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(flag) <span class="comment">// false</span></span><br><span class="line"> every() 与 some() 的实现方法相似，只有在真假的判断上有些许区别，不多说，直接看代码</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.myEvery = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// every 的设定就和 some 的完全相反了，some 是要至少一个，</span></span><br><span class="line">    <span class="comment">// every 是要全部满足，所以一旦有一个不满足就跳出循环并返回 false</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, length2 = <span class="keyword">this</span>.length; j &lt; length2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag === <span class="literal">false</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            flag = !!fn.call(callback, <span class="keyword">this</span>[j], j, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><blockquote><p><code>copyWithin()</code> 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</p></blockquote><p>copyWithin 看名字组成，就是数组内部的拷贝，相当于选择其中的一部分元素复制，粘贴到另一部分去，这就是一个用法不同于上面所说的通式的方法了。值得注意的地方是，此方法会改变原数组的元素，但不改变其大小。他的参数列表及用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line">arr.copyWithin(target, start, end)</span><br><span class="line"><span class="comment">// target : 必选，复制到指定位置的索引值</span></span><br><span class="line"><span class="comment">// start : 可选，元素复制的起始索引，缺失则从 0 开始</span></span><br><span class="line"><span class="comment">// end : 可选，元素复制的结束索引，默认值是 arr.length，可取负值，表示倒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>)) <span class="comment">// (7)[1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">1</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// (7)[1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">-2</span>)) <span class="comment">// (7)[1, 2, 3, 3, 3, 2, 2]</span></span><br></pre></td></tr></table></figure><p>第一次看到这个，肯定是看的头大吧， 不过没关系，接下来一步一步剖析整个过程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment">// 在这里我们定义 clArr 为要复制的数组片段</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>)) <span class="comment">// (7)[1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start, end 均取默认值，即 0, 7</span></span><br><span class="line"><span class="comment">// 所以 clArr = arr = [1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">// target = 3, 即从 arr[3] 开始复制,同时还要保证 arr 的大小不发生改变</span></span><br><span class="line"><span class="comment">// 所以复制后数组为 [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 当复制到数组最后一位时直接停止</span></span><br><span class="line"><span class="comment">// 从这里我们可以看出，重点就是找到clArr，只要找到clArr，一切都就迎刃而解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">1</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为copyWithin会改变原数组，所以此时的 arr = [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// start = 1, end = 7</span></span><br><span class="line"><span class="comment">// clArr = [2, 3, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 可以看到 clArr.length = end - start</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// (7)[1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 2, 3, 1, 2]</span></span><br><span class="line"><span class="comment">// start = 2, end = 5</span></span><br><span class="line"><span class="comment">// clArr = [3, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)) <span class="comment">// (7)[1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 3, 2, 3, 2]</span></span><br><span class="line"><span class="comment">// start = 4, end = 8</span></span><br><span class="line"><span class="comment">// clArr = [2, 3, 2]</span></span><br><span class="line"><span class="comment">// 可以看到虽然理论上 clArr.length = 4，但是由于start + clArr.length </span></span><br><span class="line"><span class="comment">// 已经超出原数组的长度，所以 clArr.length 会自动以原数组长度为准</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>, <span class="number">4</span>, <span class="number">-2</span>)) <span class="comment">// (7)[1, 2, 3, 3, 3, 2, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [1, 2, 3, 2, 3, 2, 2]</span></span><br><span class="line"><span class="comment">// 由定义我们知道负值就是倒数，所以我们首先将其转换成整数</span></span><br><span class="line"><span class="comment">// 即 end = arr.length + end = 5</span></span><br><span class="line"><span class="comment">// start = 4, end = 5</span></span><br><span class="line"><span class="comment">// clArr = [3]</span></span><br></pre></td></tr></table></figure><p>看到这里相信你已经看懂了吧，会用了，下一步就是自己实现了，上面的过程基本也介绍了整个过程，就是首先确定 start 与 end ，然后根据二者的值确定要复制的数组片段，再根据 target 确定从何处开始复制。下面就是自己的实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myCopyWithin = <span class="function"><span class="keyword">function</span>(<span class="params">target, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>, len = <span class="keyword">this</span>.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若传入了值就用传入的值，未传入就是用默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> end = end || len</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的实现与上面略有不同，这里首先判断 end 的值</span></span><br><span class="line">    <span class="comment">// 如果大于数组长度就给end 赋值数组长度，小于0，则取正序值</span></span><br><span class="line"></span><br><span class="line">    end = end &gt; len ? len : (end &lt; <span class="number">0</span> ? len + end : end)</span><br><span class="line">    <span class="keyword">var</span> clArr = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 是辅助索引值，len2 是 clArr 的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> index = start, len2 = end - start</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，确定 clArr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len2; i ++) &#123;</span><br><span class="line">        clArr[i] = <span class="keyword">this</span>[index]</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// len3 是遍历复制的结尾索引，加判断是防止 len3 大于原数组长度导致出错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len3 = target + len2</span><br><span class="line">    len3 = len3 &gt; len ? len : len3</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 clArr，将clArr复制到原数组指定位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> j = target; j &lt; len3; j ++) &#123;</span><br><span class="line">        arr[j] = clArr[index]</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><blockquote><p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p></blockquote><p>fill 填充，一个和 <code>copyWithin()</code> 类似的方法，因为他们都是往数组里面填充一个片段，不同的是一个填充的是本来的数组的内容，一个填充的是一个固定值。其参数列表与用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line"></span><br><span class="line">arr.fill(val, start, end)</span><br><span class="line"><span class="comment">// val : 必选，用来填充数组元素的值</span></span><br><span class="line"><span class="comment">// start : 可选，起始索引，默认值为0</span></span><br><span class="line"><span class="comment">// end : 可选，结束索引，默认值为arr.length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// (7) [5, 5, 5, 4, 5, 6, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">3</span>, <span class="number">5</span>)) <span class="comment">// (7) [5, 5, 5, 4, 5, 3, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">6</span>)) <span class="comment">// (7) [6, 6, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure><p>用法看起来也是一目了然，实现起来也是很容易，实现如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">arguments</span>[<span class="number">0</span>], start = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="number">0</span>, end = <span class="built_in">arguments</span>[<span class="number">2</span>] || arr.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i ++) &#123;</span><br><span class="line">        arr[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><blockquote><p><code>concat()</code> 方法用于连接两个或多个数组。</p></blockquote><p>concat 合并多个数组，就是将传入的多个数组按顺序连接在目标数组后面，并且返回新数组 ，参数列表及用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line">arr.concat(arr1, arr2, ...arrN)</span><br><span class="line"><span class="comment">// arr1, arr2, ... arrN : 必选，该参数可以是具体的值，也可以是数组对象。可以是任意多个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> newArr1 = arr1.concat(arr2, arr3)</span><br><span class="line"><span class="keyword">var</span> newArr2 = arr1.concat(arr2)</span><br><span class="line"><span class="keyword">var</span> newArr3 = arr1.concat(num1)</span><br><span class="line"><span class="built_in">console</span>.log(newArr1) <span class="comment">// [1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr2) <span class="comment">// [1, 2, 3, 4, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr3) <span class="comment">// [1, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure><p>此方法就是首先复制一个原数组的副本，然后将要连接的数组（数值）都拼接到后面，实现起来也很简单</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myConcat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 得到形参列表的长度，判断需要几次循环来拼接</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 如果要拼接的是数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> len2 = <span class="built_in">arguments</span>[i].length</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len2; j ++) &#123;</span><br><span class="line">                arr[arr.length] = <span class="built_in">arguments</span>[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数值</span></span><br><span class="line">            arr[arr.length] = <span class="built_in">arguments</span>[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arrays </tag>
            
            <tag> es6 </tag>
            
            <tag> 原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]css加载会造成阻塞吗？</title>
      <link href="/blog/2018/09/05/%E8%BD%AC-css%E5%8A%A0%E8%BD%BD%E4%BC%9A%E9%80%A0%E6%88%90%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F/"/>
      <url>/blog/2018/09/05/%E8%BD%AC-css%E5%8A%A0%E8%BD%BD%E4%BC%9A%E9%80%A0%E6%88%90%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：陈纪庚<br>链接：<a href="https://juejin.im/post/5b88ddca6fb9a019c7717096" target="_blank" rel="noopener">https://juejin.im/post/5b88ddca6fb9a019c7717096</a><br>来源：掘金</p></blockquote><p>之前面试今日头条的时候，今日头条面试官问我，js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？所以，接下来我就来对css加载对DOM树的解析和渲染做一个测试。</p><p>为了完成本次测试，先来科普一下，如何利用chrome来设置下载速度</p><ul><li>打开chrome控制台(按下F12),可以看到下图，重点在我画红圈的地方</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjJlMDRiZGI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt></p><ul><li>点击我画红圈的地方(No throttling),会看到下图,我们选择GPRS这个选项</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjJkZDY5MWM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt></p><p>这样，我们对资源的下载速度上限就会被限制成20kb/s，好，那接下来就进入我们的正题</p><h2 id="css加载会阻塞DOM树的解析渲染吗？"><a href="#css加载会阻塞DOM树的解析渲染吗？" class="headerlink" title="css加载会阻塞DOM树的解析渲染吗？"></a>css加载会阻塞DOM树的解析渲染吗？</h2><p>用代码说话：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      h1 &#123;</span><br><span class="line">        color: red !important</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelectorAll(<span class="string">'h1'</span>))</span></span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(h, 0)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>假设</strong>： css加载会阻塞DOM树解析和渲染</p><p><strong>假设结果</strong>: 在bootstrap.css还没加载完之前，下面的内容不会被解析渲染，那么我们一开始看到的应该是白屏，h1不会显示出来。并且此时console.log的结果应该是一个空数组。</p><p><strong>实际结果</strong>:如下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjMyMWNiMGY_aW1hZ2VzbGlt" alt></p><p>css会阻塞DOM树解析？</p><p>由上图我们可以看到，当css还没加载完成的时候，h1并没有显示，但是此时控制台输出如下</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjJmMjQzOWM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt></p><p>可以得知，此时DOM树至少已经解析完成到了h1那里，而此时css还没加载完成，也就说明，css并不会阻塞DOM树的解析。</p><p>css加载会阻塞DOM树渲染？</p><p>由上图，我们也可以看到，当css还没加载出来的时候，页面显示白屏，直到css加载完成之后，红色字体才显示出来，也就是说，下面的内容虽然解析了，但是并没有被渲染出来。所以，css加载会阻塞DOM树渲染。</p><p>个人对这种机制的评价</p><p>其实我觉得，这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以我干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。</p><h2 id="css加载会阻塞js运行吗？"><a href="#css加载会阻塞js运行吗？" class="headerlink" title="css加载会阻塞js运行吗？"></a>css加载会阻塞js运行吗？</h2><p>​<br>由上面的推论，我们可以得出，css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染。那么，css加载会不会阻塞js执行呢?</p><p>同样，通过代码来验证.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'before css'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'after css'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'经过了'</span> + (endDate -startDate) + <span class="string">'ms'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>假设</strong>: css加载会阻塞后面的js运行</p><p><strong>预期结果</strong>: 在link后面的js代码，应该要在css加载完成后才会运行</p><p><strong>实际结果</strong>:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjMwNWZmMGY_aW1hZ2VzbGlt" alt></p><p>由上图我们可以看出，位于css加载语句前的那个js代码先执行了，但是位于css加载语句后面的代码迟迟没有执行，直到css加载完成后，它才执行。这也就说明了，css加载会阻塞后面的js语句的执行。详细结果看下图(css加载用了5600+ms):</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzMxLzE2NThlYTI1MjJmZjM2M2Q_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由上所述，我们可以得出以下结论:</p><ol><li>css加载不会阻塞DOM树的解析</li><li>css加载会阻塞DOM树的渲染</li><li>css加载会阻塞后面js语句的执行</li></ol><p>因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:</p><ol><li>使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)</li><li>对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)</li><li>合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)</li><li>减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)</li></ol><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>那么为什么会出现上面的现象呢？我们从浏览器的渲染过程来解析下。</p><p>不用浏览器使用的内核不同，所以他们的渲染过程也是不一样的。目前主要有两个：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzMvMTY1OWRiMTRlNzczZjljYz9pbWFnZVZpZXcyLzAvdy8xMjgwL2gvOTYwL2Zvcm1hdC93ZWJwL2lnbm9yZS1lcnJvci8x" alt="webkit渲染过程"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzMvMTY1OWRiMTRlN2RmOGE4Zj9pbWFnZVZpZXcyLzAvdy8xMjgwL2gvOTYwL2Zvcm1hdC93ZWJwL2lnbm9yZS1lcnJvci8x" alt="Gecko渲染过程"></p><p>从上面两个流程图我们可以看出来，浏览器渲染的流程如下：</p><ol><li>HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree</li><li>将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)</li><li>根据Render Tree渲染绘制，将像素渲染到屏幕上。</li></ol><p>从流程我们可以看出来</p><ol><li>DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。</li><li>然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。</li><li>由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。</li></ol><p>以上，就是所有内容。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]HTTP - - HTTP协议简要分析（1）</title>
      <link href="/blog/2018/09/02/%E5%8E%9F-HTTP-HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89/"/>
      <url>/blog/2018/09/02/%E5%8E%9F-HTTP-HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>HTTP（Hypertext Transfer Protocol）协议是w3c于1990年颁布的一个属于应用层的面向对象的协议，主要适用于分布式超媒体信息系统。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是指客户端程序与web服务器的请求、响应的交互过程中所必须要遵守的规则和数据格式，即通信规范。</p><p>在此，客户端程序是指web浏览器、网络爬虫或者其他的应用程序；web服务器是指提供<a href="https://baike.baidu.com/item/WWW%E6%9C%8D%E5%8A%A1/10185376?fr=aladdin" target="_blank" rel="noopener">www类型服务</a>的主机。HTTP服务是目前在因特网上使用最广泛的应用层协议。它主要用于传输采用HTML实现的页面文件，而客户端浏览器与web服务器之间通过这个协议，使得网友可以拿鼠标达到全世界（当然，首先要翻墙才可以到一些到不了的地方），并通过特定的程序与web服务器进行人机交互，也就是请求响应。</p><p>tip：基于HTTP协议的客户端程序也被称为用户代理（User Agent），在用户代理和目标服务器之间存在多个不同形式的中间层（如代理、网关等）。浏览器也并不是基于HTTP协议的唯一客户端程序，在应用中还可以有搜索引擎、手机、掌上电脑、机顶盒等设备和程序，它们也通过HTTP协议与对应的web服务器之间进行通信和数据交换。</p><h2 id="HTTP协议主要的协议特性"><a href="#HTTP协议主要的协议特性" class="headerlink" title="HTTP协议主要的协议特性"></a>HTTP协议主要的协议特性</h2><h3 id="HTTP协议是建立在TCP-IP上层的应用层协议"><a href="#HTTP协议是建立在TCP-IP上层的应用层协议" class="headerlink" title="HTTP协议是建立在TCP/IP上层的应用层协议"></a>HTTP协议是建立在TCP/IP上层的应用层协议</h3><p>HTTP协议不仅保证客户端程序正确和快速地传输超文本文件信息，而且是一个基于请求/响应模式的无状态的协议。HTTP之所以简单和能够快速响应，主要是由于客户端程序向服务器程序发送HTTP请求时，只需要传送请求的方式和目标资源的路径和文件名，并且请求的方式可以为get，post和head等多种形式。</p><h3 id="HTTP协议是一个基于请求-响应模式的无状态的协议"><a href="#HTTP协议是一个基于请求-响应模式的无状态的协议" class="headerlink" title="HTTP协议是一个基于请求/响应模式的无状态的协议"></a>HTTP协议是一个基于请求/响应模式的无状态的协议</h3><p>协议的状态是指在下一次传输时可以保留本次传输信息的能力，而无状态也就是之HTTP协议对于事务处理没有记忆的能力，如果用户代理在后续处理中需要应用前次请求的信息，则必须重新请求。</p><p>基于请求/响应也就意味着客户端每次更新信息时都要重新向web服务器发出请求，HTTP协议具有无状态的特性，也就意味着客户端浏览器获取了所请求的目标资源后，将于web服务器断开网络连接而空出不再需要的网络连接资源。</p><p>因此，无状态的特性可<strong>提升分布式应用系统的性能，也允许在同一个页面中包括分布在相距很远的不同服务器中的其他信息。</strong></p><p>但是无状态的特性将会<strong>导致每次连接传送的数据量增大，同时也为实现会话跟踪带来一定的技术实现上的复杂性。</strong></p><h3 id="无永久连接"><a href="#无永久连接" class="headerlink" title="无永久连接"></a>无永久连接</h3><p>HTTP协议所具有的无永久连接的含义是指限制每次连接只处理一个请求，并且服务器处理完客户端程序的请求并受到客户端程序的应答信息后立即断开与客户端程序之间的网络连接，从而提高传输性能和减少传输时间。</p><h2 id="HTTP服务器默认的TCP连接的端口为80"><a href="#HTTP服务器默认的TCP连接的端口为80" class="headerlink" title="HTTP服务器默认的TCP连接的端口为80"></a>HTTP服务器默认的TCP连接的端口为80</h2><p>每当客户端程序向web服务器发送一个HTTP请求后，也就建立出一个到web服务器指定端口的TCP连接。这个指定的端口就是80；如果HTTP服务器的端口号不是80，则在访问该web服务器时必须给定具体的端口号，比如tomcat服务器默认的端口号为8080。</p><h2 id="HTTP协议中的请求头和响应信息"><a href="#HTTP协议中的请求头和响应信息" class="headerlink" title="HTTP协议中的请求头和响应信息"></a>HTTP协议中的请求头和响应信息</h2><h3 id="HTTP消息的基本组成"><a href="#HTTP消息的基本组成" class="headerlink" title="HTTP消息的基本组成"></a>HTTP消息的基本组成</h3><p>HTTP消息包括客户端程序向web服务器发送的请求消息和web服务器端程序向客户端程序返回的响应消息，而且他们都是由一个请求起始行、一个或者多个头域、一个标识头域结束的空行和可选的消息体组成。</p><h3 id="HTTP协议中头域的基本组成"><a href="#HTTP协议中头域的基本组成" class="headerlink" title="HTTP协议中头域的基本组成"></a>HTTP协议中头域的基本组成</h3><p>HTTP协议的头域主要包括通用头、请求头、响应头和实体头4个部分。每个头域由域名、冒号和域值三部分组成。</p><p><strong>通用头域</strong>包含请求和响应消息都支持的头域，提供了与报文相关的最基本的信息，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</p><p><strong>请求消息</strong>的第一行为下面的格式： </p><p>MethodSPRequest-URISPHTTP-VersionCRLF</p><p>Method 表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、 TRACE。</p><p><strong>响应消息</strong>的第一行为下面的格式： </p><p>HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF </p><p>HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。Status- Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。</p><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。</p><p>具体的header详解可以查看这篇<a href="https://my.oschina.net/gaomq/blog/1795002" target="_blank" rel="noopener">博文</a>。</p><h3 id="通用头（General-Header）"><a href="#通用头（General-Header）" class="headerlink" title="通用头（General Header）"></a>通用头（General Header）</h3><p>这里以我的CSDN博客首页的请求为例。</p><p><img src="https://img-blog.csdn.net/20180911223229752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>                  </p><p>其中，</p><p>Request URL : 请求的URL</p><p>Request Method : 请求的方式</p><p>Status Code : 响应输出的状态码</p><p>Remote Address : 远程地址，包括 IP地址：端口号</p><p>Referrer Policy : 来源协议，用来规定是否发送referrer消息，此处表示仅当发生协议降级（如 HTTPS 页面引入 HTTP 资源，从 HTTPS 页面跳到 HTTP 等）时不发送 Referrer 信息。这个规则是现在大部分浏览器默认所采用的。对于此协议的几种值可以查看此<a href="https://blog.csdn.net/lancelot_lewis/article/details/81133371" target="_blank" rel="noopener">博客</a>。</p><h3 id="服务端响应消息（Response-Headers）"><a href="#服务端响应消息（Response-Headers）" class="headerlink" title="服务端响应消息（Response Headers）"></a>服务端响应消息（Response Headers）</h3><p>​​​<br>​​​​同样以我的CSDN博客首页的请求为例。</p><p><img src="https://img-blog.csdn.net/20180911224534883?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>其中，</p><p>Connection : 是否开启HTTP持久连接，此处表示开启，HTTP 1.1默认值；HTTP 1.0默认值是 close,表示关闭HTTP持久连接。</p><p>Content-Encoding : web服务器支持的返回内容压缩编码类型。</p><p>Content-Type : 相应内容的类型，更多内容可以查询此<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">常用对照表</a>。</p><p>Date : 表示发起请求的世界时。</p><p>Keep-Alive : 表示HTTP持久连接在请求响应后延迟多长时间关闭。</p><p>Server : web服务器软件的名称。</p><p>Strict-Transport-Security : 表示这个网站禁止使用HTTP方式加载，浏览器应该自动把所有尝试使用HTTP的请求自动替换为HTTPS请求， max-age 表示缓存秒数。</p><p>Transfer-Encoding : 文件传输编码。</p><p>Vary : 告诉下游代理是使用缓存响应还是从原始服务器请求。</p><h3 id="客户端发送消息（Request-Headers）"><a href="#客户端发送消息（Request-Headers）" class="headerlink" title="客户端发送消息（Request Headers）"></a>客户端发送消息（Request Headers）</h3><p>​​​<br>​​​​同样以我的CSDN博客首页的请求为例。</p><p><img src="https://img-blog.csdn.net/20180911230606720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>Accept : 指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序</p><p>Accept-Encoding : 指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。</p><p>Accept-Language : 指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。</p><p>Cache-Control : 告诉所有的缓存机制是否可以缓存及哪种类型。</p><p>Cookie : HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p><p>Host : 请求的web服务器域名地址。</p><p>Referer : 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p><p>Upgrade-Insecure-Requests : 对应服务器的响应头的 Content-Security-Policy: upgrade-insecure-requests，而在浏览器的请求头出现的 Upgrade-Insecure-Requests:1 则是告诉服务器，自己支持这种操作，也就是我能读懂你服务器发过来的上面这条信息，并且在以后发请求的时候不用http而用https。</p><p>User-Agent : HTTP客户端运行的浏览器类型的详细信息。</p><h3 id="主要的响应输出的状态码及其功能说明"><a href="#主要的响应输出的状态码及其功能说明" class="headerlink" title="主要的响应输出的状态码及其功能说明"></a>主要的响应输出的状态码及其功能说明</h3><p>​​​​<br>​​​关于状态码可以直接查看我之前写的博客：常见的十个HTTP协议状态码。</p><p>（未完待续）</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]TCP协议的三次握手与四次挥手</title>
      <link href="/blog/2018/08/30/%E5%8E%9F-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/blog/2018/08/30/%E5%8E%9F-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。</p><p>现在要讨论的就是TCP协议建立连接和连接终止的过程。</p><h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><p>连接建立使用的是三次握手协议。</p><p>三次握手的目的是为了确认两台主机均具备收和发的能力。之所以是三次我想继续往下看就会了解的。</p><p>三次握手的过程：</p><ol><li>A主机向B主机发起连接请求，让B主机知道A主机可以发送消息；</li><li>B主机向A主机回复消息，让A主机知道B主机能接收到，也能发送；</li><li>A主机向B主机回复消息，让B主机知道A主机可接收消息。</li></ol><p>当然真的过程必定带着消息的传送，上面只是简单的概述一下整个过程，下面通过一幅图来了解这个过程。</p><p>在此之前需要了解其中的一些名词的意义：</p><ul><li>SYN : 建立连接；</li><li>seq ：序列号，随机生成；</li><li>ack ：确认消息，取值为 seq + 1;</li></ul><p><img src="https://img-blog.csdn.net/20180830160019297?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><ol><li>客户端发送SYN（SEQ=n）报文给服务器端，进入SYN_SEND状态。</li><li>服务器端收到SYN报文，回应一个SYN （SEQ=u）ACK(ACK=n+1）报文，进入SYN_RECV状态。</li><li>客户端收到服务器端的SYN报文，回应一个ACK(ACK=u+1）报文，进入Established状态。</li></ol><p>至此，连接就已经建立完成了，可以开始传送数据了。</p><p>从上面的过程我们可以知道必须要用三次才可以完全了解到双方都是可以发送并接收数据的。</p><h2 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h2><p>连接终止使用的是四次挥手协议。</p><p>四次挥手的目的是为了确认数据完全接受，并且关闭连接。</p><p>四次挥手的过程：</p><ol><li>A主机告诉B主机数据发送完了；</li><li>B主机告诉A主机知道A主机把数据发完了；</li><li>B主机告诉A主机数据接收完了；</li><li>A主机告诉B主机知道B主机把数据接收完了。</li></ol><p>同样，我们通过一个图来了解这个过程。</p><ul><li>FIN ： 终止，结束，类似于SYN</li></ul><p><img src="https://img-blog.csdn.net/20180830161844108?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><ol><li>某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕；</li><li>接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认；</li><li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN；</li><li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li></ol><p>至此，连接也就终止了。</p><p>而需要四次是因为：在A主机发送完数据后，可能因为一些延迟，B主机并不能立刻完全接收数据。所以需要先告诉A主机，我知道你发完了，但是我还没有接受完数据，然后等数据完全接收完了之后再告诉A主机我接收完了。这就需要四次才可以完成整个过程。</p><p>以上就是全部内容。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]常见的十个HTTP协议状态码</title>
      <link href="/blog/2018/08/29/%E5%8E%9F-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%81%E4%B8%AAHTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/blog/2018/08/29/%E5%8E%9F-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%81%E4%B8%AAHTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>首先看一下百科对HTTP状态码的解释。 </p><blockquote><p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p></blockquote><p>通俗的讲就是当客户端给服务器端发起请求时，无论成功与否，服务器端总是会返回一个3位数的数字代码， 代表请求的结果，这三位数就是<strong>HTTP状态码</strong>，如下图所示。</p><p><img src="https://img-blog.csdn.net/20180829150433415?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>其中的 <strong>Status Code</strong> 就是HTTP状态码。</p><p>HTTP状态码大致分为5类：</p><p>1xx : 消息，这一类型的状态码，代表请求已被接受，需要继续处理。但是一般服务器禁止向客户端发送此类状态码；</p><p>2xx : 成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受；</p><p>3xx : 重定向，这类状态码代表需要客户端采取进一步的操作才能完成请求；</p><p>4xx : 请求错误，这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理；</p><p>5xx : 服务器错误，这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</p><hr><p>在这里，只介绍常见的十个HTTP状态码，也是必须要记住的十个。</p><p>200 : 成功，表示访问成功，正常状态。</p><p>301 : 永久移动，表示本网页已经永久性的移动到一个新的地址，在客户端自动将请求地址改为服务器返回的新地址。</p><p>302 : 临时重定向，表示网页暂时性的转移到一的新的地址，客户端在以后可以继续向本地址发起请求。</p><p>303 : 表示必须临时重定向，并且必须使用GET方式请求。</p><p>304 : 重定向至浏览器本身，当浏览器多次发起同一请求，且内容未更改时，使用浏览器缓存，这样可以减少网络开销。</p><p>401 : 表示协议格式出错，可能是此IP地址被禁止访问该资源，与403类似。</p><p>403 : 表示没有权限，服务器拒绝访问请求。</p><p>404 : 这是最常见的错误，表示找不到系统资源，但是只是暂时性地。</p><p>500 : 表示服务器程序错误，一个通用的错误信息。</p><p>503 : 表示服务器繁忙，或者服务器负载，通常这只是一个临时状态。</p><p>以上就是全部内容，首先就是不全面，可能也会因为自己理解的不深会有部分错误，望海涵。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]DNS域名解析过程</title>
      <link href="/blog/2018/08/28/%E5%8E%9F-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>/blog/2018/08/28/%E5%8E%9F-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>当我们在浏览器中输入一个域名（eg: <a href="http://www.baidu.com）时，浏览器会显示域名所对应的网站的内容，在输入域名到浏览器显示内容这个过程中就发生了域名解析，即将域名解析成IP的过程。" target="_blank" rel="noopener">www.baidu.com）时，浏览器会显示域名所对应的网站的内容，在输入域名到浏览器显示内容这个过程中就发生了域名解析，即将域名解析成IP的过程。</a></p><p>首先解释一下域名解析的概念。（来自<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/574285" target="_blank" rel="noopener">百度百科</a>）</p><blockquote><p>域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p></blockquote><p>按个人理解，DNS域名解析大概分为5个步骤，以下。</p><ul><li><p>我们在浏览器地址栏输入一个域名，浏览器得到域名，首先在浏览器的本地缓存中查看，有没有与此域名对应的IP；</p></li><li><p>如果没有查找到就会继续查看计算机本地的HOST指向，有没有相关的记录；</p></li></ul><blockquote><p>HOST：计算机本地的一个文件，记录着域名与IP的映射关系。</p></blockquote><ul><li><p>如果仍没有查找到就会查看本地的DNS解析服务器（ LDNS ），这些服务器通常在每个城市都有；</p></li><li><p>如果还是没有查找到就会查看gTLD Server（通用顶级域）；</p></li></ul><blockquote><p>每个顶级域名都有一个记录着所以注册过相应域名的记录，如.com域名的服务器记录着全部注册过的.com域名。</p></blockquote><p>LDNS会访问gTLD其中的一台机器，当这台机器接收到这个域名后，会告诉LDNS应该去访问哪台机器，然后LDNS再去相应的机器去询问这个域名对应的IP； </p><ul><li>LDNS从gTLD获取到IP后会把这个信息返回给发出请求的计算机，LDNS会在本地进行缓存，浏览器也会对这个域名和IP进行缓存，保证下次访问这个域名时可以很快的响应。</li></ul><p>至此，整个过程就结束了，其中的专业名词均可在百度查找到相关解释。</p><p>（灵感来自微信公众号：Duing）</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 域名解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]js网络请求性能优化之防抖与节流</title>
      <link href="/blog/2018/06/17/%E5%8E%9F-js%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/blog/2018/06/17/%E5%8E%9F-js%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>防抖(debounce)</strong>：在函数需要频繁触发时，只有当有足够空闲的时间时，才执行一次。就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。</p><p><strong>节流(thorttle)</strong>：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。</p><p><strong>区别</strong>：在发生持续触发事件时，防抖设置事件延迟并在空闲时间去触发事件，而节流则是隔一定的时间触发一次。</p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>函数防抖运用的实际场景有：实时搜索，拖拽，登录用户名密码格式验证等等。</p><p>实现函数防抖的关键就是对setTimeout()这个方法的运用。先以实时搜索为例分析一下。</p><p>首先我们要写一个监听函数用来监听搜索框的value的变化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oInp;<span class="comment">// 假设在此取得输入框</span></span><br><span class="line">oInp.oninput = ajax;</span><br><span class="line"><span class="comment">// 模拟ajax请求后台数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">// 搜索框value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完之后我们会发现每当我们输入一个单词，即每当搜索框内容发生变化时都会触发我们的监听函数来请求后台数据，如此频繁的请求肯定不是我们想要的，所以我们就需要稍加处理一下，使其不再一改变就触发，而是当我们输完之后再触发发送请求。针对这种需求我们可以使用防抖来实现。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oInp;<span class="comment">// 假设在此取得输入框</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 定义一个全局定时器</span></span><br><span class="line">oInp.oninput = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模拟ajax请求后台数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">// 搜索框value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个整体的实现思想就是，当搜索框内容发生改变时，就会触发一个定时器。但是当搜索框内容再次发生改变时，我们先清除上一个定时器，再重新创建一个定时器。这样，只有当我们结束输入，搜索框内容在一定时间内不再发生改变时才会发送请求。</p><p>但是上面的代码块还有两个问题，一个就是this的指向，setTimeout()形成了一个闭包，当执行的时候，ajax()方法中的this实际指向window，所以我们还需要进行以下优化，改变this指向。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oInp;<span class="comment">// 假设在此取得输入框</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 定义一个全局定时器</span></span><br><span class="line">oInp.oninput = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>; </span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax().apply(_this); <span class="comment">// 绑定this</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模拟ajax请求后台数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">// 搜索框value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题就是e – 事件对象，在上面一系列的方法调用之中，e已经被丢了，变成了undefined,所以我们还需要进行以下优化，将事件对象重新找回来。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oInp;<span class="comment">// 假设在此取得输入框</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 定义一个全局定时器</span></span><br><span class="line">oInp.oninput = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        _arg = <span class="built_in">arguments</span>; <span class="comment">// e</span></span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ajax().apply(_this, _arg); <span class="comment">// 绑定this, 传入e</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模拟ajax请求后台数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">// 搜索框value值</span></span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// 事件对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就基本实现了函数防抖。为了实现通用性，在这里将防抖封装成一个方法，方便之后重复使用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">handle, delay</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> _this = <span class="keyword">this</span>,</span><br><span class="line">    _arg = <span class="built_in">arguments</span>;</span><br><span class="line">clearTimeout(timer);</span><br><span class="line">timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">handle.apply(_this, _arg);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// 其中 handle 为需要进行防抖操作的函数，delay 为延迟时间</span></span><br></pre></td></tr></table></figure><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>函数节流运用的实际场景有：窗口调整，页面滚动，抢购疯狂点击等等。</p><p>在这里以疯狂点击为例进行分析。</p><p>首先写一个简单的页面，当点击按钮时，数字不断增大，模拟抢购按钮。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>),</span></span><br><span class="line"><span class="javascript">oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">oDiv.innerHTML = <span class="built_in">parseInt</span>(oDiv.innerHTML) + <span class="number">1</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们肯定不希望用户去疯狂点击导致数字不断增加，甚至是使用恶意脚本去实现疯狂点击按钮</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">    oBtn.onclick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以就要引入一个新思想，那就是在一秒钟之内无论用户点多少次，都只算他点了一次，这就是节流的核心思想。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">handle, wait</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> lasttime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> nowtime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">if</span>(nowtime - lasttime &gt; wait) &#123;</span><br><span class="line">handle.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">lasttime = nowtime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">oDiv.innerHTML = <span class="built_in">parseInt</span>(oDiv.innerHTML) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">oBtn.onclick = throttle(buy, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>现在分析一下throttle方法。</p><p>参数中 handle 为需要进行节流的方法，wait为等待时间。</p><p>因为我们需要实现在一定的等待时间wait内不能执行buy()方法，所以首先需要两个时间戳，一个记录第一次点击的时间lasttime，一个记录当前的时间nowtime，只有当 nowtime 与 lasttime 的时间差大于wait时，才会再次触发buy()，同时改变lasttime为新时间戳。</p><p>放在throttle()中就是首先记录初始时间为0，当第一次点击时，获得现在时间为nowtime，时间差大于wait，执行buy(),然后本次点击的时间就成了一个新的时间点，下次点击就需要和这次点击的时间进行判断，所以设置当前时间为初始时间，然后下次点击时继续判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖和节流虽然实现起来不难，但在实际开发中还是很常用的，因为它们可以极大的优化网络请求性能，提高用户体验。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 防抖 </tag>
            
            <tag> 节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]js实现无缝轮播图插件</title>
      <link href="/blog/2018/06/05/%E5%8E%9F-js%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6/"/>
      <url>/blog/2018/06/05/%E5%8E%9F-js%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>看了几个网上的轮播图例子，然后理解了其中的原理，自己写了一个插件，实现了无缝轮播。</p><p>先来说一下实现原理：</p><ul><li><p>首先要明确做一个插件的基本要求，我认为至少需要满足以下几点要求：具备默认设置参数的功能；插件自身的作用域与用户的作用域相互独立；用户可以自己调节参数达到自己想要的效果。</p></li><li><p>然后看一下轮播图的需求。</p></li></ul><p>我们需要实现下图所示的轮播图，它具有以下功能：</p><p>A. 每隔一定的时间图片自动播放；</p><p>B. 点击对应的圆点跳转到对应的图片；</p><p>C. 点击两边的按钮可以播放上一张图或者下一张图；</p><p>D. 当鼠标悬停在图片上方时暂停播放。</p><p><img src="https://img-blog.csdn.net/20180605183306427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果图"></p><ul><li>然后需要考虑轮播图从何下手。</li></ul><p>首先要实现功能A，这里已默认5张图为例，真实的图片肯定不是五张，这个想必大家都已知道，如果后台仍然使用5张图就不可能实现真正的无缝了。而在此我们不仅要实现自动播放，还要实现按钮功能，所以我们还需有第一张图跳转到最后一张图的功能，所以需要7张图片。然后要实现图片轮播的效果就要让图片在一条线上，使用float可以轻松实现（这里要注意，我们整个框架是：div&gt;ul&gt;li&gt;img，div和li，img肯定是固定宽高，而ul就需要内容撑开宽度了，我们不知道图片的数量，如果固定了宽度，就会造成图片不再一条线上）；接着要让他动起来，我们首先想到的是通过改变ul的left值来改变图片的显示，当然这里我也用的是left，但是如果使用left会降低效率，不如用translateX()更加高效。不过那个还没有做出来，等后面做出来了再修改一下。自动播放就是把这个功能放在一个setInterval()里面就可以了。</p><p>其次要实现功能B，看到这个功能我们想到的是如何将圆点与图片连接起来，还有处理圆点的点击事件。针对前一个问题，我的解决方法是给span(圆点)添加data-index属性，并对其编号，这样我们通过点击获得的编号就可以知道要跳转到哪张图片了。针对后一个问题，我想到了可以给span外面包一层div，然后给div添加点击事件，通过事件冒泡得到事件源（即target属性），然后获取事件源的data-index即可。</p><p>然后是功能C，这个就比较简单了，右边的按钮就是触发一次播放的动画，左边的按钮就是反方向触发一次放的动画。</p><p>最后是功能D，可以通过hover()清除setInterval()，移除后重新创建一个。</p><p>考虑到插件的兼容性，即因为图片数量是未知的，所以小圆点span标签需要动态创建，同时对两个按钮也动态创建。</p><ul><li>了解了所有需求以及实现方法就要开始正式写代码了。</li></ul><p>先附上结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"carousel-inner"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"carousel-item"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/-jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先我们扩展一个封装函数sowingMap()，并在函数内通过jq的extend方法处理参数，如果用户没有传进来参数就使用默认参数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.fn.sowingMap = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = $.extend(&#123;</span><br><span class="line">            count : <span class="number">2</span>,<span class="comment">//图片数量</span></span><br><span class="line">            time : <span class="number">3000</span> <span class="comment">//自动播放时间间隔</span></span><br><span class="line">        &#125;, option);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><p>为了结构看起来清楚明了，我另外创建了一个“构造函数”Init()，并在此函数的原型链上编程。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Init</span>(<span class="params">ele, args</span>) </span>&#123; <span class="comment">//ele:父级节点，args:参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (args.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.init(ele, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'请输入正确的图片数量'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Init.prototype = &#123;&#125;</span><br></pre></td></tr></table></figure><p>在原型链上，首先写一个入口函数init()处理传进来的参数，并初始化后面需要用到的dom节点，调用主要函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init : <span class="function"><span class="keyword">function</span>(<span class="params">ele, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ele = ele,</span><br><span class="line">    <span class="keyword">this</span>.count = args.count,</span><br><span class="line">    <span class="keyword">this</span>.time = args.time,</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">this</span>.oUl = <span class="keyword">this</span>.ele.find(<span class="string">'.carousel-inner'</span>),</span><br><span class="line">    <span class="keyword">this</span>.oLi = <span class="keyword">this</span>.oUl.find(<span class="string">'.carousel-item'</span>),</span><br><span class="line">    <span class="keyword">this</span>.createSpan(), <span class="comment">//生成圆点以及左右按钮</span></span><br><span class="line">    <span class="keyword">this</span>.handleUl(), <span class="comment">//处理图片</span></span><br><span class="line">    <span class="keyword">this</span>.automatic(), <span class="comment">//自动播放</span></span><br><span class="line">    <span class="keyword">this</span>.eventBind()  <span class="comment">//点击事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个handleUl()方法，用来处理图片，即复制最后一张图片并将其接在第一位，复制第一张图片并将其接在最后一位。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleUl : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> last = <span class="keyword">this</span>.oLi.eq(<span class="number">0</span>).clone(),</span><br><span class="line">        first = <span class="keyword">this</span>.oLi.eq(<span class="keyword">this</span>.count - <span class="number">1</span>).clone(),</span><br><span class="line">        width = <span class="keyword">this</span>.ele.width(),</span><br><span class="line">        left = - (<span class="keyword">this</span>.index + <span class="number">1</span>) * <span class="keyword">this</span>.ele.width(); <span class="comment">//确认第一张图片的位置</span></span><br><span class="line">    <span class="keyword">this</span>.oUl.prepend(first).append(last).css(<span class="string">'left'</span>, left + <span class="string">'px'</span>);</span><br><span class="line">    <span class="keyword">this</span>.oUl.width((<span class="keyword">this</span>.count + <span class="number">2</span> ) * width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写一个createSpan()方法，用来动态创建span标签以及btn按钮。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createSpan : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'&lt;div class="carousel-indicators"&gt;'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count; i ++) &#123;</span><br><span class="line">        str += <span class="string">'&lt;span data-index="'</span> + i + <span class="string">'"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str += <span class="string">'&lt;/div&gt;&lt;span class="carousel-btn carousel-prev-btn"&gt;&lt;/span&gt;'</span> </span><br><span class="line">    + <span class="string">'&lt;span class="carousel-btn carousel-next-btn"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">    <span class="keyword">this</span>.ele.append(str);</span><br><span class="line">    <span class="keyword">this</span>.ele.find(<span class="string">'.carousel-indicators span'</span>).eq(<span class="keyword">this</span>.index).addClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是处理动画了，首先写一个ianimate()方法，用来处理动画，在这里面要注意，当图片动画结束后我们要处理圆点的效果以及图片的衔接问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ianimate : <span class="function"><span class="keyword">function</span>(<span class="params">ileft</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tleft = <span class="keyword">this</span>.oUl.position().left,</span><br><span class="line">    i = <span class="keyword">this</span>;</span><br><span class="line">        i.oUl.animate(&#123;</span><br><span class="line">            left : ileft + tleft</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> left = i.oUl.position().left,</span><br><span class="line">                width = i.ele.width();</span><br><span class="line">            ileft &gt; <span class="number">0</span> &amp;&amp; left &gt; -width &amp;&amp; i.oUl.css(<span class="string">'left'</span>, - i.count * width); <span class="comment">//判断是否是第0张（即最前面的最后一张）</span></span><br><span class="line">            ileft &lt; <span class="number">0</span> &amp;&amp; left &lt;  - i.count * width &amp;&amp; i.oUl.css(<span class="string">'left'</span>, -width); <span class="comment">//判断是否是最后一张（即最后面的第一张）</span></span><br><span class="line">            i.index = <span class="built_in">parseInt</span>(- left / width) - <span class="number">1</span>;</span><br><span class="line">            i.index = i.index &gt; i.count - <span class="number">1</span> ? <span class="number">0</span> : i.index;</span><br><span class="line">            i.index = i.index &lt; <span class="number">0</span> ? i.count - <span class="number">1</span> : i.index;</span><br><span class="line">            i.renBtns(); <span class="comment">// 给圆点添加特效</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是renBtns()方法，通过给对应的span添加类名来改变样式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renBtns : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ele.find(<span class="string">'.carousel-indicators span'</span>).removeClass(<span class="string">"active"</span>).eq(<span class="keyword">this</span>.index).addClass(<span class="string">'active'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当动画做好后就要去触发动画了，写一个eventBind()方法来放置圆点以及按钮的点击事件还有外层div的hover事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventBind : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">this</span>,</span><br><span class="line">        prev = <span class="keyword">this</span>.ele.find(<span class="string">".carousel-prev-btn"</span>),</span><br><span class="line">        next = <span class="keyword">this</span>.ele.find(<span class="string">".carousel-next-btn"</span>),</span><br><span class="line">        span = <span class="keyword">this</span>.ele.find(<span class="string">".carousel-indicators"</span>),</span><br><span class="line">        ileft = <span class="keyword">this</span>.ele.width();</span><br><span class="line">    prev.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        i.ianimate(ileft);</span><br><span class="line">    &#125;);</span><br><span class="line">    next.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        i.ianimate(-ileft);</span><br><span class="line">    &#125;);</span><br><span class="line">    span.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">        i.ianimate(- ($(target).data(<span class="string">'index'</span>) - i.index) * ileft);</span><br><span class="line">    &#125;);</span><br><span class="line">    i.ele.hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearInterval(i.timer);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        i.automatic();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要处理外层div的hover事件，自然先要写一个方法automatic()用来触发动画自动播放。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">automatic : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="keyword">this</span>.ele.find(<span class="string">".carousel-next-btn"</span>);</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        next.trigger(<span class="string">'click'</span>)</span><br><span class="line">    &#125;, <span class="keyword">this</span>.time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证动画的流畅程度，在动画开始之前需要加一个判断，判断现在是否有正在进行的动画，刚开始我想到了加锁，但发现不是很好操作，于是查了一下文档，发现可以通过jq内置的is()方法来判断当前是否有动画在进行，如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!i.oUl.is(<span class="string">":animated"</span>)) &#123;</span><br><span class="line">    <span class="comment">//动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要引用此插件并调用就可以了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.box'</span>).sowingMap(&#123;</span><br><span class="line">    count : <span class="number">7</span>,</span><br><span class="line">    time : <span class="number">3000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此，主要功能以及编写完毕，只需要在处理一下细节，一个轮播图插件就做好了。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 轮播图 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]简单CSS3+JQ实现图片的3D翻转</title>
      <link href="/blog/2018/05/10/%E5%8E%9F-%E7%AE%80%E5%8D%95CSS3-JQ%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%843D%E7%BF%BB%E8%BD%AC/"/>
      <url>/blog/2018/05/10/%E5%8E%9F-%E7%AE%80%E5%8D%95CSS3-JQ%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%843D%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>没想到刚开始没两天就突然断了。还是要时刻鞭策自己啊。</p><p>主要实现效果：鼠标从不同的方向进入图片，图片所在的正方体就会以此方向翻转，显示文字介绍。</p><p>效果如下图</p><p><img src="https://img-blog.csdn.net/20180510221255147?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>此处的正方体只是形象的比喻方便理解。</p><p>如下图为计算机的坐标系，文字介绍所在块（后面简称B）与图片块（后面简称A）放于同一平面，但在Z轴上相差2px。</p><p>A与B被包在块C之中。</p><p><img src="https://img-blog.csdn.net/20180510224944729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><ul><li>图片旋转</li></ul><p>当鼠标从上侧进入时，<strong>思路是</strong>先将后侧的B向上移动自身长度的距离，然后向上绕y轴向屏幕内侧旋转90度，得到A与B垂直的效果，即A仍在xoy平面，而B在yoz平面（具体什么样子，就不画图了。实在是画出来太难看了。）此时，若直接旋转C，就可以达到同时旋转A与B的效果，让C向下绕y轴向屏幕内侧旋转90度，B就会旋转到xoy平面，平行于屏幕，A就会旋转到yoz平面，垂直于屏幕。</p><p>当鼠标从其他三个方向进入时的思路与上侧进入的思路相类似，只是方向不同。</p><ul><li>鼠标进入方向的确定</li></ul><p>当明确了A与B的旋转之后，就要<strong>考虑如何获取鼠标是从哪个方向进入</strong>的了。</p><p>首先，我们重新创建一个坐标轴，以图片即A的中心为坐标原点，如下图所示。</p><p><img src="https://img-blog.csdn.net/20180510224617351?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>然后我们只需要知道鼠标当前的坐标在我们的新坐标系中的位置即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width,<span class="comment">//图片宽度</span></span><br><span class="line">    height,<span class="comment">//图片高度</span></span><br><span class="line">    left,<span class="comment">//图片在默认坐标系中的x偏移量</span></span><br><span class="line">    top;<span class="comment">//图片在默认坐标系中的y偏移量</span></span><br><span class="line">x = e.pageX - left - width / <span class="number">2</span>;</span><br><span class="line">y = e.pageY - top - height / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>知道了鼠标在新坐标系中的位置后，接下来就需要计算鼠标进入的方向了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d=(<span class="built_in">Math</span>.round(((<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI))+<span class="number">180</span>)/<span class="number">90</span>)+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Math</span>.atan2(y,x) <span class="comment">//返回x轴到(x,y)的角度的弧度值</span></span><br><span class="line">(<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI) <span class="comment">//将弧度值转换成角度</span></span><br><span class="line">((<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI))+<span class="number">180</span>)<span class="comment">//加180是为了将0度转换到x轴负半轴使角度看起来方便</span></span><br><span class="line">((<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI))+<span class="number">180</span>)/<span class="number">90</span><span class="comment">//除以90会得到一个0-4之间的浮点数</span></span><br><span class="line"><span class="built_in">Math</span>.round(((<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI))+<span class="number">180</span>)/<span class="number">90</span>)<span class="comment">//此操作将浮点数转换成正整数，此时还不能直接用，是因为此时的数字仍然表示的90度的范围，而不是某一方向</span></span><br><span class="line"><span class="built_in">Math</span>.round(((<span class="built_in">Math</span>.atan2(y,x)*(<span class="number">180</span>/<span class="built_in">Math</span>.PI))+<span class="number">180</span>)/<span class="number">90</span>)%<span class="number">4</span><span class="comment">//此操作将数字转换成了专指某一方向，0-左，1-上，2-右，3-下</span></span><br></pre></td></tr></table></figure><p>解决了这个问题，剩下的就是简单的DOM操作了。下面附上源码。</p><iframe height="530" style="width: 100%;" scrolling="no" title="JjPXQyX" src="//codepen.io/jacoxxx/embed/JjPXQyX/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/jacoxxx/pen/JjPXQyX/" target="_blank" rel="noopener">JjPXQyX</a> by Jaco Wu  (<a href="https://codepen.io/jacoxxx" target="_blank" rel="noopener">@jacoxxx</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>(完)</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 3D翻转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]jQuery实现翻页插件</title>
      <link href="/blog/2018/04/25/%E5%8E%9F-jQuery%E5%AE%9E%E7%8E%B0%E7%BF%BB%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
      <url>/blog/2018/04/25/%E5%8E%9F-jQuery%E5%AE%9E%E7%8E%B0%E7%BF%BB%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>使用编辑器：vs code</p><p>主要用到的技术：css3 + jQuery</p><ul><li>html:这次html里面也没写什么东西，主要实在js文件中利用for循环动态生成结构。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>翻页插件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"fycj.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"fycj.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'.page'</span>).create(&#123;</span></span><br><span class="line"><span class="javascript">            pageCount:<span class="number">20</span>,<span class="comment">//总页数</span></span></span><br><span class="line"><span class="javascript">            current:<span class="number">5</span>,<span class="comment">//当前页码</span></span></span><br><span class="line"><span class="javascript">            backFn:<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;&#125;<span class="comment">//回调函数</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>css文件：</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.noPre</span>,</span><br><span class="line"><span class="selector-class">.current</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#428bca</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#428bca</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.noPre</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#eee</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.current</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#428bca</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>js文件：内容看注释好了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">dom,arg</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断传入的页码是否符合标准</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current &lt;= arg.pageCount)&#123;</span><br><span class="line">            fillhtml(dom,arg);</span><br><span class="line">            bindEvent(dom,arg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">'请输入正确的页码'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态构建网页内容</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fillhtml</span>(<span class="params">dom,arg</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//清空页面布局</span></span><br><span class="line">        dom.empty();</span><br><span class="line">        <span class="comment">//大体分三部分：上一页，中间页码，下一页</span></span><br><span class="line">        <span class="comment">//上一页</span></span><br><span class="line">        <span class="comment">//上一页又分为可点击与不可点击两种</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;a class="prePage" href="#"&gt;上一页&lt;/a&gt;'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dom.remove(<span class="string">'.prePage'</span>);</span><br><span class="line">            dom.append(<span class="string">'&lt;span class="noPre"&gt;上一页&lt;/span&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间页码</span></span><br><span class="line">        <span class="comment">//中间页码又分为中间可显示的5个页码与...与两端的页码</span></span><br><span class="line">        <span class="comment">//第一页</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current != <span class="number">1</span> &amp;&amp; arg.current &gt; <span class="number">3</span>)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;a class="tcdNum" href="#"&gt;1&lt;/a&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前页面是否距离第一页大于3，是则需要...</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current<span class="number">-3</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;span&gt;...&lt;/span&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断中间需要显示的页码</span></span><br><span class="line">        <span class="keyword">var</span> start = arg.current<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">var</span> end = arg.current+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(;start &lt;= end;start++)&#123;</span><br><span class="line">            <span class="comment">//判断开始页面是否大于1且是否小于最大页码</span></span><br><span class="line">            <span class="keyword">if</span>(start &gt;= <span class="number">1</span> &amp;&amp; start &lt;= arg.pageCount)&#123;</span><br><span class="line">                <span class="comment">//判断是否是选中页面</span></span><br><span class="line">                <span class="keyword">if</span>(start == arg.current)&#123;</span><br><span class="line">                    dom.append(<span class="string">'&lt;span class="current"&gt;'</span>+start+<span class="string">'&lt;/span&gt;'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dom.append(<span class="string">'&lt;a class="tcdNum" href="#"&gt;'</span>+start+<span class="string">'&lt;/a&gt;'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后置的...</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current+<span class="number">3</span> &lt; arg.pageCount)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;span&gt;...&lt;/span&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一页</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current != arg.pageCount &amp;&amp; arg.current &lt; arg.pageCount<span class="number">-2</span>)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;a class="tcdNum" href="#"&gt;'</span>+arg.pageCount+<span class="string">'&lt;/a&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下一页</span></span><br><span class="line">        <span class="comment">//下一页与上一页类似</span></span><br><span class="line">        <span class="keyword">if</span>(arg.current &lt; arg.pageCount)&#123;</span><br><span class="line">            dom.append(<span class="string">'&lt;a class="nextPage" href="#"&gt;下一页&lt;/a&gt;'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dom.remove(<span class="string">'.prePage'</span>);</span><br><span class="line">            dom.append(<span class="string">'&lt;span class="noPre"&gt;下一页&lt;/span&gt;'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">dom,arg</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//分为点击上一页，点击页码与点击下一页</span></span><br><span class="line">        <span class="comment">//点击上一页</span></span><br><span class="line">        <span class="comment">//获得当前页面，-1 然后调用fillhtml重绘页面</span></span><br><span class="line">        dom.on(<span class="string">'click'</span>,<span class="string">'.prePage'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cur=<span class="built_in">parseInt</span>(dom.children(<span class="string">'.current'</span>).text());</span><br><span class="line">            fillhtml(dom,&#123;<span class="string">'current'</span>:cur<span class="number">-1</span>,<span class="string">'pageCount'</span>:arg.pageCount&#125;);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> arg.backFn==<span class="string">'function'</span>)&#123;</span><br><span class="line">                arg.backFn(cur<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//点击页码</span></span><br><span class="line">        <span class="comment">//获得点击页码，调用fillhtml重绘页面</span></span><br><span class="line">        dom.on(<span class="string">'click'</span>,<span class="string">'.tcdNum'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cur=<span class="built_in">parseInt</span>($(<span class="keyword">this</span>).text());</span><br><span class="line">            fillhtml(dom,&#123;<span class="string">'current'</span>:cur,<span class="string">'pageCount'</span>:arg.pageCount&#125;);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> arg.backFn==<span class="string">'function'</span>)&#123;</span><br><span class="line">                arg.backFn(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//点击下一页</span></span><br><span class="line">        <span class="comment">//获得当前页面，+1 然后调用fillhtml重绘页面</span></span><br><span class="line">        dom.on(<span class="string">'click'</span>,<span class="string">'.nextPage'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cur=<span class="built_in">parseInt</span>(dom.children(<span class="string">'.current'</span>).text());</span><br><span class="line">            fillhtml(dom,&#123;<span class="string">'current'</span>:cur+<span class="number">1</span>,<span class="string">'pageCount'</span>:arg.pageCount&#125;);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> arg.backFn==<span class="string">'function'</span>)&#123;</span><br><span class="line">                arg.backFn(cur+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展jquery封装函数</span></span><br><span class="line">    $.fn.create=<span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//      extend函数：当调用create时，如果传了参数option</span></span><br><span class="line"><span class="comment">//      则使用传入的参数，否则使用预定义的参数</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">        <span class="keyword">var</span> arg=$.extend(&#123;</span><br><span class="line">            pageCount:<span class="number">10</span>,</span><br><span class="line">            current:<span class="number">2</span>,</span><br><span class="line">            backFn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        &#125;,option)</span><br><span class="line">        init(<span class="keyword">this</span>,arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://img-blog.csdn.net/20180425213857431?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>欢迎留言批评指正。</p><p>(完)</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
            <tag> 翻页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]css3+jquery实现简单时钟特效</title>
      <link href="/blog/2018/04/22/%E5%8E%9F-css3-jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%97%B6%E9%92%9F%E7%89%B9%E6%95%88/"/>
      <url>/blog/2018/04/22/%E5%8E%9F-css3-jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%97%B6%E9%92%9F%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>初探前端开发，前期写一些小demo，后期会慢慢写些学习经验，欢迎各位看官交流学习经验（QQ:1759668379）</p><p>这个时钟特效是在腾讯课堂看渡一的js直播课时学到的，废话不多说，直接上源码。</p><ul><li>html文件：很简单的用div写整体框架，但是没有用到js动态生成div块。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html</span></span><br><span class="line"><span class="meta">        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</span></span><br><span class="line"><span class="meta">        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>数字时钟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"demo.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"colt"</span>&gt;</span>:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"colt"</span>&gt;</span>:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"demo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CSS文件：为了提高可读性，所以css部分完全与html部分分离</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#0e141b</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span>,</span><br><span class="line"><span class="selector-class">.colt</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgba</span>(224, 230,235,0.89);</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">86px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">86px</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: transform <span class="number">300ms</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.colt</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(calc(50vh - 43px));</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>:opacity <span class="number">500ms</span>,text-shadow <span class="number">400ms</span>;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">0.25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> <span class="selector-class">.visible</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>:<span class="number">1px</span> <span class="number">1px</span> <span class="number">30px</span> <span class="number">#336699</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> <span class="selector-class">.close</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">0.35</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> <span class="selector-class">.far</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> <span class="selector-class">.dis</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>js文件：主要是针对对象，所有代码全部放在原型链上。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params">dom,use24H</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.column=<span class="built_in">Array</span>.from(dom);<span class="comment">//组件类</span></span><br><span class="line">    <span class="keyword">this</span>.use24H=use24H;<span class="comment">//时间</span></span><br><span class="line">    <span class="keyword">this</span>.classList=[<span class="string">'visible'</span>,<span class="string">'close'</span>,<span class="string">'far'</span>,<span class="string">'far'</span>,<span class="string">'dis'</span>,<span class="string">'dis'</span>];<span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">this</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始--》获取到当前时间</span></span><br><span class="line"><span class="comment">// --》当前时间 14 17 35 --&gt;字符串141735</span></span><br><span class="line"><span class="comment">//--&gt;六个数与六个类名为column的div分别对应上</span></span><br><span class="line"><span class="comment">//--&gt;分别找到每一列为当前时间的数字垂直局中显示 --根据数字大小调节在Y轴上移动的距离</span></span><br><span class="line"><span class="comment">//--&gt;同一列中不同数字位置不同 透明度不同（根据为每一个数字见不同的类名实现）</span></span><br><span class="line"> </span><br><span class="line">Index.prototype.start=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> c=self.getClock();</span><br><span class="line">       self.column.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index</span>) </span>&#123;<span class="comment">//遍历所有column类对象</span></span><br><span class="line">           <span class="keyword">var</span> n=+c[index];<span class="comment">//第n列</span></span><br><span class="line">           <span class="keyword">var</span> offset=n*<span class="number">86</span>;</span><br><span class="line">           $(ele).css(&#123;</span><br><span class="line">               <span class="string">'transform'</span>:<span class="string">'translateY(calc(50vh - '</span> + offset + <span class="string">'px - '</span> + <span class="number">43</span> + <span class="string">'px))'</span>  <span class="comment">//对应数字垂直居中显示</span></span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="built_in">Array</span>.from(ele.children).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele2,index2</span>) </span>&#123;<span class="comment">//遍历column中的所有div</span></span><br><span class="line">               <span class="keyword">var</span> className=self.getClassName(n,index2);<span class="comment">//获取类名</span></span><br><span class="line">               $(ele2).attr(<span class="string">'class'</span>,className)<span class="comment">//动态添加类名</span></span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>)<span class="comment">//1秒刷新一次</span></span><br><span class="line">&#125;</span><br><span class="line">Index.prototype.getClassName=<span class="function"><span class="keyword">function</span>(<span class="params">n,index2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> className=<span class="keyword">this</span>.classList.find(<span class="function"><span class="keyword">function</span> (<span class="params">className,classindex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index2-classindex===n||index2+classindex===n;<span class="comment">//查找符合此方法的值</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> className||<span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">Index.prototype.getClock=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d=<span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>.use24H?d.getHours():d.getHours()%<span class="number">12</span>||<span class="number">12</span>,</span><br><span class="line">    d.getMinutes(),d.getSeconds()].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">p,n</span>) </span>&#123;<span class="comment">//累加函数</span></span><br><span class="line">        <span class="keyword">return</span> (p+(<span class="string">'0'</span>+n).slice(<span class="number">-2</span>));<span class="comment">//保留后两位</span></span><br><span class="line">    &#125;,<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Index($(<span class="string">'.column'</span>),<span class="literal">true</span>);<span class="comment">//new一个对象</span></span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://img-blog.csdn.net/20180425214114148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY29veA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>欢迎留言批评指正。</p><p>（完。）</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> 时钟特效 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]c++简单24点游戏</title>
      <link href="/blog/2017/04/12/%E5%8E%9F-c-%E7%AE%80%E5%8D%9524%E7%82%B9%E6%B8%B8%E6%88%8F/"/>
      <url>/blog/2017/04/12/%E5%8E%9F-c-%E7%AE%80%E5%8D%9524%E7%82%B9%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，用擅长的语言（C/C++/Java或其他均可）实现程序解决问题。</p><ol><li><p>程序风格良好(使用自定义注释模板)</p></li><li><p>列出表达式无重复。</p></li></ol><p>以下为源代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">char card[] = &#123; 'A','2','3','4','5','6','7','8','9','10','J','Q','K' &#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">double</span> nums[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> ope[<span class="number">4</span>] = &#123; <span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cre</span><span class="params">()</span><span class="comment">//生成</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"生成的四张牌面为："</span>;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">j =rand() % <span class="number">13</span>;</span><br><span class="line">buf[i] = card[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf[<span class="number">0</span>] &lt;&lt; <span class="string">";"</span> &lt;&lt; buf[<span class="number">1</span>] &lt;&lt; <span class="string">";"</span> &lt;&lt; buf[<span class="number">2</span>] &lt;&lt; <span class="string">";"</span> &lt;&lt; buf[<span class="number">3</span>] &lt;&lt; <span class="string">"。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (buf[i] == <span class="string">'A'</span>) nums[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(buf[i] == <span class="string">'2'</span>) nums[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'3'</span>) nums[i] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'4'</span>) nums[i] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'5'</span>) nums[i] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'6'</span>) nums[i] = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'7'</span>) nums[i] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'8'</span>) nums[i] = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'9'</span>) nums[i] = <span class="number">9</span>;</span><br><span class="line">else if (buf[i] == '10') nums[i] = 10;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'J'</span>) nums[i] = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'Q'</span>) nums[i] = <span class="number">12</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">'K'</span>) nums[i] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcute</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="string">'+'</span>) <span class="keyword">return</span> a + b;  <span class="comment">//若为+，则返回相应结果   </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="string">'-'</span>) <span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="string">'*'</span>) <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> a / b;    <span class="comment">//只有当分母不为0时，返回结果 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exh</span><span class="params">()</span><span class="comment">//穷举计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span>  temp[<span class="number">3</span>], tem[<span class="number">2</span>];   <span class="comment">//第一个符号放置后，经过计算后相当于剩下三个数，这个数组用于存储这三个数  </span></span><br><span class="line"><span class="keyword">double</span>  sum;  <span class="comment">//求得的和  </span></span><br><span class="line"><span class="keyword">int</span>  judge = <span class="number">0</span>;   <span class="comment">//判断是否找到一个合理的解   </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)  <span class="comment">//第一次放置的符号  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)   <span class="comment">//第二次放置的符号   </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)    <span class="comment">//第三次放置的符号    </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">3</span>; m++)      <span class="comment">//首先计算的两个相邻数字，共有3种情况，相当于括号的作用     </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[m + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ope[i] == <span class="string">'/'</span>) <span class="keyword">break</span>;</span><br><span class="line">temp[m] = calcute(nums[m], nums[m + <span class="number">1</span>], ope[i]);</span><br><span class="line">temp[(m + <span class="number">1</span>) % <span class="number">3</span>] = nums[(m + <span class="number">2</span>) % <span class="number">4</span>];</span><br><span class="line">temp[(m + <span class="number">2</span>) % <span class="number">3</span>] = nums[(m + <span class="number">3</span>) % <span class="number">4</span>];      <span class="comment">//先确定首先计算的两个数字，计算完成相当于剩下三个数，按顺序储存在temp数组中       </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">2</span>; n++)       <span class="comment">//三个数字选出先计算的两个相邻数字，两种情况，相当于第二个括号       </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp[n + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ope[j] == <span class="string">'/'</span>) <span class="keyword">break</span>;</span><br><span class="line">tem[n] = calcute(temp[n], temp[n + <span class="number">1</span>], ope[j]);</span><br><span class="line">tem[(n + <span class="number">1</span>) % <span class="number">2</span>] = temp[(n + <span class="number">2</span>) % <span class="number">3</span>];        <span class="comment">//先确定首先计算的两个数字，计算完成相当于剩下两个数，按顺序储存在temp数组中        </span></span><br><span class="line"><span class="keyword">if</span> (tem[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ope[k] == <span class="string">'/'</span>) <span class="keyword">break</span>;</span><br><span class="line">sum = calcute(tem[<span class="number">0</span>], tem[<span class="number">1</span>], ope[k]);       <span class="comment">//计算和               </span></span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">24</span>)        <span class="comment">//若和为24       </span></span><br><span class="line">&#123;</span><br><span class="line">judge = <span class="number">1</span>;         <span class="comment">//判断符为1，表示已求得解          </span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"(("</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[j] &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[k] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">"="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[k] &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; ope[j] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">")="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[j] &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[k] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">"="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[k] &lt;&lt; <span class="string">"(("</span> &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[j] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">")="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">2</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[j] &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; <span class="string">")"</span> &lt;&lt; ope[k] &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">")="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">2</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; ope[k] &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">1</span>] &lt;&lt; ope[j] &lt;&lt; <span class="string">"("</span> &lt;&lt; nums[<span class="number">2</span>] &lt;&lt; ope[i] &lt;&lt; nums[<span class="number">3</span>] &lt;&lt; <span class="string">"))="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//m=0,1,2 n=0,1表示六种括号放置可能，并按照这六种可能输出相应的格式的计算式               </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (judge == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"这四张扑克牌无法找到一个合理的解"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//如果没有找到结果，符号位为0 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"################################################"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                                              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#              欢迎进入24点游戏                #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                                              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"################################################"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"################################################"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                                              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                是否开始游戏                  #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                                              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#          0.是              1.否              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"#                                              #"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"################################################"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你的选择（0或1）："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">cre();</span><br><span class="line">exh();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请在0和1之间选择！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170412202852472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图1"></p><p><img src="https://img-blog.csdn.net/20170412202749768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图2"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 24点游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]c语言求两个数的最大公约数</title>
      <link href="/blog/2017/03/22/%E5%8E%9F-c%E8%AF%AD%E8%A8%80%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/blog/2017/03/22/%E5%8E%9F-c%E8%AF%AD%E8%A8%80%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>从键盘输入两个整数，输出两个整数的最大公约数。</p><ol><li><p>程序风格良好(使用自定义注释模板)</p></li><li><p>使用三种算法解决问题</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">common</span>&#123;</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>;<span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>;<span class="comment">//相减法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exh</span><span class="params">()</span></span>;<span class="comment">//穷举法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = m;</span><br><span class="line">b = n;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">x = a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x = a;</span><br><span class="line">a = b;</span><br><span class="line">b = x;</span><br><span class="line">x = a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = b;</span><br><span class="line">b = x;</span><br><span class="line">x = a%b;</span><br><span class="line">&#125;</span><br><span class="line">printf_s(<span class="string">"最大公约数是%d。\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//相减法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = m;</span><br><span class="line">b = n;</span><br><span class="line"><span class="keyword">while</span> (a!=b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b = b - a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf_s(<span class="string">"最大公约数是%d。\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//穷举法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = m;</span><br><span class="line">b = n;</span><br><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  ( x = b; x &gt; <span class="number">0</span>;  x--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a%x == <span class="number">0</span> &amp;&amp; b%x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = x;</span><br><span class="line">printf_s(<span class="string">"最大公约数是%d。\n"</span>, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>  (x = a; x &gt;  <span class="number">0</span>; x--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a%x == <span class="number">0</span> &amp;&amp; b%x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = x;</span><br><span class="line">printf_s(<span class="string">"最大公约数是%d。\n"</span>, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (select)</span><br><span class="line">&#123;</span><br><span class="line">printf_s(<span class="string">"请输入两个数(并以英文逗号隔开)："</span>);</span><br><span class="line">scanf_s(<span class="string">"%d,%d"</span>, &amp;m, &amp;n);</span><br><span class="line">printf_s(<span class="string">"\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              *********************************************************\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #                                                       #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #               求两数最大公约数                        #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #                                                       #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              *********************************************************\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #                                                       #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #       0.辗转相除法          1.相减法                  #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #                                                       #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #       2.穷举法              3.退出系统                #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              #                                                       #\n"</span>);</span><br><span class="line">printf_s(<span class="string">"              *********************************************************\n"</span>);</span><br><span class="line">printf_s(<span class="string">"\n"</span>);</span><br><span class="line">printf_s(<span class="string">"                    请选择您需要的操作序号(0-3)按回车确认:"</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">printf_s(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">div();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">sub();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">exh();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">printf_s(<span class="string">"请在0-3之间选择\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果图：</p><p><img src="https://img-blog.csdn.net/20170322171001543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图1"></p><p><img src="https://img-blog.csdn.net/20170322171142529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图2"></p><p><img src="https://img-blog.csdn.net/20170322171151471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图3"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]c初级打渔晒网问题</title>
      <link href="/blog/2017/03/14/%E5%8E%9F-c%E5%88%9D%E7%BA%A7%E6%89%93%E6%B8%94%E6%99%92%E7%BD%91%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2017/03/14/%E5%8E%9F-c%E5%88%9D%E7%BA%A7%E6%89%93%E6%B8%94%E6%99%92%E7%BD%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>原题目：某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。</p><p>以下是程序源代码，初学者可能在很多地方不是很完善。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> year, month, day;</span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//闰年</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//闰年个数</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//平年个数</span></span><br><span class="line"><span class="keyword">int</span> y_s, m_s;<span class="comment">//年月差</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//总日差</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;<span class="comment">//判断打渔晒网</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断年份</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断年分输入是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (year &lt; <span class="number">2010</span>) &#123;</span><br><span class="line">        printf_s(<span class="string">"year error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断闰年</span></span><br><span class="line">        <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算年份</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    j = (year - <span class="number">2010</span>) / <span class="number">4</span>;<span class="comment">//计算闰年个数</span></span><br><span class="line">    k = (year - <span class="number">2010</span>) - j;<span class="comment">//计算平年个数</span></span><br><span class="line">    y_s = <span class="number">366</span> * j + <span class="number">365</span> * k;<span class="comment">//计算年份差</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断月份差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j_m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    judge();</span><br><span class="line">    <span class="keyword">if</span> (i = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//计算月份差</span></span><br><span class="line">        <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                m_s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                m_s = <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                m_s = <span class="number">59</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                m_s = <span class="number">90</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                m_s = <span class="number">120</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                m_s = <span class="number">151</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                m_s = <span class="number">181</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                m_s = <span class="number">212</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                m_s = <span class="number">243</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                m_s = <span class="number">273</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                m_s = <span class="number">304</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                m_s = <span class="number">334</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                printf_s(<span class="string">"month error!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//计算月份差</span></span><br><span class="line">        <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                m_s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                m_s = <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                m_s = <span class="number">58</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                m_s = <span class="number">89</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                m_s = <span class="number">119</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                m_s = <span class="number">150</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                m_s = <span class="number">180</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                m_s = <span class="number">211</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                m_s = <span class="number">242</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                m_s = <span class="number">272</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                m_s = <span class="number">303</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                m_s = <span class="number">333</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                printf_s(<span class="string">"month error!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断打渔晒网</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reckon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t = y_s + m_s + day;</span><br><span class="line">    r = t % <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//判断打渔晒网</span></span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            printf_s(<span class="string">"今天晒网\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            printf_s(<span class="string">"今天打渔\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            printf_s(<span class="string">"今天晒网\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断日子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">j_d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (month == <span class="number">1</span> || month == <span class="number">3</span> || month == <span class="number">5</span> || month == <span class="number">7</span> || month == <span class="number">8</span> || month == <span class="number">10</span> || month == <span class="number">12</span>  ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (day&lt;<span class="number">1</span>||day&gt;<span class="number">31</span>) &#123;</span><br><span class="line">            printf_s(<span class="string">"day error!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reckon();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (day&lt;<span class="number">1</span> || day&gt;<span class="number">30</span>) &#123;</span><br><span class="line">                printf_s(<span class="string">"day error!\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reckon();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i=<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (day&lt;<span class="number">1</span> || day&gt;<span class="number">29</span>) &#123;</span><br><span class="line">                    printf_s(<span class="string">"day error!\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reckon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (day&lt;<span class="number">1</span> || day&gt;<span class="number">28</span>) &#123;</span><br><span class="line">                    printf_s(<span class="string">"day error!\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reckon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choose=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (choose) &#123;</span><br><span class="line">        printf_s(<span class="string">"请输入一个日期（在2010.1.1以后的日期）并以英文逗号隔开：\n"</span>);</span><br><span class="line">        scanf_s(<span class="string">"%d,%d,%d"</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line">        <span class="keyword">if</span> (judge()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j_m()) &#123;</span><br><span class="line">                j_d();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf_s(<span class="string">"继续请输入1，结束请输入0：\n"</span>);</span><br><span class="line">        scanf_s(<span class="string">"%d"</span>,&amp;choose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果图：</p><p><img src="https://img-blog.csdn.net/20170314224547180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFjb294/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 打鱼晒网 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
